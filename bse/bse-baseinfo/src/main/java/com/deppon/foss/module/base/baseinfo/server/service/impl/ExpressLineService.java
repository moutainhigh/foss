/*******************************************************************************
 * Copyright 2013 BSE TEAM
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * PROJECT NAME	: bse-baseinfo
 * 
 * FILE PATH        	: src/main/java/com/deppon/foss/module/base/baseinfo/server/service/impl/ExpressLineService.java
 * 
 * FILE NAME        	: ExpressLineService.java
 * 
 * AUTHOR			: FOSS综合管理开发组
 * 
 * HOME PAGE		:  http://www.deppon.com
 * 
 * COPYRIGHT		: Copyright (c) 2013  Deppon All Rights Reserved.
 ******************************************************************************/
/*
 * Copyright by Deppon and the original author or authors.
 * 
 * This document only allow internal use ,Any of your behaviors using the file
 * not internal will pay legal responsibility.
 *
 * You may learn more information about Deppon from
 *
 *      http://www.deppon.com
 *
 */ 


/**


dp-foss-综合管理系统用例-新增_修改_作废_查询始发线路-v1.04

修订记录 	
日期 	修订内容 	修订人员 	版本号 
2012-6-15	新增	谢艳涛	V0.1
2012-6-19	根据王偕旭点评修改	谢艳涛	V0.2
2012-6-28	根据赵鹏点评修改： “准点到达时间”采用T+1的格式进行表示；增加一些业务规则	谢艳涛	V0.2
2012-6-30	根据王偕旭要求添加：“线路简码”、“管理车队”等属性	谢艳涛	V0.3
2012-7-2	提交CITA审核	谢艳涛	V0.5
2012-7-23	根据评审会议评委意见修改：“线路名称”改为自动生成，修订生成业务规则	谢艳涛	V0.6
2012-8-2	通过业务部门审核签字版本升级到V0.9	谢艳涛	V0.9
2012-10-12	根据变更需求修改：在图二界面中添加“是否默认始发线路”字段及单选按钮；去掉规则SR5中“精确查询”	谢艳涛	V1.01
2012-10-16	根据变更需求增加导出功能：在图一界面增加“导出”按钮	谢艳涛	V1.02
2012-12-01	根据变更需求把发车标准“班次”自动生成改为自行维护	谢艳涛	V1.03
2012-12-11	根据变更需求修改发车标准，增加“时效类型”：普车、卡车两种	谢艳涛	V1.04

1.	SUC-284-新增_修改_作废_查询始发线路
1.1	相关业务用例
BUC_FOSS_5.20.30_530 开单收货
BUC_FOSS_5.20.20_520 接货运单开单
1.2	用例描述
始发线路即经营到运作的线路，主要用于查询营业部的始发配载部门，便于收货开单使用。本用例主要用于对始发线路（经营到运作的线路）基础资料维护，包括新增、修改、作废、查询操作。
1.3	用例条件
条件类型	描述	引用系统用例
前置条件	1、	行政组织基础资料完备
2、	行政区域基础资料完备	SUC-33 DP-FOSS-综合管理系统用例-新增_修改_作废_查询行政区域
SUC-85 DP-FOSS-综合管理系统用例-修改_查询行政组织业务属性

后置条件	1、	为SUC-486 生成运单系统用例提供始发线路基础资料查询	SUC-486 生成运单

1.4	操作用户角色
操作用户	描述
线路维护人员	线路维护人员对始发线路进行新增，修改，作废，查询操作。
1.5	界面要求
1.5.1	表现方式
Web页面
1.5.2	界面原型-主界面
 
 
图一：始发线路主界面
1.5.3	界面描述-主界面
1.	功能按钮区域
1)	新增按钮：点击新增按钮进入新增界面，参见【图二：新增/修改始发线路】。
2)	导出按钮：点击导出按钮，可以导出始发线路的所有数据至Excel表中
3)	查询按钮：输入查询条件，点击查询按钮，系统返回查询结果，刷新查询列表。
4)	重置按钮：点击重置按钮，清空查询条件。
5)	作废按钮：选中列表中一行或多行记录，点击作废按钮，选中的记录被作废；或点击各行的作废图标，作废各行记录，作废时连同作废该线路对应的发车标准，需要弹出确认提示框。
6)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
7)	修改按钮：点击各行的修改按钮，进入修改界面，参见【图二：新增/修改始发线路】。
8)	分页按钮：实现分页功能。
2.	列表区域
1)	列表区域默认不显示，点击查询按钮，根据查询条件显示列表数据。
2)	列表中显示：线路名称、始发站、到达站、始发城市、运输类型、是否默认始发线路。
3.	字段输入区域
1)	查询条件包括线路名称、始发站、到达站、始发城市、运输类型、管理车队、线路简码。
1.1	线路名称：文本，支持模糊查询
1.2	始发站：选择框，支持手动输入模糊查询，也支持从行政组织（营业部）基础资料中选取
1.3	到达站：选择框，支持手动输入模糊查询，也支持从行政组织（外场、空运总调）基础资料中选取
1.4	始发城市：选择框，支持手动输入模糊查询，也支持从行政区域（城市）基础资料中选取
1.5	运输类型：下拉框，默认为全部，包括：全部、汽运、空运
1.6	管理车队：选择框，支持手动输入模糊查询，也支持从行政组织（车队）基础资料中选取
1.7	线路简码：文本，支持模糊查询

1.5.4	界面原型-新增/修改始发线路
  
图二：新增/修改始发线路
1.5.5	界面描述-新增和修改始发线路
1.	字段输入区域
1)	线路名称： 自动生成，生成规则：根据所选“始发站”和“到达站”动态生成,如：生成线路名称为XXX营业部-XXX外场 
2)	线路简码：必填，文本，线路简码必须唯一
3)	管理车队：必填，选择框，从行政组织（车队）基础资料中选取
4)	运输类型：必填，下拉框，包含汽运、空运
5)	始发站：必填，选择框，从行政组织（营业部）基础资料中选取
6)	始发城市：与“始发站”联动获取，只读
7)	到达站：必填，选择框，从行政组织（外场、空运总调）基础资料中选取
8)	是否默认始发线路：必填，单选按钮，是或否
9)	线路距离（公里）：必填，数字
10)	备注：选填，文本
2．	 发车标准列表区域
1)          列表中显示：班次、准点出发时间、准点到达时间、时效类型、备注。
3.   功能按钮区域
1)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭当前界面，返回主界面；若保存失败，提示用户保存失败以及失败原因，不关闭当前界面。
2)	重置按钮：点击重置按钮，回到当前界面的初始状态。
3)	取消按钮：点击取消按钮，退出当前界面，返回主界面。
4)	新增发车标准按钮：点击新增发车标准按钮，先判断始发线路信息是否已经保存，如果信息还未保存，弹出提醒框，提醒需要保存线路信息才能新增发车标准；如果信息已经保存成功，则弹出【图三：新增和修改发车标准】界面，进行新增操作，详细步骤参见【新增发车标准操作步骤】。
5)	修改按钮：点击修改按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能修改发车标准，详细步骤参见【修改发车标准操作步骤】；
6)	作废按钮：点击作废按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能作废发车标准，详细步骤参见【作废发车标准操作步骤】。
7)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
1.5.6	界面原型-新增/修改发车标准
  
    图三：新增和修改发车标准
1.5.7	界面描述-新增/修改发车标准
1、字段输入区域
1)	班次： 数字，用户自行维护，自然数自动生成，同一条线路上班次从1开始，按照准点出发时间顺序排序。
2)	准点出发时间：必填，时间格式：08:00,09:30等
3)	始发站：自动带出
4)	准点到达时间：必填，采用T+1格式，T是指时间，如：00:30；+1天是指当天时间加1天，如：00:30+1，表示第二天的00:30；XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示。
5)	到达站：自动带出
5)6)	时效类型：下拉框，包括：普车、卡车两种时效类型；
6)7)	备注：选填
       2、功能按钮区域
              1)          保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭弹出窗口，返回到【图二：新增/修改始发线路】；若保存失败，提示用户保存失败以及失败原因，不关闭弹出窗口。
   2)          重置按钮：点击重置按钮，回到当前界面的初始状态。
 3)          取消按钮：点击取消按钮，关闭当前界面，返回到【图二：新增/修改始发线路】界面。
1.6	操作步骤
1.6.1	添加始发线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入始发线路管理主界面	【始发线路列表信息】	
2	点击新增按钮，进入【图二：新增/修改始发线路】界面		
3	输入始发线路详细信息和相关发车标准信息，点击保存。
参见业务规则SR-1、SR-2、SR-3、SR-6、SR-7	【始发线路新增/修改信息】【发车标准列表信息】【发车标准信息】	
4	返回始发线路管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.2	修改始发线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入始发线路管理主界面	【始发线路列表信息】	
2	点击修改按钮，进入【图二：新增/修改始发线路】界面		
3	修改始发线路详细信息和发车标准信息,点击保存
参见业务规则SR-1、SR-2、SR-3、SR-6、SR-7	【始发线路新增/修改信息】【发车标准列表信息】【发车标准信息】	
4	返回始发线路管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.3	作废始发线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入始发线路管理主界面	【始发线路列表信息】	
2	选择一行或者多行记录，点击作废按钮。		作废时连同作废该线路对应的发车标准，弹出确认对话框。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.6.4	查询始发线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入始发线路管理主界面	【始发线路列表信息】	
2	输入查询条件，点击查询按钮。参见业务规则SR-5	【始发线路查询条件】	系统返回查询结果

1.6.5	新增发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改始发线路】界面	【始发线路新增/修改信息】【发车标准列表信息】	
2	点击新增发车标准按钮，先判断始发线路信息是否保存，若已保存，弹出【图二：新增/修改发车标准】界面；若未保存，先保存始发线路信息，再点击新增发车标准按钮。		
3	输入发车标准详细信息，点击保存。
参见业务规则SR-1、SR-2、SR-4、SR-8	【发车标准信息】	
4	返回【图二：新增/修改始发线路】界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图二：新增/修改始发线路】界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.6	修改发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改始发线路】界面	【始发线路新增/修改信息】【发车标准列表信息】	
2	点击修改发车标准按钮，先判断始发线路信息是否修改，若未修改，弹出【图二：新增/修改发车标准】界面；若已修改，先保存始发线路信息，再点击修改发车标准按钮。		
3	输入发车标准详细信息，点击保存。
参见业务规则SR-1、SR-2、SR-4、SR-8	【发车标准信息】	
4	返回【图二：新增/修改始发线路】界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图二：新增/修改始发线路】界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.7	作废发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改始发线路】界面	【【始发线路新增/修改信息】【发车标准列表信息】	
2	选择一行记录，点击作废按钮。		弹出确认对话框。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.7	业务规则
序号	描述
SR-1	“始发站”不支持手动输入，只支持从行政组织（营业部）基础资料中选取； 
SR-2	“到达站”不支持手动输入，只支持从行政组织（外场、空运总调）基础资料中选取；若运输类型为“汽运”，则到达部门只能是外场，若运输类型为“空运”，则到达部门可以是外场或空运总调。
SR-3	“始发城市”与“始发站”联动获取，只读。
SR-4	时间通过“时间控件”选取，格式：08:00,09:30;“准点到达时间”采用T+1格式，T是指时间，如：00:30；+1天是指当天时间加1天，如：00:30+1，表示第二天的00:30；XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示
SR-5	查询都支持模糊查询，条件：“始发站”支持手动输入，也支持从行政组织（营业部）基础资料中选取；“到达站”支持手动输入，也支持从行政组织（外场、空运总调）基础资料中选取；“始发城市”支持手动输入，也支持从行政区域（城市）基础资料中选取；“运输类型”默认为全部，包含：汽运、空运、全部。
SR-6	新增和修改页面， “线路简码”不能重复，必须唯一；“线路名称”自动生成，根据所选“始发站”和“到达站”动态生成线路名称，如：广州东平营业部-广州外场
SR-7	新增和修改页面，对于一个“始发站”，只有一个默认配载的“到达站”
SR-8	新增和修改发车标准页面，“班次”为自然数，用户自行维护自动生成，同一条线路上班次从1开始，按照准点出发时间顺序排序； “始发站”自动带出;“到达站”自动带出

1.8	数据元素
1.8.1	始发线路新增/修改信息
字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
线路名称	线路名称	文本		50	是	
线路简码	线路简码，大写字母表示如：白云区均禾营业部-广州外场 简码为：SFQG，SF表示“始发”	文本		10	是	建议用4个大写英文字母表示
管理车队	线路所属车队名称	选择框		50	是	
运输类型	运输类型,包括:汽运、空运	下拉框		10	是	
始发站	始发站名称，从行政组织（营业部）基础资料中选取	选择框		50	是	
始发城市	始发站所在的城市名称，只读，与“始发站”联动获取	只读		20	是	
到达站	到达站名称，从行政组织（外场、空运总调、上海虹桥营业部）基础资料中选取	选择框		50	是	
是否默认始发线路	是否默认始发线路	单选框		2	是	
线路距离（公里）	始发站与到达站之间的距离，单位：公里	数字		6	是	
备注	备注	文本		100	否	
1.8.2	始发线路列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
线路名称	线路名称	N/A	50	N/A	
线路简码	线路简码，大写字母表示如：白云区均禾营业部-广州外场 简码为：SFQG，SF表示“始发”	N/A	10	N/A	
始发站	始发站名称	N/A	50	N/A	
始发城市	始发站所在的城市名称	N/A	20	N/A	
到达站	到达站名称	N/A	50	N/A	
运输类型	运输类型,包括:汽运、空运	N/A	20	N/A	
管理车队	线路所属车队名称	N/A	50	N/A	
是否默认始发线路	是否默认始发线路	N/A	10	N/A	
1.8.3	始发线路查询条件
字段名称 	说明 	输入限制	长度	是否必填	备注
线路名称	线路名称	文本	50	否	
始发站	始发站名称，支持手动输入，也支持从行政组织（营业部）基础资料中选取	文本	50	否	
到达站	到达站名称，支持手动输入、也支持从行政组织（外场、空运总调、上海虹桥营业部）基础资料中选取	文本	50	否	
始发城市	始发站所在的城市名称，支持手动输入，也支持从行政区域（城市）基础资料中选取	文本	20	否	
运输类型	运输类型,包括:汽运、空运、全部	下拉框	10	默认为全部	
管理车队	线路所属车队名称	选择框	50	否	
线路简码	线路简码，大写字母表示如：白云区均禾营业部-广州外场 简码为：SFQG，SF表示“始发”	文本框	10	否	
1.8.4	发车标准列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
班次	线路班次	N/A	2	N/A	自然数，用户自行维护同一条线路上班次从1开始，按照准点出发时间顺序排序
准点发车时间	准点发车时间，格式：08:00,09:30	N/A	20	N/A	
准点到达时间	准点到达时间，采用T+1格式，T是指时间，如：00:30；1是指当天时间加1天，如：00:30+1，表示第二天的00:30; XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示。	N/A	20	N/A	
时效类型	时效类型：包括普车、卡车两种				
备注	文本	N/A	100	N/A	
1.8.5	发车标准信息
字段名称 	说明 	输入限制	长度	是否必填	备注
班次	线路班次	N/A	2	N/A	自然数，用户自行维护同一条线路上班次从1开始，按照准点出发时间顺序排序
准点发车时间	准点发车时间，从日期控件中选择，控件格式：08:00,09:30	选择框	20	是	
始发站	始发站名称，自动带出 	N/A	50	N/A	
准点到达时间	准点到达时间，采用T+1格式，T是指时间，如：00:30；1是指当天时间加1天，如：00:30+1，表示第二天的00:30; XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示。	选择框	20	是	
到达站	到达站名称，自动带出 	N/A	50	N/A	
时效类型	时效类型：包括普车、卡车两种	下拉框		是	
备注	备注	文本	200	否	

1.9	非功能性需求
使用量	
2012年全网估计用户数	
响应要求（如果与全系统要求 不一致的话）	
使用时间段	
高峰使用时间段	

1.10	接口描述
接口名称 	对方系统（外部系统或内部其他模块）	接口描述
		



dp-foss-综合管理系统用例-新增_修改_作废_查询运作到运作线路信息-v1.05
修订记录 
日期 	修订内容 	修订人员 	版本号 
2012-5-30	新增   	谢艳涛	V0.1
2012-6-18	根据王偕旭点评修改，并改名为”运作到运作线路信息”	谢艳涛	V0.2
2012-6-30	根据赵鹏点评修改：增加“线路简码”、“管理车队”以及一些业务规则	谢艳涛	V0.3
2012-7-2	根据王偕旭要求修改	谢艳涛	V0.4
2012-7-2	提交CITA审核	谢艳涛	V0.5
2012-7-9	根据评审会议评委向彪意见修改：线路“普车时效”、“卡车时效”修改成可配置	谢艳涛	V0.6
2012-8-2	通过业务部门审核签字版本升级到V0.9	谢艳涛	V0.9
2012-10-16	根据变更需求增加导出功能：在图一界面增加“导出”按钮	谢艳涛	V1.01
2012-11-27	根据变更需求修改业务规则SR-1、SR-2	谢艳涛	V1.02
2012-12-01	根据变更需求把发车标准“班次”自动生成改为自行维护	谢艳涛	V1.03
2012-12-11	根据变更需求发车标准上增加：“时效类型”：卡车、普车	谢艳涛	V1.04
2012-12-29	根据变更需求在新增/修改线路界面增加“生效/失效”按钮，在点击生效按钮对业务规则SR-10在后台进行验证；增加业务规则SR-13;	谢艳涛	V1.05

1.	SUC-218-新增_修改_作废_查询运作到运作线路信息
1.1	相关业务用例
BUC_FOSS_5.20.30_530 开单收货
BUC_FOSS_5.10.20_060 制定班车发车计划
BUC_FOSS_5.10.20_020制定长途发车计划
BUC_FOSS_5.10.20_010 预测货量
BUC_FOSS_5.10.20_090 确定班车发车计划
BUC_FOSS_5.10.20_065 排班（短途班车）
BUC_FOSS_5.10.20_022 调整走货线路
1.2	用例描述
运作到运作线路主要用于货量预测、发车计划制定、排班以及调整走货线路等。本用例用于对运作到运作线路基础资料的维护，包括新增、修改、作废、查询等操作。  
1.3	用例条件
条件类型	描述	引用系统用例
前置条件	1、	行政区域基础资料完备
2、	行政组织基础资料完备
3、	偏线代理基础资料完备	SUC-33 DP-FOSS-综合管理系统用例-新增_修改_作废_查询行政区域
SUC-85 DP-FOSS-综合管理系统用例-修改_查询行政组织业务属性
SUC-649  新增_修改_作废_查询偏线代理

后置条件	1、	为制定运作到运作走货路径、查询/制定发车计划（短途）、修改发车计划（短途）系统用例提供线路基础资料查询。	SUC-187  新增_修改_作废_查询运作到运作走货路径
SUC-216  查询/制定发车计划（短途）
SUC-224修改发车计划（短途）
SUC-62 预测货量
SUC-63  查询预测货量
1.4	操作用户角色
操作用户	描述
线路维护人员	线路维护人员对运作到运作线路基础资料进行新增，修改，作废，查询操作。
1.5	界面要求
1.5.1	表现方式
Web页面
1.5.2	界面原型-主界面
                                 图一：线路基础资料管理主界面
1.5.3	界面描述-主界面
1.	功能按钮区域
1)	新增按钮：点击新增按钮进入新增界面，参见【图二：新增/修改线路（线段信息）界面】。
2)	导出按钮：点击导出按钮，可以导出运作到运作线路的所有数据至Excel表中
3)	查询按钮：输入查询条件，点击查询按钮，系统返回查询结果，刷新查询列表。
4)	重置按钮：点击重置按钮，重置查询条件。
5)	作废按钮：选中列表中一行或多行记录，点击作废按钮，选中的记录被作废；或点击各行的作废按钮，作废各行记录，作废时连同作废该线路对应的发车标准和线段信息，需要弹出确认提示框。
6)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
7)	修改按钮：点击各行的修改按钮，进入修改界面，参见【图二：新增/修改线路（线段信息）界面】。
8)	分页按钮：实现分页功能。
2.	列表区域
1)	列表区域默认不显示，点击查询按钮，根据查询条件显示列表数据。
2)	列表中显示：线路名称、线路简码、线路类型、出发站、出发城市、到达站、到达城市、线路距离（公里）、管理车队、线路状态。
3.	字段输入区域
1)	查询条件包括线路名称、出发站、到达站、出发城市、到达城市、线路类型、线路简码、管理车队。
1.1	线路名称：文本，支持模糊查询
1.2	出发站：选择框，支持手动输入模糊查询，支持从行政组织（外场、空运总调）基础资料中选取
1.3	到达站：选择框，支持手动输入模糊查询，也支持从行政组织（外场、空运总调）、偏线代理、空运代理网点或可空运到达的营业部基础资料中选取
1.4	出发城市：选择框，支持手动输入模糊查询，也支持从行政区域（城市）基础资料中选取
1.5	到达城市：选择框，支持手动输入模糊查询，也支持从行政区域（城市）基础资料中选取
1.6	线路类型：下拉框，默认为全部，包含：全部、专线、偏线、空运；
1.7	线路简码：文本，支持模糊查询
1.8	管理车队：选择框，支持手动输入模糊查询，也支持从行政组织（车队）基础资料中选取
1.81.9	线路状态：下拉框，包括：全部、生效、失效；
1.5.4	界面原型-新增/修改界面
   
图二：新增/修改线路（线段信息）界面   
图三：新增/修改线路（发车标准）界面
   
图四：新增/修改线路（线路类型为空运）界面
1.5.5	界面描述-新增/修改界面
1.	字段输入区域
1)	线路名称：自动生成，生成规则：根据所选“出发站”和“到达站”动态生成,如：生成线路名称为XXX外场-XXX外场；
2)	线路简码：必填，文本，线路简码必须唯一；
3)	线路类型：必填，下拉框，包含专线、偏线、空运。若线路类型为偏线/空运，“管理车队”、“普车时效（小时）”、“卡车时效（小时）”不可见，线段信息列表、发车标准列表均不不显示，“时效（小时）”可见，见【图四：新增/修改线路（线路类型为空运）界面】
4)	管理车队：必填，选择框，从行政组织（车队）基础资料中选取；
5)	出发站：必填，选择框，不支持手动输入，只支持从行政组织（外场、空运总调）信息基础资料中选取
6)	到达站：必填，选择框，不支持手动输入，支持从行政组织（外场、空运总调）、偏线代理、空运代理网点基础资料中选取
7)	出发城市：只读，与“出发站”联动获取显示
8)	到达城市：只读，与“到达站”联动获取显示
9)	普车时效（小时）：必填，数字
10)	卡车时效（小时）：必填，数字
11)	线路距离（公里）：必填，数字，出发站与到达站间的距离，单位：公里；
12)	描述：选填
2．列表区域
1)	线段列表（图二：新增/修改线路（线段信息）界面）中显示：线段顺序、出发站、出发城市、到达站、到达城市、线段距离（公里）、普车时效（小时）、卡车时效（小时）、经停时间（小时）。
2)	发车标准列表（图三：新增/修改线路（发车标准）界面）中显示：班次、准点出发时间、中转到达货最晚到达时间、时效类型。 
3. 功能按钮区域
1)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭当前界面，返回主界面；若保存失败，提示用户保存失败以及失败原因，不关闭当前界面。
2)	重置按钮：点击重置按钮，回到当前界面的初始状态。
3)	取消按钮：点击取消按钮，退出当前界面，返回主界面。
3)4)	生效或失效按钮：点击失效按钮，线路状态修改为失效状态，失效按钮隐藏，生效按钮显示；点击生效按钮，在后台对业务规则SR-10进行验证，线路状态修改为生效状态，生效按钮隐藏，失效按钮显示。
        线段信息面板（【图二：新增/修改线路（线段信息）界面】）
1)	 新增线段按钮：点击新增线段按钮，先判断线路信息是否已经保存，如果信息还未保存，弹出提醒框，提醒需要保存线路信息才能新增线段信息；如果信息已经保存成功，则弹出【图五：新增/修改线段界面】界面，进行新增操作，详细步骤参见【新增线段操作步骤】。
2)	修改线段按钮：点击修改线段按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能修改线段信息，详细步骤参见【修改线段操作步骤】；
3)	作废按钮：点击作废按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能作废线段信息，详细步骤参见【作废线段操作步骤】。
4)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
        发车标准面板（【图三：新增/修改线路（发车标准）界面】）
1)	 新增发车标准按钮：点击新增发车标准按钮，先判断线路信息是否已经保存，如果信息还未保存，弹出提醒框，提醒需要保存线路信息才能新增发车标准；如果信息已经保存成功，则弹出【图五：新增/修改发车标准】界面，进行新增操作，详细步骤参见【新增发车标准操作步骤】。
2)	修改发车标准按钮：点击修改按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能修改发车标准，详细步骤参见【修改发车标准操作步骤】；
3)	作废按钮：点击作废按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能作废发车标准，详细步骤参见【作废发车标准操作步骤】。
4)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
1.5.6	界面原型-新增/修改线段界面
 
                图五：新增/修改线段界面
1.5.7	界面描述-新增/修改线段界面
1、字段输入区域
1)	线段顺序： 必填，数字
2)	线段距离（公里）：必填，数字，出发站与到达站之间的距离，单位公里；
3)	出发站：必填，选择框，不支持手动输入，只支持从行政组织（外场）基础资料中选取，参见业务规则SR-10;
4)	到达站：必填，选择框，不支持手动输入，只支持从行政组织（外场）基础资料中选取, 参见业务规则SR-10;
5)	出发城市：只读，与“出发站”联动获取显示
6)	到达城市：只读，与“到达站”联动获取显示
7)	普车时效（小时）：必填，数字
8)	卡车时效（小时）：必填，数字
9)	经停时间（小时）：必填，数字
10)	描述：选填       
       2、功能按钮区域
1)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭弹出窗口，返回到【图二：新增/修改线路（线段信息）界面】；若保存失败，提示用户保存失败以及失败原因，不关闭弹出窗口。
2)	重置按钮：点击重置按钮，回到当前界面的初始状态。
3)	取消按钮：点击取消按钮，关闭当前界面，返回到【图二：新增/修改线路（线段信息）界面】界面。
1.5.8	界面原型-新增/修改发车标准
  
图六：新增/修改发车标准
1.5.9	界面描述-新增/修改发车标准
1、字段输入区域
1)	班次：数字，用户自行维护，自然数自动生成，同一条线路上班次从1开始，按照准点出发时间顺序排序。
2)	准点出发时间：必填，格式：08:00,09:30
3)	出发站：自动带出
4)	到达站：自动带出
5)	中转到达货最晚到达时间：必填，采用T-1格式，如：02:00-1天表示前一天的02:00；
5)6)	时效类型：下拉框，必选，包括：卡车 、普车两种时效类型；
6)7)	备注：选填
       2、功能按钮区域
              1)          保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭弹出窗口，返回到【图三：新增/修改线路（发车标准）界面】；若保存失败，提示用户保存失败以及失败原因，不关闭弹出窗口。
   2)          重置按钮：点击重置按钮，回到当前界面的初始状态。
 3)          取消按钮：点击取消按钮，关闭当前界面，返回到【图三：新增/修改线路（发车标准）界面】。

1.6	操作步骤
1.6.1	新增线路信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入线路信息管理主界面	【线路信息列表数据】	
2	点击新增按钮，进入【图二：新增/修改线路（线段信息）界面】		
3	输入线路信息、线段信息和发车标准信息，点击保存。
参见业务规则SR-1、SR-2、SR-3、SR-4,、SR-5、SR-8、SR-11	【线路基础资料信息】【线段信息列表数据】【发车标准列表信息】	
4	返回线路信息管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.2	修改线路信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入线路信息管理主界面	【线路信息列表数据】	
2	点击修改按钮，进入【图二：新增/修改线路（线段信息）界面】		
3	修改线路信息、线段信息和发车标准信息,点击保存
参见业务规则SR-1、SR-2、SR-3、SR-4,、SR-5、SR-8、SR-11	【线路基础资料信息】【线段信息列表数据】【发车标准列表信息】	
4	返回线路信息管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.3	作废线路信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入线路信息管理主界面	【线路信息列表数据】	
2	点击作废图标，可以作废当前记录；选择一行记录或多行记录，点击作废按钮，可以作废多条记录。		作废时连同作废该线路对应的线段信息和发车标准，弹出确认对话框。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.6.4	查询线路信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入线路信息管理主界面	【线路信息列表数据】	
2	输入查询条件，点击查询按钮。参见业务规则SR-7	【线路信息查询条件】	系统返回查询结果

1.6.5	新增线段操作步骤

序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改线路（线段信息）界面】	【线路基础资料信息】【线段信息列表数据】	
2	点击新增线段按钮，先判断线路信息是否保存，若已保存，弹出【图五：新增/修改线段界面】；若未保存，先保存线路信息，再点击新增线段按钮。		
3	输入线段详细信息，点击保存。
参见业务规则SR-3、SR-10、SR-12	【线段信息】	
4	返回【图二：新增/修改始发线路】界面		


序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图二：新增/修改线路（线段信息）界面】		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.6	修改线段操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改线路（线段信息）界面】	【线路基础资料信息】【线段信息列表数据】	
2	点击修改线段按钮，先判断线路信息是否修改，若未修改，弹出【图五：新增/修改线段界面】；若已修改，先保存线路信息，再点击修改线段按钮。		
3	输入线段详细信息，点击保存。
参见业务规则SR-3、SR-10、SR-12	【线段信息】	
4	返回【图二：新增/修改线路（线段信息）界面】		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图二：新增/修改线路（线段信息）界面】		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		
1.6.7	作废线段信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改线路（线段信息）界面】	【线路基础资料信息】	
2	选择一行记录，点击作废按钮。 	【线段信息列表数据】	弹出确认对话框
3	点击确定按钮		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.6.8	新增发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图三：新增/修改线路（发车标准）界面】	【线路基础资料信息】【发车标准列表信息】	
2	点击新增发车标准按钮，先判断线路信息是否保存，若已保存，弹出【图六：新增/修改发车标准】界面；若未保存，先保存线路信息，再点击新增发车标准按钮。		
3	输入发车标准详细信息，点击保存。
参见业务规则SR-6、SR-9	【发车标准信息】	
4	返回【图三：新增/修改线路（发车标准）界面】		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图三：新增/修改线路（发车标准）界面】		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.9	修改发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图三：新增/修改线路（发车标准）界面】	【线路基础资料信息】【发车标准列表信息】	
2	点击修改发车标准按钮，先判断线路信息是否修改，若未修改，弹出【图六：新增/修改发车标准】界面；若已修改，先保存始发线路信息，再点击修改发车标准按钮。		
3	输入发车标准详细信息，点击保存。
参见业务规则SR-6、SR-9	【发车标准信息】	
4	返回【图三：新增/修改线路（发车标准）界面】		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图三：新增/修改线路（发车标准）界面】		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.10	作废发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图三：新增/修改线路（发车标准）界面】	【线路基础资料信息】【发车标准列表信息】	
2	选择一行记录，点击作废按钮。		弹出确认对话框。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		


1.7	业务规则
序号	描述
SR-1	新增/修改页面，“出发站”不支持手动输入，只支持从选择框选择，遵循以下规则：1、 若“线路类型”为专线或偏线，出发站只能选择“外场”；
2、	若“线路类型”为空运，出发站只能是“外场”、“空运总调”；
SR-2	新增/修改页面，“到达站”不支持手动输入，只支持从选择框选择，遵循以下规则：1、若“线路类型”为专线，“到达站”只能选择“外场”；
2、若“线路类型”为偏线，“到达站”只能选择“偏线代理”；
3、若“线路类型”为空运，“到达站”只能选择"空运总调"或"空运代理网点"或可空运到达的营业部；
SR-3	新增/修改页面，“出发城市”与“出发站”联动选取，只读；“到达城市”与“到达站”联动选取，只读。“出发城市”字段只读，数据来源于出发站所属城市，“到达城市”字段只读，数据来源于到达站所属城市。
SR-4	新增/修改页面，线路类型：专线、偏线、空运。
SR-5	新增/修改页面，当“线路类型”为“专线”时，时效分为“普车时效”和“卡车时效”；当“线路类型”为“偏线/空运”时，仅提供一个“时效”，并且“管理车队”、线段列表、发车标准均不显示；
SR-6	“中转到达货最晚到达时间”不能大于“准点出发时间”；“中转到达货最晚到达时间”采用T-1格式，如：2：00-1天，表示前一天的2:00；
SR-7	查询都支持模糊查询，条件：“出发站”支持手动输入，也支持从行政组织（外场、空运总调）信息基础资料中选取；“到达站”支持手动输入，也支持从行政组织（外场、空运总调）、偏线代理、空运代理网点基础资料中选取；“出发城市”、“到达城市”支持手动输入，也支持从行政区域（城市）基础资料中选取；“线路类型”默认为全部，包含专线、偏线、空运；“管理车队”支持手动输入，也支持从行政组织（车队）基础资料中选取 
SR-8	新增/修改页面，“线路简码”不能重复，必须唯一；“线路名称”自动生成，根据所选“出发站”和“到达站”动态生成线路名称，如：上海外场-广州外场
SR-9	新增和修改发车标准页面，“班次”自然数字，用户自行维护自动生成，同一条线路上班次从1开始，按照准点出发时间顺序排序； “始发站”自动带出;“到达站”自动带出
SR-10	第一条线段的出发站必须是线路的出发站；最后一条线段的到达站必须是线路的到达站；第n条线段的出发站必须是第n-1条线段的到达站；
SR-11	新增/修改页面，线路的“普车时效（小时）”=线段的“普车时效（小时）”+线段的“经停时间（小时）”，在线段的“普车时效（小时）”、“经停时间（小时）”输入后动态计算生成；线路的“卡车时效（小时）” =线段的“卡车时效（小时）”+线段的“经停时间（小时）”，在线段的“卡车时效（小时）”、“经停时间（小时）”输入后动态计算生成；
SR-12	新增/修改线段页面, “出发站”不支持手动输入，只支持从行政组织（外场）基础资料中选择；“到达站”不支持手动输入，只支持从行政组织（外场）基础资料中选择
SR-13	线路的状态在“失效”状态下，不能使用，只有在“生效”状态下才能使用。修改线路时，必须先把线路状态修改为“失效”状态，才能进行其他数据修改。

1.8	数据元素
1.8.1	线路基础资料信息
字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
线路名称	线路的名称	文本		50	是	
线路简码	线路简码	文本		10	否	
线路类型	线路类型，包括：专线、偏线、空运	下拉框		10	是	
管理车队	线路所属车队名称，从行政组织（车队）基础资料中选择	选择框		50		若“线路类型”为专线，显示；否则不显示
出发站	出发站名称	文本		50	是	参见业务规则SR-1
到达站	到达站名称	文本		50	是	参见业务规则SR-2
出发城市	出发站所在城市名称，与“出发站”联动	只读		30	是	
到达城市	到达站所在城市名称，与“到达站”联动	只读		30	是	
普车时效（小时）	普车运行时间，单位：小时；线路的“普车时效（小时）”=线段的“普车时效（小时）”+线段的“经停时间（小时）”	数字		4	是	若“线路类型”为专线，显示；否则不显示
卡车时效（小时）	卡车运行时间，单位：小时；线路的“卡车时效（小时）” =线段的“卡车时效（小时）”+线段的“经停时间（小时）”	数字		4	是	若“线路类型”为专线，显示；否则不显示
时效（小时）	时效（小时）	数字		4	是	若“线路类型”为偏线/空运，显示；否则不显示
线路距离（公里）	线路距离，单位：公里	数字		6	是	
描述	描述信息	文本		100	否	
1.8.2	线路信息列表数据
字段名称 	说明 	输入限制	长度	是否必填	备注
线路名称	线路的名称	N/A	50	N/A	
线路简码	线路简码	N/A	10	N/A	
线路类型	线路类型，包括：专线、偏线、空运	N/A	10	N/A	
出发站	出发站名称	N/A	50	N/A	
出发城市	出发站所在城市名称	N/A	30	N/A	
到达站	到达站名称	N/A	50	N/A	
到达城市	到达站所在城市名称	N/A	30	N/A	
线路距离（公里）	线路距离，单位：公里	N/A	6	N/A	
管理车队	线路所属车队名称	N/A	50	N/A	
1.8.3	线路信息查询条件
字段名称 	说明 	输入限制	长度	是否必填	备注
线路名称	线路名称	文本	50	否	
出发站	出发站名称	选择框	50	否	从“外场”、“空运总调”基础资料中选取
到达站	到达站名称	选择框	50	否	从“外场”、“空运总调”、“偏线代理”、、“空运代理网点”基础资料中选取
出发城市	出发站所在城市名称	选择框	30	否	参见业务规则SR-7
到达城市	到达站所在城市名称	选择框	30	否	参见业务规则SR-7
线路类型	线路类型，包含：专线、偏线、空运、全部	下拉框	10	默认全部	
线路简码	线路简码	文本	10	否	
管理车队	线路所属车队名称	选择框	50	否	

1.8.4	线段信息列表数据
字段名称 	说明 	输入限制	长度	是否必填	备注
线段顺序	线段在整条线路中的顺序编号	N/A	2	N/A	
出发站	出发站名称	N/A	50	N/A	
出发城市	出发站所在城市名称	N/A	30	N/A	
到达站	到达站名称	N/A	50	N/A	
到达城市	到达站所在城市名称	N/A	30	N/A	
线段距离（公里）	出发站与到达站之间的距离 单位：公里	N/A	6	N/A	
普车时效（小时）	普车运行时间，单位：小时	N/A	4	N/A	
卡车时效（小时）	卡车运行时间，单位：小时	N/A	4	N/A	
经停时间（小时）	车在中转外场停留时间，单位：小时	N/A	4	N/A	

1.8.5	线段信息
字段名称 	说明 	输入限制	长度	是否必填	备注
线段顺序	线段在整条线路中的顺序编号	数字	2	是	
线段距离（公里）	出发站与到达站之间的距离 单位：公里	数字	6	是	
出发站	出发站名称	选择框	50	是	从行政组织（外场）基础资料中选取
到达站	到达站名称	选择框	50	是	从行政组织（外场）基础资料中选取
出发城市	出发站所在城市名称，与“出发站”联动	只读	30	是	
到达城市	到达站所在城市名称，与“到达站”联动	只读	30	是	
普车时效（小时）	普车运行时间，单位：小时	数字	4	是	
卡车时效（小时）	卡车运行时间，单位：小时	数字	4	是	
经停时间（小时）	车在中转外场停留时间，单位：小时	数字	4	是	
描述	描述	文本	100	否	


1.8.6	发车标准列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
班次	线路班次，默认为：1	N/A	2	N/A	自然数字，用户自行维护同一条线路上班次从1开始，按照准点出发时间顺序排序
准点出发时间	准点出发时间,格式：08：00、09:30	N/A	20	N/A	
中转到达货最晚到达时间	中转到达货物最晚到达外场的时间，采用T-1格式表示，如：2:00-1天，表示前一天的2:00。	N/A	20	N/A	
时效类型	时效类型，包括：普车、卡车两种时效				

1.8.7	发车标准信息
字段名称 	说明 	输入限制	长度	是否必填	备注
班次	发车班次	数字	2	是	自然数字，用户自行维护同一条线路上班次从1开始，按照准点出发时间顺序排序
准点出发时间	准点发车时间，格式：08:00,09:30	日期	20	是	
出发站	出发站名称，自动带出	N/A	50	N/A	
到达站	到达站名称，自动带出	N/A	50	N/A	
中转到达货最晚到达时间	中转到达货物最晚到达外场的时间，采用T-1格式表示，如：2:00-1天，表示前一天的2:00。	日期选择框	20	是	“中转到达货最晚到达时间”不能大于“准点出发时间”
时效类型	时效类型，包括：普车、卡车两种时效				
备注	备注	文本	200	否	
1.9	非功能性需求
使用量	
2012年全网估计用户数	
响应要求（如果与全系统要求 不一致的话）	
使用时间段	
高峰使用时间段	

1.10	接口描述
接口名称 	对方系统（外部系统或内部其他模块）	接口描述
		

		

dp-foss-综合管理系统用例-新增_修改_作废_查询到达线路-v1.04		
		
修订记录 
日期 	修订内容 	修订人员 	版本号 
2012-6-12	新增	谢艳涛	V0.1
2012-6-30	根据赵鹏点评修改：“班次”自动生成，“准点到达时间采用”T+1格式	谢艳涛	V0.2
2012-7-01	根据王偕旭点评修改：增加“运输类型”属性	谢艳涛	V0.3
2012-7-2	提交CITA审核	谢艳涛	V0.5
2012-7-6	根据评审会议罗越、王偕旭要求增加“网点组”思想修改：到达线路增加“是否到达默认线路”属性	谢艳涛	V0.6
2012-8-2	通过业务部门审核签字版本升级到V0.9	谢艳涛	V0.9
2012-10-16	根据变更需求增加导出功能：在图一界面增加“导出”按钮	谢艳涛	V1.01
2012-11-27	根据变更需求修改业务规则SR-2、SR-1	谢艳涛	V1.02
2012-12-01	根据变更需求把发车标准“班次”自动生成改为自行维护;增加业务规则SR-8，到达线路只有汽运，界面上去掉“运输类型”	谢艳涛	V1.03
2012-12-11	根据变更需求修改发车标准：增加“时效类型”分为：普车、卡车两种	谢艳涛	V1.04

1.	SUC-740-新增_修改_作废_查询到达线路
1.1	相关业务用例
BUC_FOSS_5.20.30_530 开单收货
BUC_FOSS_5.10.20_060 制定班车发车计划
BUC_FOSS_5.10.20_020制定长途发车计划
BUC_FOSS_5.10.20_010 预测货量
BUC_FOSS_5.10.20_090 确定班车发车计划
BUC_FOSS_5.10.20_065 排班（短途班车）
BUC_FOSS_5.10.20_022 调整走货线路
1.2	用例描述
到达线路即运作到经营的线路，主要用于货量预测、发车计划制定。本用例用于对到达线路基础资料维护，包括新增、修改、作废、查询、导出数据等操作。
1.3	用例条件
条件类型	描述	引用系统用例
前置条件	1、	行政组织基础资料完备
2、	行政区域基础资料完	SUC-33 DP-FOSS-综合管理系统用例-新增_修改_作废_查询行政区域
SUC-85 DP-FOSS-综合管理系统用例-修改_查询行政组织业务属性
后置条件	1、	为查询/制定发车计划（短途）、修改发车计划（短途）等系统用例提供到达线路基础资料查询	SUC-216  查询/制定发车计划（短途）
SUC-224修改发车计划（短途）

1.4	操作用户角色
操作用户	描述
线路维护人员	线路维护人员对到达线路进行新增，修改，作废，查询操作。
1.5	界面要求
1.5.1	表现方式
Web页面
1.5.2	界面原型-主界面
  
图一：到达线路主界面
1.5.3	界面描述-主界面
1.	功能按钮区域
1)	新增按钮：点击新增按钮进入新增界面，参见【图二：新增/修改到达线路】。
2)	导出按钮：点击导出按钮，可以导出到达线路的所有数据至Excel表中
3)	查询按钮：输入查询条件，点击查询按钮，系统返回查询结果，刷新查询列表。
4)	重置按钮：点击重置按钮，清空查询条件。
5)	作废按钮：选中列表中一行或多行记录，点击作废按钮，选中的记录被作废；或点击各行的作废按钮，作废各行记录，作废时连同作废该线路对应的发车标准，需要弹出确认提示框。
6)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
7)	修改按钮：点击各行的修改按钮，进入修改界面，参见【图二：新增/修改到达线路】。
8)	分页按钮：实现分页功能。
2.	列表区域
1)	列表区域默认不显示，点击查询按钮，根据查询条件显示列表数据。
2)	列表中显示：线路名称、线路简码、运输类型、出发站、到达站、线路距离（公里）、是否默认到达线路。
3.	字段输入区域
1)	查询条件包括线路名称、出发站、到达站、线路简码、管理车队。
1.1	线路名称：文本，支持模糊查询
1.2	出发站：选择框，支持手动输入模糊查询，也支持从行政组织（外场）基础资料中选取
1.3	到达站：选择框，支持手动输入模糊查询，也支持从行政组织（营业部）基础资料中选取
1.4	线路简码：文本，支持模糊查询
1.5	管理车队：选择框，支持手动输入模糊查询，也支持从行政组织（车队）基础资料中选取
1.5.4	界面原型-新增/修改到达线路
 
图二：新增/修改到达线路
1.5.5	界面描述-新增和修改到达线路
1.	字段输入区域
1)	线路名称：线路名称必须唯一自动生成，生成规则：根据所选“出发站”和“到达站”动态生成,如：生成线路名称为XXX外场-XXX营业部
2)	线路简码：必填，文本，大写英文字母表示，线路简码必须唯一
3)	管理车队：必填，选择框，从行政组织（车队）基础资料中选取
4)	线路距离（公里）：必填，数字
5)	出发站：必填，选择框，从行政组织（外场）基础资料中选取
6)	到达站：必填，选择框，从行政组织（营业部）基础资料中选取
7)	是否默认达到线路：必填，单选框，是或否，默认为是
8)	备注：选填
2．	 发车标准列表区域
1)          列表中显示：班次、准点出发时间、准点到达时间、时效类型、备注。
3.   功能按钮区域
1)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭当前界面，返回主界面；若保存失败，提示用户保存失败以及失败原因，不关闭当前页面。
2)	重置按钮：点击重置按钮，回到当前界面的初始状态。
3)	取消按钮：点击取消按钮，退出当前界面，返回主界面。
4)	新增发车标准按钮：点击新增发车标准按钮，先判断线路信息是否已经保存，如果信息还未保存，弹出提醒框，提醒需要保存到达线路信息才能新增发车标准；如果信息已经保存成功，则弹出【图三：新增和修改发车标准】界面，进行新增操作，详细步骤参见【新增发车标准操作步骤】。
5)	修改按钮：点击修改按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能修改发车标准，详细步骤参见【修改发车标准操作步骤】；
6)	作废按钮：点击作废按钮，先判断线路信息是否已做修改，如果线路信息已做修改，弹出提醒框，提醒先保存线路信息才能作废发车标准，详细步骤参见【作废发车标准操作步骤】。
7)	查看详细信息：鼠标移动到列表中某一条记录，双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
1.5.6	界面原型-新增/修改发车标准
 
    图三：新增和修改发车标准
1.5.7	界面描述-新增/修改发车标准
1、字段输入区域
1)	班次：数字，用户自行维护，自然数。
2)	出发站：自动带出
3)	到达站：自动带出
4)	准点出发时间：必填，格式：08:00,09:30等
5)	准点到达时间：必填，采用T+1格式，T是指时间，如：00:30；+1天是指当天时间加1天，如：00:30+1，表示第二天的00:30；XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示。
6)	时效类型：下拉框，包括：普车、卡车两种时效类型；
6)          备注：选填
       2、功能按钮区域
1)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭弹出窗口，返回到【图二：新增/修改到达线路】；若保存失败，提示用户保存失败以及失败原因，不关闭弹出窗口。
2)	重置按钮：点击重置按钮，回到当前界面的初始状态。
3)	取消按钮：点击取消按钮，关闭当前界面，返回到【图二：新增/修改到达线路】界面。
1.6	操作步骤
1.6.1	添加到达线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入到达线路管理主界面	【到达线路列表信息】	
2	点击新增按钮，进入【图二：新增/修改到达线路】界面		
3	输入到达线路详细信息和相关发车标准信息，点击保存。
参见业务规则SR-1、SR-2、SR-5、SR-6	【到达线路新增/修改信息】【发车标准列表信息】【发车标准信息】	
4	返回到达线路管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.2	修改到达线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入到达线路管理主界面	【到达线路列表信息】	
2	点击修改按钮，进入【图二：新增/修改到达线路】界面		
3	修改到达线路详细信息和发车标准信息,点击保存
参见业务规则SR-1、SR-2、SR-5、SR-6	【到达线路新增/修改信息】【发车标准列表信息】【发车标准信息】	
4	返回到达线路管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.3	作废到达线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入到达线路管理主界面	【到达线路列表信息】	
2	选择一行或者多行记录，点击作废按钮。		作废时连同作废该线路对应的发车标准，弹出确认对话框。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.6.4	查询到达线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入到达线路管理主界面	【到达线路列表信息】	
2	输入查询条件，点击查询按钮。参见业务规则SR-4	【到达线路查询条件】	系统返回查询结果

1.6.5	新增发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改到达线路】界面	【到达线路新增/修改信息】【发车标准列表信息】	
2	点击新增发车标准按钮，先判断到达线路信息是否保存，若已保存，弹出【图二：新增/修改发车标准】界面；若未保存，先保存到达线路信息，再点击新增发车标准按钮。		
3	输入发车标准详细信息，点击保存。
参见业务规则SR-3、SR-7	【发车标准信息】	
4	返回【图二：新增/修改到达线路】界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图二：新增/修改到达线路】界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.6	修改发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改到达线路】界面	【到达线路新增/修改信息】【发车标准列表信息】	
2	点击修改发车标准按钮，先判断到达线路信息是否修改，若未修改，弹出【图二：新增/修改发车标准】界面；若已修改，先保存到达线路信息，再点击修改发车标准按钮。		
3	输入发车标准详细信息，点击保存。
参见业务规则SR-3、SR-7	【发车标准信息】	
4	返回【图二：新增/修改到达线路】界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，关闭当前界面，返回【图二：新增/修改到达线路】界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.7	作废发车标准操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：新增/修改到达线路】界面	【到达线路新增/修改信息】【发车标准列表信息】	
2	选择一行记录，点击作废按钮。		弹出确认对话框。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.7	业务规则
序号	描述
SR-1	在新增/修改页面， “到达站”不支持手动输入，只支持从行政组织（营业部）基础资料中选取。 
SR-2	在新增/修改页面，“出发站”不支持手动输入，只支持从行政组织（外场）基础资料中选取。
SR-3	时间通过“时间控件”选取，格式：08:00,09:30;“准点到达时间”采用T+1格式，T是指时间，如：00:30；+1天是指当天时间加1天，如：00:30+1，表示第二天的00:30；XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示，“准点到达时间”不能早于“准点出发时间”。
SR-4	查询都支持模糊查询，条件：“出发站”支持手动输入，也支持从行政组织（外场、空运总调）基础资料中选取；“到达站”支持手动输入，也支持从行政组织（营业部）基础资料中选取。
SR-5	新增和修改页面，“线路简码”不能重复，必须唯一；“线路名称”自动生成，根据所选“出发站”和“到达站”动态生成线路名称，如： 广州外场-广州东平营业部
SR-6	新增和修改页面，对于一个“到达站”，只有一个默认配载的“出发站”
SR-7	新增和修改发车标准页面，“班次”自然数，用户自行维护；“出发站”自动带出;“到达站”自动带出
SR-8	到达站必须是具有自提派送属性的行政组织,以及到达站可做到达产品是否存在到达线路的产品属性。

1.8	数据元素
1.8.1	到达线路新增/修改信息
字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
线路名称	线路名称	文本		50	是	
线路简码	线路简码	文本		10	是	
管理车队	线路所属车队名称	选择框		50	是	
线路距离（公里）	出发站与到达站之间的距离，单位：公里	数字		6	是	
出发站	出发站名称，从行政组织（外场）基础资料中选取	选择框		50	是	
到达站	到达站名称，从行政组织（营业部）基础资料中选取	选择框		50	是	
是否默认到达线路	是否为默认到达线路	单选框		2	是	默认为是
备注	备注	文本		100	否	
1.8.2	到达线路列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
线路名称	线路名称，命名格式：上海专线-松江工业区营业部	N/A	50	N/A	
线路简码	线路简码，大写字母表示如：上海外场-松江工业区营业部 简码为：DDSG，DD表示“到达”	N/A	10	N/A	
出发站	出发站名称	N/A	50	N/A	
到达站	到达站名称	N/A	50	N/A	
线路距离（公里）	出发站与到达站之间的距离，单位：公里	N/A	6	N/A	
管理车队	线路所属车队名称	N/A	50	N/A	
是否默认到达线路	是否为默认到达线路	N/A	2	N/A	
1.8.3	到达线路查询条件
字段名称 	说明 	输入限制	长度	是否必填	备注
线路名称	线路名称 	文本	50	否	
出发站	出发站名称，支持手动输入，也支持从行政组织（外场、空运总调）基础资料中选择	选择框	50	否	
到达站	到达站名称，支持手动输入，也支持从行政组织（营业部）基础资料中选择	选择框	50	否	
管理车队	线路所属车队名称	选择框	50	否	
线路简码	线路简码 	文本框	10	否	
1.8.4	发车标准列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
班次	线路班次	N/A	2	N/A	
准点发车时间	准点发车时间，格式：08:00,09:30	N/A	20	N/A	
准点到达时间	准点到达时间，格式：08:00,09:30	N/A	20	N/A	
时效类型	时效类型：卡车、普车两种				
备注	备注				
1.8.5	发车标准信息
字段名称 	说明 	输入限制	长度	是否必填	备注
班次	发车班次，自然数，用户自行维护	N/A	2	N/A	
出发站	出发站名称，自动带出	N/A	50	N/A	
到达站	到达站名称，自动带出 	N/A	50	N/A	
准点出发时间	准点发车时间，格式：08:00,09:30	时间选择框	20	是	
准点到达时间	准点到达时间，采用T+1格式，T是指时间，如：00:30；+1天是指当天时间加1天，如：00:30+1，表示第二天的00:30；XX天用下拉框表示，如果为0天，默认为当天时间，如：22:00+0天，用22:00表示	时间选择框	20	是	
时效类型	时效类型：分为卡车和普车两种				
备注	备注	文本	200	否	

1.9	非功能性需求
使用量	
2012年全网估计用户数	
响应要求（如果与全系统要求 不一致的话）	
使用时间段	
高峰使用时间段	

1.10	接口描述
接口名称 	对方系统（外部系统或内部其他模块）	接口描述
		

		

dp-foss-综合管理系统用例-新增_修改_作废_查询走货路径(运作到运作)-v1.12		
		
修订记录 
日期 	修订内容 	修订人员 	版本号 
2012-7-2	新增 	谢艳涛	V0.1
2012-7-3	提交CITA审核	谢艳涛	V0.5
2012-7-5	根据评审意见修改：增加“是否可以打木架”、“打木架外场”属性	谢艳涛	V0.6
2012-7-8	根据ITA王偕旭要求修改：增加“是否默认走货路径”、“出发网点组”、“到达网点组”属性	谢艳涛	V0.7
2012-8-2	通过业务部门审核签字版本升级到V0.9	谢艳涛	V0.9
2012-12-1	根据变更需求修改“运输性质”，业务规则SR-1、SR-3，把机场修改为“空运代理网点”,修改业务规则SR-9,删除SR-10	谢艳涛	V1.11
2013-1-4	根据变更需求在新增/修改线路界面增加“生效/失效”按钮，增加业务规则SR-10;	谢艳涛	V1.12

1.	SUC-187-新增_修改_作废_查询走货路径（运作到运作）
1.1	相关业务用例
BUC_FOSS_5.10.20_022 调整走货线路。

1.2	用例描述
走货路径（运作到运作）主要用于计算并调整走货路径、调整货物走货路径、重新计算走货路径等。本用例用于对走货路径（运作到运作）基础资料的维护，包括新增、修改、作废、查询等操作。
1.3	用例条件
条件类型	描述	引用系统用例
前置条件	1、	行政组织基础资料完备
2、	运作到运作线路信息基础资料完备
3、	空运代理网点机场信息基础资料完备
4、	偏线代理基础资料完备
5、	始发线路基础资料完备
6、	到达线路基础资料完备	SUC-85 DP-FOSS-综合管理系统用例-修改_查询行政组织业务属性
SUC-218  新增_修改_作废_查询运作到运作线路信息
SUC-72052  新增_修改_作废_查询空运代理网点机场信息 
SUC-649  新增_修改_作废_查询偏线代理
SUC-284  新增_修改_作废_查询始发线路
SUC-740  新增_修改_作废_查询到达线路
后置条件	1、	为计算并调整走货路径、调整货物走货路径、重新计算走货路径等系统用例提供运作到运作走货路径基础资料查询	SUC-611  计算并调整走货路径
SUC-429  调整货物走货路径
SUC-748  重新计算走货路径
1.4	操作用户角色
操作用户	描述
线路管理员	线路管理员对“走货路径（运作到运作）基础资料”进行新增，修改，作废，查询操作。
1.5	界面要求
1.5.1	表现方式
Web页面
1.5.2	界面原型-主界面
                                图一：走货路径（运作到运作）管理主界面
1.5.3	界面描述-主界面
1.	功能按钮区域
1)	新增按钮：点击新增按钮进入新增界面，参见【图二：走货路径（运作到运作）新增/修改界面】。
2)	查询按钮：输入查询条件，点击查询按钮，系统返回查询结果，刷新查询列表。
3)	重置按钮：点击重置按钮，清空查询条件。
4)	作废按钮：选中列表中一行或多行记录，点击作废按钮，弹出确认提示框，作废时同时把该走货路径包含的线路移除；或点击各行的作废按钮，弹出确认提示框。作废成功后会弹出作废成功的提示框，作废时同时把该走货路径包含的线路移除；若作废失败，弹出作废失败的提示框，并提示失败原因。
5)	查看详细信息：双击该行记录，弹出一个窗口，可以查看该记录的详细信息。
6)	修改按钮：点击各行的修改按钮，进入修改界面，参见【图二：走货路径（运作到运作）新增/修改界面】。
7)	分页按钮：实现分页功能。
2.	列表区域
1)	列表区域默认不显示，点击查询按钮，根据查询条件显示列表数据。
2)	列表中显示：出发站、到达站、运输性质、时效（小时）、是否可以打木架、打木架外场、是否默认走货路径、状态。
3.	字段输入区域
1)	查询条件包括出发站、到达站、运输性质。
1.1	出发站：选择框，支持手动输入模糊查询，也支持从行政组织（外场、空运总调）基础资料中选择；
1.2	到达站：选择框，支持手动输入模糊查询，也支持从行政组织（外场）、偏线代理、空运代理网点机场信息基础资料中选择；
1.3	运输性质：下拉框，包括：全部、取第三级产品类型（精准卡航，精准城运，精准汽运（长途），精准汽运（短途），汽运偏线，精准空运）（整车不可以选，需要排除掉）精准汽运、精准卡航、汽运偏线、精准空运。默认为全部。
1.31.4	状态：下拉框，包括：全部、生效、失效。默认为全部。

1.5.4	界面原型-新增/修改界面
  图二：走货路径（运作到运作）新增/修改界面
1.5.5	界面描述-新增/修改界面
1.	字段输入区域
1)	运输性质： 必填，下拉框，包含取第三级产品类型（精准卡航，精准城运，精准汽运（长途），精准汽运（短途），汽运偏线，精准空运）（整车不可以选，需要排除掉）精准汽运、精准卡航、汽运偏线、精准空运。
2)	出发站：必填，选择框，从行政组织（外场、空运总调）基础资料中选择
3)	到达站：必填，选择框，从行政组织（外场）、偏线代理、机场空运代理网点、可空运到达的营业部信息基础资料中选择
4)	时效（小时）：根据添加的线路时效（小时）+经停时间（小时）计算获取。
5)	是否默认走货路径：选择框，默认选中，该走货路径是否为默认走货路径；
6)	是否可以打木架：必填，单选按钮，是或否，默认为否，若值为“否”，单选按钮为只读状态，不允许选择“是”；若值为“是”，单选按钮可以选择为“否”；
7)	打木架外场：下拉框，默认为不显示；与“是否可以打木架”联动，若“是否可以打木架”值为“否”，“打木架外场”隐藏；若“是否可以打木架”值为“是”，“打木架外场”显示，下拉框里会把拥有“可以打木架”属性的外场查询出来，默认为第一个具有“可以打木架” 属性的外场；
8)	备注：选填，文本
9)	出发站对应营业部：下拉列表，显示所有配置过始发线路到达出发站的营业部与“是否默认走货路径”联动，如果“是否默认走货路径”选中，“出发站对应营业部”为所有不是默认的始发配载部门为“出发站”的营业部；否则，“出发站对应营业部”显示所有始发配载部门为“出发站”的营业部。
10)	出发网点组：下拉列表，列表中显示该“出发网点组”所属的营业部，从“出发站对应营业部”下拉列表中选择；
11)	到达站对应营业部：下拉列表，显示所有配置过到达线路到达该到到达站的营业部与“是否默认走货路径”联动，如果“是否默认走货路径”选中，“到达站对应营业部”显示所有不是默认的到达配载部门为“到达站”的营业部；否则，“到达站对应营业部”显示所有到达配置部门为“到达站”的营业部；
12)	到达网点组：下拉列表，列表中显示该“到达网点组”所属的营业部，从“到达站对应营业部”下拉列表中选择。
13)	网点组列表详见【网点组列表数据】
14)	线路信息列表详见【线路信息列表数据】
2.	功能按钮区域
1)	出发网点组右选（--->）按钮：选中“出发站对应营业部”下拉列表中的营业部，点击右选按钮，选中的营业部会在“出发网点组”下拉列表中显示。
2)	出发网点组右全选（-->>）按钮：点击右全选按钮，“出发站对应营业部”下拉列表中的营业部全部会在“出发网点组”下拉列表中显示。
3)	出发网点组左移（<---）按钮：选中“出发网点组”下拉列表中的营业部，点击左移按钮，选中的营业部会在“出发网点组”下拉列表中清除；
4)	出发网点组左全移（<<--）按钮：点击左全移按钮，“出发网点组”下拉列表中的营业部全部清除；
5)	到达网点组右选（--->）按钮：选中“到达站对应营业部”下拉列表中的营业部，点击右选按钮，选中的营业部会在“到达网点组”下拉列表中显示
6)	到达网点组右全选（-->>）按钮：点击右全选按钮，“到达站对应营业部”下拉列表中的营业部全部会在“到达网点组”下拉列表中显示。
7)	到达网点组左移（<---）按钮：选中“到达网点组”下拉列表中的营业部，点击左移按钮，选中的营业部会在“到达网点组”下拉列表中清除；
8)	到达网点组左全移（<<--）按钮：点击左全移按钮，“到达网点组”下拉列表中的营业部全部清除
9)	添加网点组按钮：点击添加网点组按钮，先判断走货路径信息是否已经保存，如果信息还未保存，弹出提示框，提示需要先保存走货路径信息才能添加线路信息；如果信息已经保存成功，进行添加网点组操作
10)	修改网点组按钮：点击修改网点组按钮，先判断走货路径信息是否已做修改，如果走货路径信息已做修改，弹出提示框，提示先保存走货路径信息才能进行修改网点组操作，则弹出【图三：修改网点组界面】，进行修改网点组操作；
11)	作废网点组按钮：点击作废网点组按钮，先判断走货路径信息是否已做修改，如果走货路径信息已做修改，弹出提示框，提示先保存走货路径信息才能作废网点组操作；
12)	添加线路按钮：点击添加线路按钮，先判断走货路径信息是否已经保存，如果信息还未保存，弹出提示框，提示需要先保存走货路径信息才能添加线路信息；如果信息已经保存成功，则弹出【图四：线路信息新增/修改界面】，进行添加线路操作。
13)	修改线路按钮：点击修改线路按钮，先判断走货路径信息是否已做修改，如果走货路径信息已做修改，弹出提示框，提示先保存走货路径信息才能进行修改线路信息操作，则弹出【图四：线路信息新增/修改界面】，进行修改线路操作。
14)	移除线路按钮：选择要移除的线路，点击移除线路按钮，先判断走货路径信息是否已做修改，如果走货路径信息已做修改，弹出提示框，提示先保存走货路径信息才能移除线路信息。
15)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭当前界面，返回主界面；若保存失败，提示用户保存失败以及失败原因，不关闭当前界面
16)	重置按钮：点击重置按钮，回到当前界面的初始状态。
17)	取消按钮：点击取消按钮，如果当前界面数据未保存，提示“界面数据不为空，是否退出”，点击“是”退出当前界面，返回主界面；否则，不关闭当前界面。
17)18)	生效或失效按钮：点击失效按钮，走货路径状态修改为失效状态，失效按钮隐藏，生效按钮显示；点击生效按钮，在后台对业务规则SR-6进行验证，走货路径状态修改为生效状态，生效按钮隐藏，失效按钮显示。
1.5.6	界面原型-修改网点组
 
                                                                 图三：修改网点组界面
1.5.7	界面描述-修改网点组
1、	字段输入区域
1)	出发站对应营业部：下拉列表，下拉列表中显示所有始发配置部门为“出发站”的营业部
2)	出发网点组：必填，下拉列表，列表中显示该“出发网点组”所属的营业部，从“出发站对应营业部”下拉列表中选择
3)	到达站对应营业部：下拉列表框，下拉列表中显示所有到达配置部门为“到达站”的营业部；
4)	到达网点组：必填，下拉列表，列表中显示该“到达网点组”所属的营业部，从“到达站对应营业部”下拉列表中选择。
2、功能按钮区域
1)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭当前界面，返回主界面；若保存失败，提示用户保存失败以及失败原因，不关闭当前界面
2)	重置按钮：点击重置按钮，回到当前界面的初始状态。
3)	取消按钮：点击取消按钮，如果当前界面数据未保存，提示“界面数据不为空，是否退出”，点击“是”退出当前界面，返回主界面；否则，不关闭当前界面；
1.5.8	界面原型-新增/修改线路信息
 
                                                  图四：线路信息新增/修改界面
1.5.9	界面描述-新增/修改线路信息
2、	字段输入区域
5)	序号：必填，数字，该线路在走货路径中所占的顺序
6)	线路名称：必填，选择框，从运作到运作线路信息基础资料中选择，参见业务规则SR-3
7)	线路简码：与“线路名称”联动带出 
8)	出发站：必填，下拉框，根据所选线路动态获取该线路包含线段所有的出发站。默认选中线路的出发站。
9)	到达站：必填，下拉框，根据所选线路动态获取该线路包含线段所有的到达站。默认选中线路的到达站。
10)	时效（小时）：根据走货路径的“运输性质”，所选“线路名称”以及“出发站”，“到达站”，由系统自动计算。
11)	经停时间（小时）：必填，数字，默认为0，单位：小时
2、功能按钮区域
4)	保存按钮：点击保存按钮，需要提示用户是否保存成功，若保存成功，关闭当前界面，返回主界面；若保存失败，提示用户保存失败以及失败原因，不关闭当前界面
5)	重置按钮：点击重置按钮，回到当前界面的初始状态。
6)	取消按钮：点击取消按钮，如果当前界面数据未保存，提示“界面数据不为空，是否退出”，点击“是”退出当前界面，返回主界面；否则，不关闭当前界面。
1.6	操作步骤
1.6.1	添加走货路径操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入走货路径（运作到运作）管理主界面	【走货路径列表信息】	
2	点击新增按钮，进入新增/修改界面		
3	输入走货路径（运作到运作）详细信息，并选择线路，点击保存。
参见业务规则SR-1、SR-2、SR-7、SR-8、SR-9、SR-10	【走货路径新增/修改信息】【线路列表信息】	
4	返回走货路径（运作到运作）管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.2	修改走货路径操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入走货路径管理主界面	【走货路径列表信息】	
2	点击修改按钮，进入新增/修改界面		
3	修改走货路径详细信息，点击保存
参见业务规则SR-1、SR-2、SR-7、SR-8、SR-9、SR-10	【走货路径新增/修改信息】【线路列表信息】	
4	返回走货路径管理主界面		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.3	作废走货路径操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入走货路径管理主界面	【走货路径列表信息】	
2	选择一行或者多行记录，点击作废按钮。		作废时同时把该走货路径下面的线路一起移除。
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.6.4	查询走货路径操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入走货路径管理主界面	【走货路径列表信息】	
2	输入查询条件，点击查询按钮。参见业务规则SR-5	【走货路径查询条件】	系统返回查询结果

1.6.5	添加线路信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：走货路径（运作到运作）新增/修改界面】	【走货路径新增/修改信息】【线路列表信息】	
2	点击添加线路按钮，弹出【图四：线路信息新增/修改界面】		
3	输入线路详细信息，点击保存。
参见业务规则SR-3、SR-4	【线路新增/修改信息】	
4	返回到【图二：运作到运作走货路径新增/修改界面】		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在新增界面		

1.6.6	修改线路信息操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：走货路径（运作到运作）新增/修改界面】	【走货路径新增/修改信息】【线路列表信息】	
2	点击修改按钮，，弹出【图四：线路信息新增/修改界面】		
3	修改线路详细信息，点击保存
参见业务规则SR-3、SR-4	【线路新增/修改信息】	
4	返回到【图二：走货路径（运作到运作）新增/修改界面】		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.7	移除线路操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：走货路径（运作到运作）新增/修改界面】	【走货路径新增/修改信息】【线路列表信息】	
2	选择一行或者多行记录，点击移除按钮。		弹出提示框
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.6.8	添加网点组操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：走货路径（运作到运作）新增/修改界面】	【走货路径新增/修改信息】【线路列表信息】【网点组列表数据】	
2	选择出发站对应营业部下拉列表中的营业部，点击右选（-->）按钮		选择的营业部在出发网点组下拉列表中显示
3	选择到达站对应营业部下拉列表中的营业部，点击右选（-->）按钮		选择的营业部在到达网点组下拉列表中显示
4	点击添加网点组按钮，参见业务规则SR-10		把出发网点组和到达网点组保存到数据库
5	刷新【图二：走货路径（运作到运作）新增/修改界面】		划分好的出发网点组和到达网点组在网点组列表中显示

序号	扩展事件	相关数据	备注
4a	若保存失败，需提示用户保存失败以及失败原因，继续停留在【图二：走货路径（运作到运作）新增/修改界面】		

1.6.9	修改网点组操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：走货路径（运作到运作）新增/修改界面】	【走货路径新增/修改信息】【线路列表信息】【网点组列表数据】	
2	点击修改按钮，，弹出【图三：修改网点组界面】		
3	修改网点组详细信息，点击保存, 参见业务规则SR-10		
4	返回到【图二：走货路径（运作到运作）新增/修改界面】		

序号	扩展事件	相关数据	备注
3a	点击取消按钮，退出当前界面，返回主界面		
3b	若保存失败，需提示用户保存失败以及失败原因，继续停留在修改界面		

1.6.10	作废网点组操作步骤
序号	基本步骤	相关数据	补充步骤
1	进入【图二：走货路径（运作到运作）新增/修改界面】	【走货路径新增/修改信息】【线路列表信息】【网点组列表数据】	
2	点击移除按钮。		弹出提示框
3	点击确定按钮。		

序号	扩展事件	相关数据	备注
2a	点击取消按钮，退出当前界面，返回主界面		
2b	若作废失败，需提示用户作废失败以及失败原因		

1.7	业务规则
序号	描述
SR-1	新增/修改界面，若“运输性质”为精准汽运、精准卡航，“出发站”只能从行政组织（外场）基础资料中选择，“到达站”只能从行政组织（外场）基础资料中选择；若“运输性质”为汽运偏线，“出发站”只能从行政组织（外场）基础资料中选择，“到达站”只能从偏线代理基础资料中选择；若“运输性质”为精准空运，“出发站”只能从行政组织（空运总调或外场）基础资料中选择， 行政组织（空运总调）基础资料中选择，“到达站”只能从机场空运代理网点或可空运到达的营业部信息基础资料中选择；
SR-2	新增/修改界面，时效（小时），根据走货路径的“运输性质”，所选“线路名称”以及“出发站”，“到达站”，由系统自动计算
SR-3	新增/修改线路页面，走货路径可以任意选取运作到运作线路，线路选择框需要区分汽运，空运，偏线3个tab供用户选择“线路名称”根据走货路径的“运输性质”不同从运作到运作线路基础资料中选择不同的线路，遵循以下规则：
1、	若“运输性质”为精准汽运/精准卡航，“线路名称”只能从运作到运作线路基础资料中选择“线路类型”为专线的线路；
2、	若“运输性质”为汽运偏线，“线路名称”只能从运作到运作线路基础资料中选择“线路类型”为偏线或专线的线路，且走货路径中至少包含一条偏线线路；
3、1、	若“运输性质”为精准空运，“线路名称”只能从运作到运作线路基础资料中选择“线路类型”为空运的线路；
SR-4	新增/修改线路页面，“出发站”根据所选线路动态获取该线路包含线段所有的出发站，以下拉框显示，默认选中线路的出发站。；“到达站”根据所选线路动态获取该线路包含线段所有的到达站，以下拉框显示，默认选中线路的到达站。；“时效（小时）” 根据走货路径的“运输性质”，所选“线路名称”以及“出发站”，“到达站”，由系统自动计算
SR-5	查询支持模糊查询，条件“出发站”支持手动输入模糊查询，从行政组织（外场、空运总调）基础资料中选择；“到达站”从行政组织（外场）、偏线代理、机场空运代理网点信息基础资料中选择；“运输性质”默认为全部，包含：精准卡航，精准城运，精准汽运（长途），精准汽运（短途），汽运偏线，精准空运精准汽运、精准卡航、汽运偏线、精准空运。
SR-6	走货路径的第一段线路的“出发站”必须与走货路径的“出发站”一致，走货路径的最后一段线路的“到达站”必须与走货路径的“到达站”一致，走货路径第n段线路的“出发站”必须与走货路径第n-1段线路的“到达站”一致；
SR-7	走货路径的线路中，选择的“到达站”在线路中的站点位置必须在“出发站”的站点位置之后；
SR-8	新增/修改线路页面，“是否可以打木架”单选按钮，是或否，默认为否，若值为“否”，单选按钮为只读状态，不允许选择“是”；若值为“是”，单选按钮可以选择为“否”；“打木架外场”与“是否可以打木架”联动，若“是否可以打木架”值为“否”，“打木架外场”隐藏；若“是否可以打木架”值为“是”，“打木架外场”显示，下拉框里会把拥有“可以打木架”属性的外场查询出来，默认为第一个具有“可以打木架” 属性的外场；
SR-9	新增/修改页面，相同运输性质，出发站和到达站之间，只能有一条默认走货路径。 
“出发站对应营业部”、“到达站对应营业部”与“是否默认走货路径”联动，
若“是否默认走货路径”选中，：
1、“出发站对应营业部”为所有不是默认的始发配载部门为“出发站”的营业部；
2、“到达站对应营业部”显示所有不是默认的到达配载部门为“到达站”的营业部；否则：
1、“出发站对应营业部”显示所有始发配载部门为“出发站”的营业部；
2、“到达站对应营业部”显示所有到达配置部门为“到达站”的营业部；
SR-10	新增/修改页面
1、当运输性质为“汽运偏线”或者“精准空运”且走货路径不是默认路径时，“出发网点组”不能为空，“到达网点组”为空；
2、当运输性质为“精准汽运”或者“精准卡航”且走货路径不是默认路径时，“出发网点组”和“到达网点组”均不能为空
SR-10	走货路径的状态在“失效”状态下，不能使用，只有在“生效”状态下才能使用；修改走货路径时，必须把状态修改为“失效”状态，才能进行其他数据修改。

1.8	数据元素
1.8.1	走货路径新增/修改信息
字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
运输性质	运输性质,包含：精准卡航，精准城运，精准汽运（长途），精准汽运（短途），汽运偏线，精准空运精准汽运、精准卡航、汽运偏线、精准空运	下拉框		10	是	参见业务规则：SR-1
出发站	出发站名称	选择框		50	是	参见业务规则：SR-1
到达站	到达站名称	选择框		50	是	参见业务规则：SR-1
时效（小时）	根据走货路径的“运输性质”和所选“线路名称”联动带出	N/A		4	N/A	参见业务规则：SR-2
是否默认走货路径	该走货路径是否为营业部的默认走货路径	选择框		2	是	默认选中
是否可以打木架	是否可以允许打木架，是或否	单选框		2	否	默认为否，参见业务规则：SR-8
打木架外场	具有打木架功能的外场	下拉框		10	是	参见业务规则：SR-8
备注	备注	文本		200	否	
出发站对应营业部	出发站对应营业部	下拉列表		100	N/A	
出发网点组	出发网点组	下拉列表				表示哪些营业部划分为一出发网点组
到达站对应营业部	到达站对应营业部	下拉列表		100	N/A	
到达网点组	到达网点组	下拉列表		100		表示哪些营业部划分为一到达网点组
1.8.2	走货路径列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
出发站	出发站名称	N/A	50	N/A	
到达站	到达站名称	N/A	50	N/A	
运输性质	运输性质,包含：精准卡航，精准城运，精准汽运（长途），精准汽运（短途），汽运偏线，精准空运精准汽运、精准卡航、汽运偏线、精准空运 	N/A	10	N/A	
时效（小时）	走货路径的运行时效，单位：小时	N/A	50	N/A	
是否可以打木架	是否可以允许打木架，是或否	N/A	2	N/A	
打木架外场	具有打木架功能的外场	N/A	10	N/A	
是否默认走货路径	该走货路径是否为营业部的默认走货路径	N/A	2	N/A	
状态	状态,包括生效、失效两种状态	N/A	10	N/A	
1.8.3	走货路径查询条件
字段名称 	说明 	输入限制	长度	是否必填	备注
出发站	出发站名称	选择框	50	否	参见业务规则：SR-5
到达站	到达站名称	选择框	50	否	参见业务规则：SR-5
运输性质	运输性质,默认全部	下拉框	10	否	参见业务规则：SR-5
状态	状态,包括全部、生效、失效，默认为全部	下拉框	10	否	
1.8.4	网点组列表数据
字段名称 	说明 	输入限制	长度	是否必填	备注
出发网点组	出发网点组，包含作为一组的营业部	N/A	1000	N/A	
到达网点组	到达网点组，包含作为一组的营业部	N/A	1000	N/A	

1.8.5	线路列表信息
字段名称 	说明 	输入限制	长度	是否必填	备注
序号	该线路在走货路径中所占的顺序	N/A	2	N/A	
线路名称	中转到中转线路名称，从中转到中转线路信息基础资料中选择	N/A	50	N/A	
线路简码	线路简码	N/A	10	N/A	
出发站	出发站名称	N/A	50	N/A	
到达站	到达站名称	N/A	50	N/A	
时效（小时）	中转到中转线路的运行时效，单位小时	N/A	4	N/A	
经停时间（小时）	停留时间，单位:小时	N/A	4	N/A	

1.8.6	线路新增/修改信息
字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
序号	该线路在走货路径中所占的顺序	数字		2		
线路名称	中转到中转线路名称，从中转到中转线路信息基础资料中选择	选择框		50	是	参见业务规则：SR-3
线路简码	线路简码	N/A		10	N/A	自动带出
出发站	出发站名称	选择框		50	是	
到达站	到达站名称	选择框		50	是	
时效（小时）	中转到中转线路的运行时效，单位小时	N/A		4	N/A	自动带出
经停时间（小时）	停留时间，单位:小时	数字		4	是	
1.9	非功能性需求
使用量	
2012年全网估计用户数	
响应要求（如果与全系统要求 不一致的话）	
使用时间段	
高峰使用时间段	

1.10	接口描述
接口名称 	对方系统（外部系统或内部其他模块）	接口描述
		
		
*/



package com.deppon.foss.module.base.baseinfo.server.service.impl;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.BooleanUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.springframework.transaction.annotation.Transactional;

import com.deppon.foss.base.util.ComnConst;
import com.deppon.foss.base.util.SqlUtil;
import com.deppon.foss.base.util.define.NumberConstants;
import com.deppon.foss.base.util.define.SymbolConstants;
import com.deppon.foss.framework.cache.CacheManager;
import com.deppon.foss.framework.cache.ICache;
import com.deppon.foss.framework.server.components.export.excel.ExportResource;
import com.deppon.foss.module.base.baseinfo.api.server.dao.IExpressLineDao;
import com.deppon.foss.module.base.baseinfo.api.server.dao.IFreightRouteDao;
import com.deppon.foss.module.base.baseinfo.api.server.dao.IFreightRouteLineDao;
import com.deppon.foss.module.base.baseinfo.api.server.service.IAdministrativeRegionsService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IEmployeeService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IExpressDepartureStandardService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IExpressLineService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ILdpAgencyDeptService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ILineItemService;
import com.deppon.foss.module.base.baseinfo.api.server.service.INetGroupService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IOrgAdministrativeInfoService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IOutfieldService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ISaleDepartmentService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ISyncLineInfosToGpsService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IVehicleAgencyCompanyService;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressDepartureStandardEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.FreightRouteEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.FreightRouteLineEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.LineItemEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.OrgAdministrativeInfoEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.OuterBranchExpressEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.OutfieldEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.QueryingConstant;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.SaleDepartmentEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.AgingDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.DepartureStandardDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.FreightRouteLineAgingDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.LineInfoDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.LineStationsDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.MapDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.NetGroupSiteDto;
import com.deppon.foss.module.base.baseinfo.api.shared.exception.LineException;
import com.deppon.foss.module.base.baseinfo.server.util.LineUtils;
import com.deppon.foss.module.base.dict.api.server.service.IDataDictionaryValueService;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryConstants;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryValueConstants;
import com.deppon.foss.module.base.dict.api.shared.domain.DataDictionaryValueEntity;
import com.deppon.foss.module.pickup.pricing.api.server.service.IProductService;
import com.deppon.foss.module.pickup.pricing.api.shared.define.PricingConstants;
import com.deppon.foss.module.pickup.pricing.api.shared.domain.ProductEntity;
import com.deppon.foss.module.pickup.pricing.api.shared.dto.ProductDto;
import com.deppon.foss.util.common.FossTTLCache;
import com.deppon.foss.util.define.FossConstants;
import com.google.inject.Inject;


/**
 * 线路服务类
 * @author foss-zhujunyong
 * @date Oct 26, 2012 3:22:56 PM
 * @version 1.0
 */
public class ExpressLineService implements IExpressLineService {

    /**
     * 日志打印类
     */
    private static final Logger log = Logger.getLogger(ExpressLineService.class);

    /**
     * lineDao
     */
    @Inject
    private IExpressLineDao expresslineDao;
    
    /**
     * orgAdministrativeInfoService
     */
    @Inject
    private IOrgAdministrativeInfoService orgAdministrativeInfoService;
    
    /**
     * administrativeRegionsService
     */
    @Inject
    private IAdministrativeRegionsService administrativeRegionsService;

    /**
     * lineItemService
     */
    @Inject
    private ILineItemService lineItemService;
    
    /**
     * departureStandardService
     */
    @Inject
    private IExpressDepartureStandardService expressdepartureStandardService;
    
    /**
     * productService
     */
    @Inject
    private IProductService productService;
    
    /**
     * freightRouteLineDao
     */
    @Inject
    private IFreightRouteLineDao freightRouteLineDao;
    
    /**
     * freightRouteDao
     */
    @Inject
    private IFreightRouteDao freightRouteDao;

    /**
     * syncLineInfosToGpsService
     */
    private ISyncLineInfosToGpsService syncLineInfosToGpsService;
    
    /**
     * dataDictionaryValueService
     */
    @Inject
    private IDataDictionaryValueService dataDictionaryValueService;
    
    /**
     * 
     * vehicleAgencyCompanyService
     */
    @Inject
    private IVehicleAgencyCompanyService vehicleAgencyCompanyService;

    @Inject
    private ISaleDepartmentService saleDepartmentService;
    
    @Inject
    private INetGroupService netGroupService;
    
    private ILdpAgencyDeptService ldpAgencyDeptService;
    
    private IEmployeeService employeeService;
    /**
     * 外场 Service接口
     */
    @Inject
    private IOutfieldService outfieldService;
    

	public void setEmployeeService(IEmployeeService employeeService) {
		this.employeeService = employeeService;
	}

	/**
     * @param outfieldService the outfieldService to set
     */
    public void setOutfieldService(IOutfieldService outfieldService) {
        this.outfieldService = outfieldService;
    }

    /**
     * @param netGroupService the netGroupService to set
     */
    public void setNetGroupService(INetGroupService netGroupService) {
        this.netGroupService = netGroupService;
    }

    /**
     * @param saleDepartmentService the saleDepartmentService to set
     */
    public void setSaleDepartmentService(
    	ISaleDepartmentService saleDepartmentService) {
        this.saleDepartmentService = saleDepartmentService;
    }



    /**
     * @param vehicleAgencyCompanyService the vehicleAgencyCompanyService to set
     */
    public void setVehicleAgencyCompanyService(
    	IVehicleAgencyCompanyService vehicleAgencyCompanyService) {
        this.vehicleAgencyCompanyService = vehicleAgencyCompanyService;
    }

    
    
    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:27:29 AM
     * @param dataDictionaryValueService
     * @see
     */
    public void setDataDictionaryValueService(IDataDictionaryValueService dataDictionaryValueService) {
        this.dataDictionaryValueService = dataDictionaryValueService;
    }
    
    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:27:35 AM
     * @param syncLineInfosToGpsService
     * @see
     */
    public void setSyncLineInfosToGpsService(ISyncLineInfosToGpsService syncLineInfosToGpsService) {
        this.syncLineInfosToGpsService = syncLineInfosToGpsService;
    }

    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:14:46 AM
     * @param freightRouteLineDao
     * @see
     */
    public void setFreightRouteLineDao(IFreightRouteLineDao freightRouteLineDao) {
        this.freightRouteLineDao = freightRouteLineDao;
    }

    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:14:54 AM
     * @param productService
     * @see
     */
    public void setProductService(IProductService productService) {
        this.productService = productService;
    }
    
    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:27:45 AM
     * @param lineItemService
     * @see
     */
    public void setLineItemService(ILineItemService lineItemService) {
        this.lineItemService = lineItemService;
    }

    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:27:50 AM
     * @param expresslineDao
     * @see
     */
    public void setExpresslineDao(IExpressLineDao expresslineDao) {
		this.expresslineDao = expresslineDao;
	}

	
    
    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:27:55 AM
     * @param freightRouteDao
     * @see
     */
    public void setFreightRouteDao(IFreightRouteDao freightRouteDao) {
        this.freightRouteDao = freightRouteDao;
    }

   

	/**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:28:01 AM
     * @param orgAdministrativeInfoService
     * @see
     */
    public void setOrgAdministrativeInfoService(IOrgAdministrativeInfoService orgAdministrativeInfoService) {
        this.orgAdministrativeInfoService = orgAdministrativeInfoService;
    }
    
    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:28:06 AM
     * @param administrativeRegionsService
     * @see
     */
    public void setAdministrativeRegionsService(IAdministrativeRegionsService administrativeRegionsService) {
        this.administrativeRegionsService = administrativeRegionsService;
    }

    /**
     * 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:13:27 AM
     * @param expressdepartureStandardService
     * @see
     */
    public void setExpressdepartureStandardService(
			IExpressDepartureStandardService expressdepartureStandardService) {
		this.expressdepartureStandardService = expressdepartureStandardService;
	}


    /** 
     * <p>添加线路</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.IExpressLineService#addLine(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity)
     */
    @Override
    @Transactional
    public ExpressLineEntity addLine(ExpressLineEntity line) {
	// 检查参数
	if (line == null) {
	    return null;
	}
	// 如果是到达线路，只有汽运一种类型
	if (StringUtils.equals(DictionaryValueConstants.BSE_LINE_SORT_TARGET, line.getLineSort())) {
	    line.setTransType(DictionaryValueConstants.BSE_LINE_TRANSTYPE_QIYUN);
	}

	// 检查线路简码是否有重复
	ExpressLineEntity entity = querySimpleLineBySimpleCodeNoCache(line.getSimpleCode());
	if (entity != null) {
	    throw new LineException(LineException.SIMPLECODE_EXIST);
	}
	// 检查是否有重复属性的线路（相同出发和到达站，线路类型的默认线路是否重复等）
	validateDuplication(line, null);
	
	// 驻地营业部/派送部始发线路和到达线路只能配置给对应的驻地外场。
	validStation(line);

	// 如果是运作到运作线路的专线类型（也就是有线段的），则默认为invalid。 否则都默认为valid
	if (StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) 
		&& StringUtils.equals(line.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN)) {
	    line.setValid(FossConstants.NO);
	} else {
	    line.setValid(FossConstants.YES);
	}
	//如果是到达线路
	if (StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)){
	    validateExpressOutAssemble(line.getOrginalOrganizationCode(), line.getDestinationOrganizationCode());
	}
	System.out.println("添加进入service");
	ExpressLineEntity expressLineEntity = expresslineDao.addLine(line);
	/*//如果是到达线路和始发线路
	if (StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)||StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)){
		  //同步到短途GPS
		syncLineInfoToGps(ExpressLineEntity, NumberConstants.ONE);
	}*/
	 
	return expressLineEntity;
    }
    
    /**
     * <p>验证到达线路如果‘到达站’是落地陪公司或网点，需要验证‘出发站’外场是否配置了‘可落地外发配载’</p> 
     * @author 094463-foss-xieyantao
     * @date 2013-10-9 下午5:41:01
     * @param orCode 出发站外场编码
     * @param deCode 到达站编码
     * @see
     */
    private void validateExpressOutAssemble(String orCode,String deCode){
	if(StringUtils.isNotBlank(deCode)){
	    String subDecode = deCode.substring(0, NumberConstants.NUMBER_3);
	    if(StringUtils.equals("LDP", subDecode)){
		if(StringUtils.isNotBlank(orCode)){
		    OutfieldEntity entity = outfieldService.queryOutfieldByOrgCodeNoCache(orCode);
		    if(null != entity){
			//验证‘出发站’外场是否配置了‘可落地外发配载’
			if(StringUtils.equals(FossConstants.NO, entity.getExpressOutAssemble())){
			    throw new LineException("出发站外场没有配置属性为：可落地外发配载！");
			}
		    }else {
			throw new LineException("出发站外场没有配置属性为：可落地外发配载！");
		    }
		}
	    }
	}
    }
    /**
     * 
     * 向GPS同步线路数据(供修改新增发车标准时候用)</p> 
     * @author foss-lifanghong
     * @param line 线路实体
     * @param isDeleted 操作标识：1：新增 2：修改 3：删除 删除 默认0.
     * @return
     * @see
     */
    @Override
	public void sendLineInfoToGps(ExpressLineEntity line, int isDeleted) {
    	syncLineInfoToGps(line,isDeleted);		
	} 
    /**
     * 
     * 向GPS同步线路数据</p> 
     * @author foss-lifanghong
     * @param line 线路实体
     * @param isDeleted 操作标识：1：新增 2：修改 3：删除 删除 默认0.
     * @return
     * @see
     */
	private boolean syncLineInfoToGps(ExpressLineEntity line, int isDeleted) {
	// 检查参数
	if (line == null) {
	    return false;
	}
	// 只有运作到运作的线路新增才需要像GPS同步数据
//	if (!StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER)) {
//	    return false;
//	}
	// 向GPS同步线路数据
	boolean result = false;
	try {
	    LineInfoDto lineInfo = new LineInfoDto();
	    lineInfo.setLineId(line.getVirtualCode());
	    lineInfo.setLineName(line.getLineName());
	    //卡车时效（千分之小时）
	    if(line.getFastAging()!=null){
			 double fastAging = (double) (line.getFastAging())/NumberConstants.NUMBER_1000*NumberConstants.NUMBER_60;
			  lineInfo.setRuntime(new Float(fastAging));
		}
	    // 线路距离
	    lineInfo.setMile(new Float(line.getDistance())); 
	    OrgAdministrativeInfoEntity orginal = orgAdministrativeInfoService.queryOrgAdministrativeInfoByCodeClean(line.getOrginalOrganizationCode());
	    if (orginal != null && StringUtils.isNotBlank(orginal.getUnifiedCode())) {
		lineInfo.setStartsiteId(orginal.getUnifiedCode());
	    }
	    OrgAdministrativeInfoEntity destination = orgAdministrativeInfoService.queryOrgAdministrativeInfoByCodeClean(line.getDestinationOrganizationCode());
	    if (destination != null && StringUtils.isNotBlank(destination.getUnifiedCode())) {
		lineInfo.setArrivalsiteId(destination.getUnifiedCode());
	    }
	    lineInfo.setIsDeleted(isDeleted);
	    syncLineInfosToGpsService.syncLineInfosToGps(lineInfo);
	    result = true;
	} catch (Exception t) {
	    log.error("发送到GPS出错", t);
	    result = false;
	}
	return result;
    }
    /**
     * 
     * <p>检查相同出发和到达站，线路类型的默认线路是否重复</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:18:14 AM
     * @param line
     * @param virtualCode
     * @see
     */
    private void validateDuplication(ExpressLineEntity line, String virtualCode) {
	// 检查参数
	if (line == null) {
	    return;
	}
	// 如果是始发线路，出发部门，运输类型和默认线路不能都相同
	ExpressLineEntity c = new ExpressLineEntity();
	c.setLineSort(line.getLineSort());
	c.setOrginalOrganizationCode(line.getOrginalOrganizationCode());
	c.setDestinationOrganizationCode(line.getDestinationOrganizationCode());
	//做修改时 先校验两个点之间，是否有重复
	if(StringUtils.isNotBlank(virtualCode)){
		List<ExpressLineEntity> newlist = querySimpleLineListByCondition(c);
		if(CollectionUtils.isNotEmpty(newlist)){
			boolean count =true;
			for (ExpressLineEntity expressLineEntity : newlist) {
				if(!StringUtils.equals(virtualCode, expressLineEntity.getVirtualCode())){
					count =false;
				}
			}
			if (!count) {
				throw new LineException(LineException.DUPLICATION);
			}
		}
		
	}
	
	// 中转线路
	// 同一个营业部，同一种运输方式，默认的只能有一个线路, 非默认的虽然可以有多个线路,但是到同一外场的只能有一个
	if (StringUtils.equals(DictionaryValueConstants.BSE_LINE_SORT_TRANSFER, line.getLineSort())) {
	    c.setLineType(line.getLineType());
	} else { // 始发或到达线路
	    c.setTransType(line.getTransType());
	    if (StringUtils.equals(FossConstants.YES, line.getIsDefault())) {
		c.setIsDefault(line.getIsDefault());
		// 默认线路的情况下，始发线路只管始发营业部，到达线路只管到达营业部
		if (StringUtils.equals(DictionaryValueConstants.BSE_LINE_SORT_SOURCE, line.getLineSort())) {
		    c.setDestinationOrganizationCode(null);
		} else {
		    c.setOrginalOrganizationCode(null);
		 }
	    }
	}
	// 检查是否有默认重复
	List<ExpressLineEntity> list = querySimpleLineListByCondition(c);
		if (CollectionUtils.isNotEmpty(list)) {
		    if (StringUtils.isBlank(virtualCode)) {
			throw new LineException(LineException.DUPLICATION);
		    } 
		    //虚拟编码不为空  说明是做修改操作
		    for (ExpressLineEntity entity : list) {
				// 如果是另一条线路，并且当前线路和找到的线路都是默认的，则非法，因为两点之间不能有两条默认线路
				if (!StringUtils.equals(virtualCode, entity.getVirtualCode()) && StringUtils.equals(FossConstants.YES, entity.getIsDefault()) && StringUtils.equals(FossConstants.YES, line.getIsDefault())) {
					throw new LineException(LineException.DUPLICATION);
				}
		    }
		}
    }
    
    /**
     * <p>驻地营业部/派送部始发线路和到达线路只能配置给对应的驻地外场。</p> 
     * @author foss-zhujunyong
     * @
     * @date Mar 5, 2013 10:18:14 AM
     * @param line
     * @see
     */
    private void validStation(ExpressLineEntity line) {
    	
		// 始发线路
		if (StringUtils.equals(DictionaryValueConstants.BSE_LINE_SORT_SOURCE,
				line.getLineSort())) {
			// 查找始发营业部
			SaleDepartmentEntity entity = this.saleDepartmentService.querySaleDepartmentByCode(line.getOrginalOrganizationCode());
			
			// 如果是驻地营业部，则始发线路只能配置对应的驻地外场
			if (null!=entity&&FossConstants.YES.equals(entity.getStation())) {
				if (!StringUtils.equals(line.getDestinationOrganizationCode(), entity.getTransferCenter())) {
					throw new LineException("始发线路只能配置对应的驻地外场");
				}
			}
		}
		// 到达线路
		else if (StringUtils.equals(
				DictionaryValueConstants.BSE_LINE_SORT_TARGET,
				line.getLineSort())) {
			// 查找到达营业部
			SaleDepartmentEntity entity = this.saleDepartmentService.querySaleDepartmentByCode(line.getDestinationOrganizationCode());
			
			// 如果是驻地营业部，则始发线路只能配置对应的驻地外场
			if (entity != null && FossConstants.YES.equals(entity.getStation())) {
				if (!StringUtils.equals(line.getOrginalOrganizationCode(), entity.getTransferCenter())) {
					throw new LineException("到达线路只能配置对应的驻地外场");
				}
			}
		}
    	
    }
    
    /** 
     * <p>作废线路</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line 只用virtualCode和modifyUser
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#deleteLine(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity)
     */
    @Override
    @Transactional
    public ExpressLineEntity deleteLine(ExpressLineEntity line) {
    
//     ExpressLineEntity  toGpsEntity = new ExpressLineEntity();
	// 检查参数
	if (line == null) {
	    return null;
	}
	ExpressLineEntity entity = queryLineByVirtualCode(line.getVirtualCode());
//	toGpsEntity = entity;
	if (entity == null){
	    return null;
	}

	// 如果是始发线路，还需要同步作废网点组
	if (StringUtils.equals(entity.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)) {
	  //  boolean isExist = checkSameSourceTargetLineExist(entity.getOrginalOrganizationCode(), entity.getDestinationOrganizationCode(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE, line.getVirtualCode());
	  //    if (BooleanUtils.isFalse(isExist)) {
		netGroupService.deleteSourceNetGroup(entity.getOrginalOrganizationCode(), entity.getDestinationOrganizationCode(), line.getModifyUser(),entity.getTransType(),FossConstants.NETWORK_GROUP_EXP);
	  //    }
	}
	// 如果是到达线路，还需要同步作废网点组
	if (StringUtils.equals(entity.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)) {
	    boolean isExist = checkSameSourceTargetLineExist(entity.getOrginalOrganizationCode(), entity.getDestinationOrganizationCode(), DictionaryValueConstants.BSE_LINE_SORT_TARGET, line.getVirtualCode());
	    if (BooleanUtils.isFalse(isExist)) {
		netGroupService.deleteTargetNetGroup(entity.getDestinationOrganizationCode(), entity.getOrginalOrganizationCode(), line.getModifyUser(),FossConstants.NETWORK_GROUP_EXP);
	    }
	}
	
	// 如果是运作线路，专线类型，并且有效性为Y，则不能作废
	if (entity.checkValid() 
		&& StringUtils.equals(entity.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) 
		&& StringUtils.equals(DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN, entity.getLineType())) {
	    throw new LineException(LineException.VALID_LINE_CAN_NOT_BE_DELETED);
	}
	
	// 检查该线路在走货路径中是否已经引用，若引用则不让删
	checkReferenceInFreightRoute(line.getVirtualCode());
	
	// 作废线段
	lineItemService.deleteLineItemByLine(line.getVirtualCode(), line.getModifyUser());
	// 作废发车标准
	expressdepartureStandardService.deleteDepartureStandardByLine(line.getVirtualCode(), line.getModifyUser());
	entity = expresslineDao.deleteLine(line);
	//如果是到达线路和始发线路
	/*if (StringUtils.equals(toGpsEntity.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)||StringUtils.equals(toGpsEntity.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)){
		//同步到短途GPS
		syncLineInfoToGps(toGpsEntity, NumberConstants.THREE);
	}*/
	// 清空缓存
	if (entity != null) {
	    invalidEntity(entity.getVirtualCode());
	    invalidEntity(entity.getSimpleCode());
	}
	
	return entity;
    }

    /**
     * 
     * <p>检查该线路在走货路径中是否已经引用，若引用则不让删</p> 
     * 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:28:18 AM
     * @param lineVirtualCode
     * @see
     */
    private void checkReferenceInFreightRoute(String lineVirtualCode) {
	// 检查该线路在走货路径中是否已经引用，若引用则不让删
	List<FreightRouteLineEntity> list = freightRouteLineDao.queryFreightRouteLineListByLine(lineVirtualCode);
	if (CollectionUtils.isNotEmpty(list)) {
	   throw new LineException(LineException.USED_BY_FREIGHTROUTE);
	}
    }
    
    /**
     * 
     * <p>批量作废线路</p> 
     * @author foss-zhujunyong
     * @date Mar 13, 2013 10:28:37 AM
     * @param virtualCodes
     * @param modifyUser 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#deleteLineList(java.util.List, java.lang.String)
     */
    @Override
    @Transactional
    public void deleteLineList(List<String> virtualCodes, String modifyUser) {
	// 检查参数
	if (CollectionUtils.isEmpty(virtualCodes) || StringUtils.isBlank(modifyUser)) {
	    return;
	}
	for (String virtualCode : virtualCodes) {
	    // 检查该线路在走货路径中是否已经引用，若引用则不让删
	    checkReferenceInFreightRoute(virtualCode);
	    ExpressLineEntity line = new ExpressLineEntity();
	    line.setVirtualCode(virtualCode);
	    line.setModifyUser(modifyUser);
	    deleteLine(line);
	}
    }
    
    /** 
     * <p>更新线路</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#updateLine(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity)
     */
    @Override
    @Transactional
    public ExpressLineEntity updateLine(ExpressLineEntity line) {
	// 检查参数
	if (line == null) {
	    return null;
	}

	// 查询数据库中的原有记录
	ExpressLineEntity old = querySimpleLineByVirtualCode(line.getVirtualCode());

	//313353 sonar
	this.sonarSplitOne(line, old);
	
	// 检查是否有重复线路属性（出发站到达站，默认线路等）
	validateDuplication(line, line.getVirtualCode());
		
	// 驻地营业部/派送部始发线路和到达线路只能配置给对应的驻地外场。
	validStation(line);
		
	// 如果出发部门或到达部门发生了变更 (如果是始发或到达线路)
	this.sonarSplitTwo(line, old);
	
	// 如果是到达线路，只有汽运一种类型
	if (StringUtils.equals(DictionaryValueConstants.BSE_LINE_SORT_TARGET, line.getLineSort())) {
	    line.setTransType(DictionaryValueConstants.BSE_LINE_TRANSTYPE_QIYUN);
	    //验证到达线路如果‘到达站’是落地陪公司或网点，需要验证‘出发站’外场是否配置了‘可落地外发配载’
	    validateExpressOutAssemble(line.getOrginalOrganizationCode(), line.getDestinationOrganizationCode());
	}
	//如果是始发或到达线路，把valid设定成Y。否则若线路为运作到运作，不修改valid值。
	if(StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
			||StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)){
		line.setValid("Y");
	}
	ExpressLineEntity result = expresslineDao.updateLine(line);
	
	List<ExpressDepartureStandardEntity> departureStandardEntitys = expressdepartureStandardService.queryDepartureStandardListByLineVirtualCode(line.getVirtualCode());
	//如果是到达线路和始发线路 取发车标准第一个的时效
		if (StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)||StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)){
		//如果是始发到达线路新增修改发车标准的时候要同步给gps  时效
			if(CollectionUtils.isNotEmpty(departureStandardEntitys)){
				if(StringUtils.isNotBlank(departureStandardEntitys.get(NumberConstants.ZERO).getLeaveTime())&&StringUtils.isNotBlank(departureStandardEntitys.get(NumberConstants.ZERO).getArriveTime())){
					//准点出发时间
					String leaveTime = departureStandardEntitys.get(NumberConstants.ZERO).getLeaveTime();
					// 准点到达时间(eg: 1645)
					String arriveTime = departureStandardEntitys.get(NumberConstants.ZERO).getArriveTime();
					long fastAging=0;
					DateFormat df = new SimpleDateFormat("HHmm");
					try {
						Date d1 = df.parse(leaveTime);
						Date d2 = df.parse(arriveTime);
						long hours = d2.getTime()+(departureStandardEntitys.get(NumberConstants.ZERO).getArriveDay()*NumberConstants.NUMBER_24*NumberConstants.NUMBER_3600*NumberConstants.NUMBER_1000) - d1.getTime();
//						Double.longBitsToDouble(hours);
						fastAging = hours/NumberConstants.NUMBER_3600;
					}catch (Exception e){
						log.error(e);
					}
					result.setFastAging(fastAging);
					//同步到短途GPS
					//sendLineInfoToGps(line, NumberConstants.TWO);
				}
			}
		 }
	
	// 清空缓存
	if (result != null) {
	    invalidEntity(result.getVirtualCode());
	    invalidEntity(result.getSimpleCode());
	}
	return enhanceLine(result);
    }
    
	/**
	 * sonar优化拆分
	 * 
	 * @author 313353
	 */
	private void sonarSplitOne(ExpressLineEntity line, ExpressLineEntity old) {
		// 如果是运作线路，专线类型，并且有效性为Y，则不能修改出发站和到达站
		if (line.checkValid() 
			&& StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) 
			&& StringUtils.equals(DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN, line.getLineType())) {
		    
		    if (old == null) {
			// 如果老线路不存在，则无法修改
			throw new LineException(LineException.LINE_DOES_NOT_EXIST);
		    }
		    // 如果生效线路的出发站或者到达站被修改过了，则抛出异常
		    if (!StringUtils.equals(old.getOrginalOrganizationCode(), line.getOrginalOrganizationCode())
			    || !StringUtils.equals(old.getDestinationOrganizationCode(), line.getDestinationOrganizationCode())) {
			throw new LineException(LineException.VALID_LINE_CAN_NOT_CHANGE_SITE);
		    }
		}
		// 检查线路简码是否有重复
		ExpressLineEntity entity = querySimpleLineBySimpleCodeNoCache(line.getSimpleCode());
		if (entity != null && !StringUtils.equals(line.getVirtualCode(), entity.getVirtualCode())) {
			    throw new LineException(LineException.SIMPLECODE_EXIST);
		}
	}
	
    
	/**
	 * sonar优化拆分
	 * 
	 * @author 313353
	 */
	private void sonarSplitTwo(ExpressLineEntity line, ExpressLineEntity old) {
		if ((!StringUtils.equals(old.getOrginalOrganizationCode(), line.getOrginalOrganizationCode()) || !StringUtils.equals(
				old.getDestinationOrganizationCode(), line.getDestinationOrganizationCode()))
				&& !StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER)) {
			    boolean isExist = checkSameSourceTargetLineExist(old.getOrginalOrganizationCode(), old.getDestinationOrganizationCode(), old.getLineSort(), old.getVirtualCode());
			    // 如果是始发线路
			    if (StringUtils.equals(old.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE) && BooleanUtils.isFalse(isExist)) {
				netGroupService.deleteSourceNetGroup(old.getOrginalOrganizationCode(), old.getDestinationOrganizationCode(), line.getModifyUser(),old.getTransType(),FossConstants.NETWORK_GROUP_EXP);
			    }
			    // 如果是到达线路
			    if (StringUtils.equals(old.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET) && BooleanUtils.isFalse(isExist)) {
				netGroupService.deleteTargetNetGroup(old.getDestinationOrganizationCode(), old.getOrginalOrganizationCode(), line.getModifyUser(),FossConstants.NETWORK_GROUP_EXP);
			    }
			}
	}

    /**
     * 
     * <p>根据虚拟编码查询线路</p> 
     * @author foss-zhujunyong
     * @date Oct 25, 2012 11:33:00 AM
     * @param id
     * @return
     * @see
     */
    @Override
    public ExpressLineEntity queryLineByVirtualCode(String virtualCode) {
	return enhanceLine(querySimpleLineByVirtualCode(virtualCode));
    }
    
    /**
     * 
     * <p>根据虚拟编码查询线路,不包含其他冗余属性</p> 
     * @author foss-zhujunyong
     * @date Mar 14, 2013 11:35:12 AM
     * @param virtualCode
     * @return
     * @see
     */
    @Override
    public ExpressLineEntity querySimpleLineByVirtualCode(String virtualCode) {
	if (StringUtils.isBlank(virtualCode)) {
	    return null;
	}
	// 查询缓存
	ExpressLineEntity entity = null;
	if(SqlUtil.loadCache){//客户端不读缓存
	    entity = queryEntityCache(virtualCode);
	} else {
	    entity = expresslineDao.queryLineByVirtualCode(virtualCode);
	}
	return entity;
    }
    

    /** 
     * <p>根据查询条件查询线路</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line
     * @param start
     * @param limit
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#queryLineListByCondition(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity, int, int)
     */
    @Override
    public List<ExpressLineEntity> queryLineListByCondition(ExpressLineEntity line, int start, int limit) {
	ExpressLineEntity entity = line == null ? new ExpressLineEntity() : line;
	return enhanceLineList(expresslineDao.queryLineListByCondition(entity, start, limit));
    }

    /** 
     * <p>根据查询条件查询线路,不包括出发站目的站名称等冗余信息</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line
     * @param start
     * @param limit
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#queryLineListByCondition(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity, int, int)
     */
    @Override
    public List<ExpressLineEntity> querySimpleLineListByCondition(ExpressLineEntity line, int start, int limit) {
	ExpressLineEntity entity = line == null ? new ExpressLineEntity() : line;
	return expresslineDao.queryLineListByCondition(entity, start, limit);
    }
    
    /** 
     * <p>根据查询条件查询线路,不包括出发站目的站名称等冗余信息</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line
     * @param start
     * @param limit
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#queryLineListByCondition(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity, int, int)
     */
    @Override
    public List<ExpressLineEntity> querySimpleLineListByCondition(ExpressLineEntity line) {
	return querySimpleLineListByCondition(line, 0, Integer.MAX_VALUE);
    }
    
    /**
     * 
     * <p>根据查询条件查询线路,不带分页</p> 
     * @author foss-zhujunyong
     * @date Nov 4, 2012 5:20:59 PM
     * @param line
     * @return
     * @see
     */
    @Override
    public List<ExpressLineEntity> queryLineListByCondition(ExpressLineEntity line) {
	return queryLineListByCondition(line, 0, Integer.MAX_VALUE);
    }
    
    
    /**
     * 
     * <p>按出发部门查询空运线路的到达部门</p> 
     * @author foss-zhujunyong
     * @date Dec 7, 2012 10:21:10 AM
     * @param sourceCode 出发部门编码
     * @return
     * @see
     */
    @Override
    public List<String> queryAirLineBySource(String sourceCode) {
	List<String> resultList = new ArrayList<String>();
	if (StringUtils.isBlank(sourceCode)) {
	    return resultList;
	}
	ExpressLineEntity condition = new ExpressLineEntity();
	condition.setOrginalOrganizationCode(sourceCode);
	condition.setActive(FossConstants.ACTIVE);
	condition.setLineType(DictionaryValueConstants.BSE_LINE_TYPE_KONGYUN);
	condition.setTransType(DictionaryValueConstants.BSE_LINE_TRANSTYPE_KONGYUN);
	List<ExpressLineEntity> lineList = expresslineDao.queryLineListBySourceAndType(condition);
	if (CollectionUtils.isEmpty(lineList)) {
	    return resultList;
	}
	for (ExpressLineEntity line : lineList) {
	    resultList.add(line.getDestinationOrganizationCode());
	}
	return resultList;
    }
    
    /** 
     * <p>根据查询条件查询线路数量</p> 
     * @author foss-zhujunyong
     * @date Oct 26, 2012 3:22:56 PM
     * @param line
     * @return 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#countLineListByCondition(com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity)
     */
    @Override
    public long countLineListByCondition(ExpressLineEntity line) {
	return expresslineDao.countLineListByCondition(line);
    }

    /**
     * 
     * <p>填充出发城市和目的城市等冗余和扩充字段，一般为名称类的，因为数据库中只保存了编码</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:21:27 AM
     * @param line
     * @return
     * @see
     */
    private ExpressLineEntity enhanceLine(ExpressLineEntity line) {
	if (line == null) {
	    return null;
	}
	// 填充出发站名称
	if (StringUtils.isBlank(line.getOrginalOrganizationName())) {
	    line.setOrginalOrganizationName(orgAdministrativeInfoService.queryCommonNameByCommonCode(line.getOrginalOrganizationCode()));
	}
	// 填充到达站名称
	if (StringUtils.isBlank(line.getDestinationOrganizationName())) {
	    line.setDestinationOrganizationName(orgAdministrativeInfoService.queryCommonNameByCommonCode(line.getDestinationOrganizationCode()));
	}
	// 填充出发城市名称
	if (StringUtils.isBlank(line.getOrginalCityName())) {
	    line.setOrginalCityName(administrativeRegionsService.queryAdministrativeRegionsNameByCode(line.getOrginalCityCode()));
	}
	// 填充到达城市名称
	if (StringUtils.isBlank(line.getDestinationCityName())) {
	    line.setDestinationCityName(administrativeRegionsService.queryAdministrativeRegionsNameByCode(line.getDestinationCityCode()));
	}
	// 填充管理车队名称
	if (StringUtils.isBlank(line.getOrganizationName())) {
	    line.setOrganizationName(orgAdministrativeInfoService.queryOrgAdministrativeInfoNameByCode(line.getOrganizationCode()));
	}
	// 填充发车标准列表
	if (CollectionUtils.isEmpty(line.getStandardList())) {
	    List<ExpressDepartureStandardEntity> standardList = expressdepartureStandardService.queryDepartureStandardListByLineVirtualCode(line.getVirtualCode());
	    line.setStandardList(standardList);
	}
	// 返回填充好的线路
	return line;
    }
    
    /**
     * 
     * <p>批量填充出发城市和目的城市</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:23:37 AM
     * @param list
     * @return
     * @see
     */
    private List<ExpressLineEntity> enhanceLineList(List<ExpressLineEntity> list) {
	if (CollectionUtils.isEmpty(list)) {
	    return new ArrayList<ExpressLineEntity> ();
	}
	for (ExpressLineEntity line : list) {
	    enhanceLine(line);
	}
	return list;
    }
    
    /**
     * 
     * <p>根据出发部门（外场）编码查询所有直接到达的部门（外场）编码</p> 
     * @author foss-zhujunyong
     * @date Nov 5, 2012 3:41:28 PM
     * @param sourceCode 出发外场的部门编码
     * @return
     * @see
     */
    @Override
    public List<String> queryTargetCodeListBySourceCode(String sourceCode) {
	List<String> resultList = new ArrayList<String> ();
	if (StringUtils.isBlank(sourceCode)) {
	    return resultList;
	}
	
	LineItemEntity condition = new LineItemEntity();
	condition.setActive(FossConstants.ACTIVE);
	condition.setOrginalOrganizationCode(sourceCode);
	List<LineItemEntity> list = lineItemService.querySimpleLineItemListByCondition(condition);
	// 过滤掉其所挂载线路为失效状态的
	List<LineItemEntity> effectList = new ArrayList<LineItemEntity> ();
	for (LineItemEntity item : list) {
	    if (item == null || StringUtils.isBlank(item.getLineVirtualCode())) {
		continue;
	    }
	    ExpressLineEntity line = queryLineByVirtualCode(item.getLineVirtualCode());
	    if (line != null && line.checkValid()) {
		effectList.add(item);
	    }
	}
	
	// 把生效线段列表中的目的站找出来
	for (LineItemEntity entity : effectList) {
	    if (!resultList.contains(entity.getDestinationOrganizationCode())) {
		resultList.add(entity.getDestinationOrganizationCode());
	    }
	}
	return resultList;
    }
    
    /**
     * 
     * <p>通过始发营业部查询默认始发配置外场
     * 或通过到达营业部查询默认到达外场</p> 
     * @author foss-zhujunyong
     * @date Nov 12, 2012 4:03:28 PM
     * @param saleCode
     * @param productCode
     * @param lineSort
     * @return
     * @see
     */
    @Override
    public String queryDefaultTransCode(String saleCode, String productCode, String lineSort) {
	return queryDefaultTransCode(saleCode, productCode, lineSort, new Date());
    }
    
    /**
     * 
     * <p>通过始发营业部查询默认始发配置外场
     * 或通过到达营业部查询默认到达外场</p> 
     * 按时间建模查找
     * @author foss-zhujunyong
     * @date Nov 12, 2012 4:03:28 PM
     * @param saleCode
     * @param productCode
     * @param lineSort
     * @param date
     * @return
     * @see
     */
    @Override
    public String queryDefaultTransCode(String saleCode, String productCode, String lineSort, Date date) {
	String result = null;
	ExpressLineEntity condition = new ExpressLineEntity();
	if (StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_SOURCE)) {
	    condition.setOrginalOrganizationCode(saleCode);
	} else {
	    condition.setDestinationOrganizationCode(saleCode);
	}
	condition.setLineSort(lineSort);
	// 始发线路需要区分汽运和空运，到达线路就不用区分了
	if (StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_SOURCE)) {
	    condition.setTransType(LineUtils.convertProductCodeToTransType(productCode));
	}
	condition.setIsDefault(FossConstants.YES);
	condition.setModifyDate(date);
	List<ExpressLineEntity> list = querySimpleLineListByCondition(condition);
	if (CollectionUtils.isEmpty(list)) {
	    // 始发配载或到达配载中找不到，说明这是一个孤儿营业部，不能出发或到达
	    return result;
	} else {
	    // 取得默认的到达配置外场
	    ExpressLineEntity line = list.get(0);
	    return StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_SOURCE) ? line.getDestinationOrganizationCode() : line.getOrginalOrganizationCode();
	}
    }

    /**
     * 
     * <p>计算在一条线路上指定起点和终点以及指定产品类型的时效</p> 
     * @author foss-zhujunyong
     * @date Dec 4, 2012 5:18:02 PM
     * @param line
     * @param sourceCode
     * @param targetCode
     * @param productCode
     * @return
     * @see
     */
    @Override
    public Long calculateAging(ExpressLineEntity line, String sourceCode, String targetCode, String productCode) {
	if (StringUtils.isBlank(productCode)) {
	    return null;
	}
	// 这里要注入ProductService
	String priority = queryProductPriorityByCode(productCode, new Date());
	if (StringUtils.isBlank(priority)) {// 如果返回为空，则默认为普车时效
	    priority = DictionaryValueConstants.PRODUCT_NORMAL;
	}
	FreightRouteLineAgingDto agingDto = calculateAging(line, sourceCode, targetCode);
	if (agingDto == null) {
	    return null;
	}
	return LineUtils.isFast(priority) ? agingDto.getCurrentFastAging() : agingDto.getCurrentCommonAging();
    }
    
    /**
     * 
     * 计算在一条线路上指定起点和终点的半截线路的卡车时效和普车时效
     * @author foss-zhujunyong
     * @date Nov 9, 2012 11:13:39 AM
     * @param line 线路实体
     * @param sourceCode 出发部门
     * @param targetCode 到达部门
     * @return
     * @see
     */
    @Override
    public FreightRouteLineAgingDto calculateAging(ExpressLineEntity line, String sourceCode, String targetCode) {
	// 如果连线路实体都为空的话，计算线路的时效根本就没有意义
	if (line == null) {
	    return null;
	}
	long lineCommonAging = line.getCommonAging() == null ? 0 : line.getCommonAging();
	long lineFastAging = line.getFastAging() == null ? 0 : line.getFastAging();
	long lineOtherAging = line.getOtherAging() == null ? 0 : line.getOtherAging();
	
	List<LineItemEntity> lineItemList = lineItemService.querySimpleLineItemListByLineVirtualCode(line.getVirtualCode());
	
	// 创建返回结果
	FreightRouteLineAgingDto result = new FreightRouteLineAgingDto();
	result.setLineVirtualCode(line.getVirtualCode());
	result.setSourceCode(sourceCode);
	result.setTargetCode(targetCode);
	// 默认值设为中转线路，如果是始发或者到达，后面会重设该值
	result.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TRANSFER);
	
	boolean sourceMatch = false;
	Long beforeCommonAging = 0L;
	Long beforeFastAging = 0L;
	Long currentCommonAging = 0L;
	Long currentFastAging = 0L;
	// 线段列表为空，说明是始发或到达线路或偏线，空运等
	if (CollectionUtils.isEmpty(lineItemList)) {
	    // 如果是始发或到达
	    if (!StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER)) {
		// 把线路类型设成始发或者到达都可以，因为始发到达都是从发车标准来查时效，一样处理，只要不是运作到运作就行。
		result.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_SOURCE);
		currentCommonAging = lineCommonAging;
		currentFastAging = lineFastAging;
		// 如果是偏线或空运
	    } else if (!StringUtils.equals(line.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN)) {
		currentCommonAging = lineOtherAging;
		currentFastAging = lineOtherAging;
	    }
	    lineItemList = new ArrayList<LineItemEntity> ();
	}
	for (LineItemEntity lineItem : lineItemList) {
	    long commonAging = lineItem.getCommonAging() == null ? 0 : lineItem.getCommonAging();
	    long fastAging = lineItem.getFastAging() == null ? 0 : lineItem.getFastAging();
	    long passbyAging = lineItem.getPassbyAging() == null ? 0 : lineItem.getPassbyAging();
	    
	    // 如果出发部门匹配，则不再累加出发时效
	    if(StringUtils.equals(lineItem.getOrginalOrganizationCode(), sourceCode)) {
		sourceMatch = true;
	    }  
	    // 如果到达部门匹配，则累加到达时效并退出运算
	    if(StringUtils.equals(lineItem.getDestinationOrganizationCode(), targetCode)) {
		// 到达部门的经停时效不用计算
		currentCommonAging += commonAging;
		currentFastAging += fastAging;
		break;
	    } else 
		// 如果线段的出发部门不是走货路径线路的出发部门，则累加出发时效
	    if (BooleanUtils.isFalse(sourceMatch)) { 
		beforeCommonAging += commonAging + passbyAging;
		beforeFastAging += fastAging + passbyAging;
		// 如果线段的出发部门已经匹配，到达部门尚未匹配，则累加到达时效,要加上经停时间
	    } else { 
		currentCommonAging += commonAging + passbyAging;
		currentFastAging += fastAging + passbyAging;
	    }
	}
	result.setBeforeCommonAging(beforeCommonAging);
	result.setBeforeFastAging(beforeFastAging);
	result.setCurrentCommonAging(currentCommonAging);
	result.setCurrentFastAging(currentFastAging);
	return result;
    }

    /**
     * 
     * <p>通过线路虚拟编码和班次，查出发车时间和到达时间</p> 
     * @author foss-zhujunyong
     * @date Nov 14, 2012 11:17:08 AM
     * @param lineVirtualCode
     * @param sequence
     * @return
     * @see
     */
    @Override
    public DepartureStandardDto queryDepartureStandardByLineSequence(String lineVirtualCode, int sequence){
	ExpressDepartureStandardEntity standard = expressdepartureStandardService.queryDepartureStandardByLineVirtualCodeAndSequence(lineVirtualCode, sequence);
	if (standard == null) {
	    return null;
	}
	DepartureStandardDto result = new DepartureStandardDto();
	result.setLineVirtualCode(lineVirtualCode);
	result.setDepartureStandardVirtualCode(standard.getVirtualCode());
	result.setLeaveTime(standard.getLeaveTime());
	result.setProductType(standard.getProductType());
	// 如果是始发到达线路，那么到达时间是默认的，自然就给返回了
	if (StringUtils.isNotBlank(standard.getArriveTime())){
	    result.setArriveTime(standard.getArriveTime());
	    result.setArriveDay(standard.getArriveDay() == null ? 0 : standard.getArriveDay().intValue());
	    return result;
	}
	// 否则的话，只能是中转专线线路
	ExpressLineEntity line = queryLineByVirtualCode(lineVirtualCode);
	result.setSourceCode(line.getOrginalOrganizationCode());
	result.setTargetCode(line.getDestinationOrganizationCode());
	result.setLineName(line.getLineName());
	
	int minuteOffset = LineUtils.convertHourToMinute(LineUtils.isFast(standard.getProductType()) ? line.getFastAging() : line.getCommonAging());
	AgingDto dto = LineUtils.calculatePartLineStandard(standard.getLeaveTime(), minuteOffset);
	result.setArriveTime(dto.getTime());
	result.setArriveDay(dto.getDay());
	return result;
    }
    
    /**
     * 
     * <p>根据出发部门和到达部门查询班次列表</p> 
     * 只能找到专线的，因为偏线和空运没有班次的说法
     * @author foss-zhujunyong
     * @date Nov 9, 2012 2:04:40 PM
     * @param sourceCode
     * @param targetCode
     * @return
     * @see
     */
    @Override
    public List<DepartureStandardDto> queryDepartureStandardListBySourceTarget(
	    String sourceCode, String targetCode) {
	List<DepartureStandardDto> resultList = new ArrayList<DepartureStandardDto>();
	// 判断参数是否合法
	if (StringUtils.isBlank(sourceCode) || StringUtils.isBlank(targetCode) 
		|| StringUtils.equals(sourceCode, targetCode)) {
	    return resultList;
	}
	
	// 在线路表中找符合条件的线路(包含了偏线和空运等)
	ExpressLineEntity condition = new ExpressLineEntity();
	condition.setOrginalOrganizationCode(sourceCode);
	condition.setDestinationOrganizationCode(targetCode);
	List<ExpressLineEntity> lineList = querySimpleLineListByCondition(condition);
	
	// 在线段表中找符合条件的线路（也包括半截线路）（线段表中只有专线）
	List<String> lineVirutalCodeList = lineItemService.queryLineVirtualCodeListBySourceTarget(sourceCode, targetCode);
	// 过滤掉已经在lineList中存在的线路
	List<String> partLineCodeList = new ArrayList<String>();
	for (String virtualCode : lineVirutalCodeList) {
	    if(BooleanUtils.isFalse(isLineExist(lineList, virtualCode))){
		partLineCodeList.add(virtualCode);
	    }
	}
	// 把经过过滤的半截线路和线路表中找到的线路整合起来
	for (String virtualCode : partLineCodeList) {
	    lineList.add(querySimpleLineByVirtualCode(virtualCode));
	}
	// 根据线路和班次扩展出符合条件的实体添加到结果集中
	for (ExpressLineEntity line : lineList) {
	    if (line == null) {
		continue;
	    }
	    // 取一截线路的卡车时效和普车时效
	    FreightRouteLineAgingDto dto = calculateAging(line, sourceCode, targetCode);
	    List<ExpressDepartureStandardEntity> standardList = expressdepartureStandardService.queryDepartureStandardListByLineVirtualCode(line.getVirtualCode());
	    if (CollectionUtils.isEmpty(standardList)) {
		// 如果该线路没有发车标准，说明是偏线或者空运，忽略掉
		continue;
	    }
	    for (ExpressDepartureStandardEntity standard : standardList) {
		DepartureStandardDto result = LineUtils.calculateDepartureStandardBySourceTarget(standard, dto);
		result.setLineName(line.getLineName());
		result.setLineSimpleCode(line.getSimpleCode());
		resultList.add(result);
	    }
	}
	return resultList;
	
    }

    /**
     * 
     * <p>判断特定的线路虚拟编码是否在线路列表中存在</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:25:34 AM
     * @param list
     * @param virtualCode
     * @return
     * @see
     */
    private boolean isLineExist(List<ExpressLineEntity> list, String virtualCode){
	for (ExpressLineEntity line : list) {
	    if (StringUtils.equals(line.getVirtualCode(), virtualCode)) {
		return true;
	    }
	}
	return false;
    }

    /**
     * 
     * <p>只需要判断出发部门直达到达部门的线路是否存在，如果不存在则返回空</p> 
     * 要根据传入的时间找出最近的一个班次返回
     * @author foss-zhujunyong
     * @date Nov 15, 2012 11:17:53 AM
     * @param sourceCode
     * @param targetCode
     * @param date
     * @return
     * @see
     */
    @Override
    public DepartureStandardDto queryDepartureStandardListBySourceTargetDirectly(
	    String sourceCode, String targetCode, Date date) {
	// 判断参数是否合法
	if (StringUtils.isBlank(sourceCode) || StringUtils.isBlank(targetCode) || StringUtils.equals(sourceCode, targetCode) || date == null) {
	    return null;
	}
	// 尝试找偏线代理公司
	String companyCode = vehicleAgencyCompanyService.queryCompanyCodeBySiteCode(targetCode);
	String destCode = StringUtils.isBlank(companyCode) ? targetCode : companyCode;

	
	// 在线路表中查找符合的线路
	ExpressLineEntity condition = new ExpressLineEntity();
	condition.setOrginalOrganizationCode(sourceCode);
	condition.setDestinationOrganizationCode(destCode);
	List<ExpressLineEntity> lineList = querySimpleLineListByCondition(condition);
	// 如果找不到符合的线路，则返回null
	if (CollectionUtils.isEmpty(lineList)) {
	    return null;
	}
	for (ExpressLineEntity line : lineList) {
	    if (line == null) {
		continue;
	    }
	    // 如果是中转线路
	    if (StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER)) {
		List<LineItemEntity> itemList = lineItemService.querySimpleLineItemListByLineVirtualCode(line.getVirtualCode());
		ExpressDepartureStandardEntity standard = null;
		// 如果是偏线或者空运
		if (CollectionUtils.isEmpty(itemList) && !StringUtils.equals(line.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN)) {
		    return LineUtils.createExpressDepartureStandardDto(line, standard);
		} else 
		// 如果只有一条线段，即直达线路
		if (itemList.size() == BigDecimal.ONE.intValue()) {
		    standard = expressdepartureStandardService.queryDepartureStandardByLineAndTime(line, date);
		    return LineUtils.createExpressDepartureStandardDto(line, standard);
		}
		// 否则只能是始发或到达线路
	    } else {
	    	ExpressDepartureStandardEntity standard = expressdepartureStandardService.queryDepartureStandardByLineAndTime(line, date);
		return LineUtils.createExpressDepartureStandardDto(line, standard);
	    }
	}
	// 找不到合适的线路，则返回null
	return null;
    }

    /**
     * 
     * <p>根据线路简码查询线路实体</p>
     * 因为线路简码不能重复，所以只能查出一条线路 
     * @author foss-zhujunyong
     * @date Nov 16, 2012 11:16:12 AM
     * @param simpleCode
     * @return
     * @see
     */
    @Override
    public ExpressLineEntity queryLineBySimpleCode(String simpleCode) {
	return enhanceLine(querySimpleLineBySimpleCode(simpleCode));
    }
    /**
     * <p>根据线路简码查询线路实体, 不包含冗余属性</p>
     * 因为线路简码不能重复，所以只能查出一条线路 
     * @author foss-zhujunyong
     * @date Nov 16, 2012 11:16:12 AM
     * @param simpleCode
     * @return
     * @see
     */
    @Override
    public ExpressLineEntity querySimpleLineBySimpleCode(String simpleCode) {
	if (StringUtils.isBlank(simpleCode)) {
	    return null;
	}
	// 在缓存中查找
	ExpressLineEntity entity = null;
	if (SqlUtil.loadCache) {
	    entity = queryEntityCache(simpleCode);
	}
	
	return enhanceLine(entity);
    }
	/**
	 * <p>
	 * 根据线路简码查询线路实体, 不包含冗余属性(不走缓存查询)
	 * </p>
	 * 
	 * @author 130566-zengjunfan
	 * @param simpleCode
	 * @return
	 */
	@Override
	public ExpressLineEntity querySimpleLineBySimpleCodeNoCache(String simpleCode) {
		if (StringUtils.isBlank(simpleCode)) {
			return null;
		}
		// 不走缓存查询，直接查询库中记录
		/*List<ExpressLineEntity> resultList = lineDao.queryExpressLineEntityBySimpleCode(simpleCode);
		if (CollectionUtils.isEmpty(resultList)) {
			return null;
		}
		ExpressLineEntity entity = resultList.get(0);
		return enhanceLine(entity);*/
		return null;
	}
    /**
     * 
     * <p>通过线路虚拟编码，出发部门和到达部门编码查询出发部门和到达部门之间的距离</p>
     * 如果出发部门和到达部门传空，则返回线路总距离 
     * @author foss-zhujunyong
     * @date Nov 16, 2012 11:29:36 AM
     * @param lineVirtualCode
     * @param sourceCode
     * @param targetCode
     * @return
     * @see
     */
    @Override
    public Long queryDistanceBySourceTarget(String lineVirtualCode,
	    String sourceCode, String targetCode) {
	if (StringUtils.isBlank(lineVirtualCode)) {
	    return null;
	}
	ExpressLineEntity line = queryLineByVirtualCode(lineVirtualCode);
	if (line == null) {
	    return null;
	}
	//如果传入的出发部门和到达部门为空，则返回整条线路长度。如果出发部门和到达部门和线路的一致，也返回整条线路长度
	if ((StringUtils.isBlank(sourceCode) && StringUtils.isBlank(targetCode))
		|| (StringUtils.equals(line.getOrginalOrganizationCode(), sourceCode) && StringUtils.equals(line.getDestinationOrganizationCode(), targetCode))) {
	    return line.getDistance();
	}
	// 下面的代码都是计算半条线路的长度
	List<LineItemEntity> itemList = lineItemService.querySimpleLineItemListByLineVirtualCode(lineVirtualCode);
	if (CollectionUtils.isEmpty(itemList)) {
	    return null;
	}
	long result = 0;
	boolean header = false;
	for (LineItemEntity item : itemList) {
	    if (StringUtils.equals(item.getOrginalOrganizationCode(), sourceCode)) {
		header = true;
	    }
	    if (BooleanUtils.isTrue(header)) {
		result += item.getDistance();
	    }
	    if (StringUtils.equals(item.getDestinationOrganizationCode(), targetCode)) {
		break;
	    }
	}
	return result;
    }

    /**
     * 
     * <p>通过外场的部门编码查询所有辐射到达的营业部</p> 
     * @author foss-zhujunyong
     * @date Nov 16, 2012 3:08:33 PM
     * @param transferCode
     * @return
     * @see
     */
    @Override
    public List<String> queryArriveCodeListByTransferCode(String transferCode) {
	List<String> resultList = new ArrayList<String>();
	if (StringUtils.isBlank(transferCode)) {
	    return resultList;
	}
	// 在到达线路中查询
	ExpressLineEntity condition = new ExpressLineEntity();
	condition.setActive(FossConstants.ACTIVE);
	condition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TARGET);
	condition.setOrginalOrganizationCode(transferCode);
	List<ExpressLineEntity> lineList = querySimpleLineListByCondition(condition);
	if (CollectionUtils.isEmpty(lineList)) {
	    return resultList;
	}
	// 把符合的到达线路的到达部门（营业部）放入返回列表
	for (ExpressLineEntity line : lineList) {
	    resultList.add(line.getDestinationOrganizationCode());
	}
	return resultList;
    }

    /**
     * 
     * <p>根据出发部门和到达部门查询班次列表</p> 
     * 只能找到专线的，因为偏线和空运没有班次的说法
     * @author foss-zhujunyong
     * @date Nov 19, 2012 2:50:12 PM
     * @param sourceCode 出发部门
     * @param targetCode 到达部门
     * @param productCode 第三极产品类型
     * @return
     * @see
     */
    @Override
    public List<DepartureStandardDto> queryDepartureStandardListBySourceTarget(
	    String sourceCode, String targetCode, String productCode) {
	List<DepartureStandardDto> resultList = queryDepartureStandardListBySourceTarget(sourceCode, targetCode);
	if (StringUtils.isBlank(productCode)) {
	    return resultList;
	}
	
	// 这里要注入ProductService
	String priority = queryProductPriorityByCode(productCode, new Date());
	if (StringUtils.isBlank(priority)) {// 如果返回为空，则默认为普车时效
	    priority = DictionaryValueConstants.PRODUCT_NORMAL;
	}
	// 把符合条件的发车标准dto返回
	List<DepartureStandardDto> list = new ArrayList<DepartureStandardDto>();
	for (DepartureStandardDto dto : resultList) {
	    if (dto == null) {
		continue;
	    }
	    // 如果发车标准中有到达时间，说明是始发或到达线路的，
	    if (StringUtils.isNotBlank(dto.getArriveTime())||StringUtils.equals(dto.getProductType(), priority)) {
		list.add(dto);
		// 如果是中转线路，则需要过滤班车的卡普属性
	    } /*else if (StringUtils.equals(dto.getProductType(), priority)) {
		list.add(dto);
	    }*/
	}
	return list;
    }

    /**
     * 
     * <p>根据产品代码取产品优先级</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:27:20 AM
     * @param productCode
     * @param date
     * @return
     * @see
     */
    private String queryProductPriorityByCode(String productCode, Date date){
	ProductDto c = new ProductDto();
	c.setCode(productCode);
	List<ProductEntity> list = productService.findExternalProductByCondition(c, date);
	if (CollectionUtils.isEmpty(list)) {
	    return null;
	}
	return list.get(0).getPriority();
    }

    /**
     * 
     * <p>通过外场编码查询所有的辐射到的出发营业部</p>
     * 包括默认始发配载和非默认的
     * 不包括驻地营业部（驻地营业部只能从所属外场出发） 
     * 主要给走货路径添加修改界面，给网点组选择对应的营业部使用,getIsDefault可以判断是否为默认
     * @author foss-zhujunyong
     * @date Dec 4, 2012 11:29:33 AM
     * @param transferCode
     * @return
     * @see
     */
    @Override
    public List<NetGroupSiteDto> querySourceLineListByTransferCode(String transferCode,String productCode) {
    	List<NetGroupSiteDto> resultList = new ArrayList<NetGroupSiteDto>();
    	//2014.1.22日，根据网点组优化需求，有关汽运产品的走货路径只显示汽运的始发线路网点组信息，空运的只显示空运相关的网点组信息 而进行改造
    	//修改内容为：将该接口增加一个参数，走货路径的产品类型，用于筛选始发线路，目前快递的产品默认只走汽运
    	if (StringUtils.isBlank(transferCode)||StringUtils.isBlank(productCode)) {
    	    return resultList;
    	}
    	ExpressLineEntity condition = new ExpressLineEntity();
    	condition.setActive(FossConstants.ACTIVE);
    	condition.setDestinationOrganizationCode(transferCode);
    	condition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_SOURCE);
    	//根据产品类型进行判断
    	if(PricingConstants.ProductEntityConstants.PRICING_PRODUCT_C1_C20002.equals(productCode)
    			||PricingConstants.ProductEntityConstants.PRICING_PRODUCT_C2_C20004.equals(productCode)
    			||PricingConstants.ProductEntityConstants.PRICING_PRODUCT_AIR_FREIGHT.equals(productCode)){
    		condition.setTransType(DictionaryValueConstants.BSE_LINE_TRANSTYPE_KONGYUN);
    	}
    	else{
    		condition.setTransType(DictionaryValueConstants.BSE_LINE_TRANSTYPE_QIYUN);
    	}
    	List<ExpressLineEntity> lineList = queryLineListByCondition(condition);
    	if (CollectionUtils.isEmpty(lineList)) {
    	    return resultList;
    	}
    	for (ExpressLineEntity line : lineList) {
    	    NetGroupSiteDto result = new NetGroupSiteDto();
    	    result.setCode(line.getOrginalOrganizationCode());
    	    result.setName(line.getOrginalOrganizationName());
    	    result.setDefault(StringUtils.equals(line.getIsDefault(), FossConstants.YES));
    	    resultList.add(result);
    	}
    	return resultList;
        }
    /**
     * 
     * <p>通过外场编码查询所有的辐射到的到达营业部</p>
     * 包括默认始发配载和非默认的
     * 不包括驻地营业部（驻地营业部只能从所属外场出发） 
     * 主要给走货路径添加修改界面，给网点组选择对应的营业部使用,getIsDefault可以判断是否为默认
     * @author foss-zhujunyong
     * @date Dec 4, 2012 11:31:20 AM
     * @param transferCode
     * @return
     * @see
     */
    @Override
    public List<NetGroupSiteDto> queryTargetLineListByTransferCode(String transferCode) {
	List<NetGroupSiteDto> resultList = new ArrayList<NetGroupSiteDto>();
	if (StringUtils.isBlank(transferCode)) {
	    return resultList;
	}
	ExpressLineEntity condition = new ExpressLineEntity();
	condition.setActive(FossConstants.ACTIVE);
	condition.setOrginalOrganizationCode(transferCode);
	condition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TARGET);
	List<ExpressLineEntity> lineList = queryLineListByCondition(condition);
	if (CollectionUtils.isEmpty(lineList)) {
	    return resultList;
	}
	for (ExpressLineEntity line : lineList) {
	    NetGroupSiteDto result = new NetGroupSiteDto();
	    result.setCode(line.getDestinationOrganizationCode());
	    // 如果目的营业部不具备可到达属性，则不返回 
	    if (!checkArrive(result.getCode())) {
		continue;
	    }
	    result.setName(line.getDestinationOrganizationName());
	    result.setDefault(StringUtils.equals(line.getIsDefault(), FossConstants.YES));
	    resultList.add(result);
	}
	return resultList;
    }

    /**
     * 
     * <p>检查是否可到达</p> 
     * @author foss-zhujunyong
     * @date May 28, 2013 5:32:03 PM
     * @param code
     * @return
     * @see
     */
    private boolean checkArrive(String code) {
	if (StringUtils.isBlank(code)) {
	    return false;
	}
	SaleDepartmentEntity sale = saleDepartmentService.querySaleDepartmentByCode(code);
	return sale != null && sale.checkArrive();
    }
    
    
    /**
     * 
     * <p>导出线路到excel</p>
     * 线路对象的线路类别必须指定，用来判断是导出运作线路还是始发或到达线路
     * 运作线路lineSort类型： DictionaryValueConstants.BSE_LINE_SORT_TRANSFER
     * 始发或到达lineSort类型：DictionaryValueConstants.BSE_LINE_SORT_SOURCE
     * 或DictionaryValueConstants.BSE_LINE_SORT_TARGET
     * @author foss-zhujunyong
     * @date Dec 19, 2012 7:54:17 PM
     * @param line
     * @return
     * @see
     */
    @Override
    public ExportResource exportLineList(ExpressLineEntity line){
	// 线路对象的线路类别必须指定，用来判断是导出运作线路还是始发或到达线路
	if (line == null || StringUtils.isBlank(line.getLineSort())) {
	    return null;
	}
	List<ExpressLineEntity> list =  expresslineDao.queryLineListForExport(line, 0, Integer.MAX_VALUE);
	// 返回的结果集
	List<List<String>> resultList = new ArrayList<List<String>>();
	// 在循环外判断好，提高性能
	boolean isTransfer = StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER);

	// 取线路类型的数据字典(专线,偏线,空运)
	List<DataDictionaryValueEntity> lineTypeList = dataDictionaryValueService.queryDataDictionaryValueByTermsCode(DictionaryConstants.BSE_TRANS_LINE_TYPE);
	Map<String, String> lineTypeMap = new HashMap<String, String>();
	for (DataDictionaryValueEntity data : lineTypeList) {
	    lineTypeMap.put(data.getValueCode(), data.getValueName());
	}
	// 取运输类型的数据字典(汽运,空运)
	List<DataDictionaryValueEntity> transTypeList = dataDictionaryValueService.queryDataDictionaryValueByTermsCode(DictionaryConstants.BSE_TRANS_TYPE);
	Map<String, String> transTypeMap = new HashMap<String, String>();
	for (DataDictionaryValueEntity data : transTypeList) {
	    transTypeMap.put(data.getValueCode(), data.getValueName());
	}
	for (ExpressLineEntity entity : list) {
		//班次为空不用导出
		if(entity.getFrequencyNo()==0){
			continue;
		}else{
		    // 导出运作或始发到达格式
		    List<String> result = isTransfer ? exportTransferLine(entity, lineTypeMap) : exportSourceTargetLine(entity, transTypeMap);
		    resultList.add(result);
		}
	}
	ExportResource sheet = new ExportResource();
	if (StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER)) {
	    sheet.setHeads(ComnConst.LINE_TRANSFER_TITLE);
	} else {
	    sheet.setHeads(ComnConst.LINE_SOURCE_TARGET_TITLE);
	}
	sheet.setRowList(resultList);
	return sheet;
    }
    
    /**
     * 
     * <p>导出中转线路</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:28:22 AM
     * @param line
     * @return
     * @see
     */
    private List<String> exportTransferLine(ExpressLineEntity line, Map<String, String> lineTypeMap){
    	List<String> result = new ArrayList<String>();
    	result.add(line.getLineName());
    	result.add(line.getSimpleCode());
    	result.add(lineTypeMap.get(line.getLineType()));
    	result.add(line.getOrginalOrganizationName());
    	result.add(line.getOrginalCityName());
    	result.add(line.getDestinationOrganizationName());
    	result.add(line.getDestinationCityName());
    	result.add(String.valueOf(line.getDistance()));
    	result.add(line.getOrganizationName());
    	
    	result.add(Integer.toString(line.getFrequencyNo()));
    	//result.add(line.getLeaveTime());
    	if(StringUtils.isNotBlank(line.getLeaveTime())){
    		String time = line.getLeaveTime();
    		String times = time.substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+time.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    		result.add(times);
    	}else{
    		result.add(" ");
    	}
    	
    	List<LineItemEntity> lineItemEntityList = lineItemService.queryLineItemListByLineVirtualCode(line.getVirtualCode());// 根据线路虚拟编码查询线路下线段信息
    	if(CollectionUtils.isEmpty(lineItemEntityList)){
    		result.add(" ");
    		result.add(" ");
    	}else{
    		long a = lineItemEntityList.get(0).getFastAging();
    		long b = lineItemEntityList.get(0).getCommonAging();
    		double fastAging = new Double(a);
    		double commonAging = new Double(b);
    		result.add(fastAging/NumberConstants.NUMBER_1000+"");
    		result.add(commonAging/NumberConstants.NUMBER_1000+"");
    	}
    	
    	//313353 sonar
    	this.sonarSplitThree(line, result, lineItemEntityList);
    	//313353 sonar
    	this.sonarSplitFour(line, result, lineItemEntityList);
    	
    	if(StringUtils.isNotBlank(line.getArriveDeadTime())){
    		result.add(line.getArriveDeadTime().substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+line.getArriveDeadTime().substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4)+"-"+line.getArriveDeadDay()+"天");
    	}else{
    		if(StringUtils.isNotBlank(line.getLeaveTime())){
    			String time = line.getLeaveTime();
    			String times = time.substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+time.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    			result.add(times+"-"+line.getArriveDeadDay()+"天");
    		}else{
    			result.add(" "+"-"+line.getArriveDeadDay()+"天");
    		}
    	}
    	//根据工号查询姓名
    	String modifyUserName;
    	if(StringUtils.isNotBlank(line.getModifyUserCode())){
    		modifyUserName = employeeService.queryEmpNameByEmpCode(line.getModifyUserCode());
    		if(StringUtils.isNotBlank(modifyUserName)){
    			result.add(modifyUserName);
    		}else{
    			result.add(line.getModifyUserCode());
    		}
    	}else{
    		result.add(line.getModifyUserCode());
    	}
    	
    	if(!(line.getModifyTime()==null)){
    	SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");  
    	String modifyTime=sdf.format(line.getModifyTime());  
    	if(StringUtils.equals("2099-12-31",modifyTime)||StringUtils.equals("2999-12-31",modifyTime)){
    		result.add(null); 
    	}else{
    		result.add(modifyTime); 
    	}
    	
    	}else{
    		result.add(" ");
    	}
    	result.add(line.getNotes());
//    	result.add(line.getArriveDeadTime());
    	
//    	if(FossConstants.YES.equals(line.getIsDefault())){
//    		result.add(QueryingConstant.YES);
//    	}else{
//    		result.add(QueryingConstant.NO);
//    	}
    //	
    	
    	return result;
        }
    
	/**
	 * sonar优化拆分
	 * 
	 * @author 313353
	 */
	private void sonarSplitThree(ExpressLineEntity line, List<String> result, 
			List<LineItemEntity> lineItemEntityList) {
		//对卡车和普车的到达时间进行处理
    	if(StringUtils.isNotBlank(line.getFastAging()+"")){
    		//result.add(line.getLeaveTime());
    		if(StringUtils.isNotBlank(line.getLeaveTime())){
    			String time = line.getLeaveTime();
    			double leaveTime = new Double(time);
    			if(CollectionUtils.isEmpty(lineItemEntityList)){
    				result.add(" ");
    			}else{
    				long a = lineItemEntityList.get(0).getFastAging();
    				double fastAgingHour = (new Double(a))/NumberConstants.NUMBER_1000;
    				String stringhour = fastAgingHour+"";
    				String[] fastAgingTime = stringhour.split("[.]");
    				String b;
    				String c;
    				double fastAging = new Double(a);
//    				String sfastAging = fastAging+"";
    				if(fastAgingTime.length>1){
    					b = fastAgingTime[0];
    					c = fastAgingTime[1];
    					fastAging = (new Double(b))*NumberConstants.NUMBER_100+(new Double((c+"00").substring(NumberConstants.STRING_LOCATION_0, NumberConstants.STRING_LOCATION_2)))*NumberConstants.MUTT_06;
    				}else{
    					fastAging = (new Double(fastAgingTime[0]))*NumberConstants.NUMBER_100;
    				}
    				double fastArriveTime;
//    				if(sfastAging.length()>5){
//    					fastArriveTime = leaveTime+fastAging/10;
//    				}else{
    					fastArriveTime = leaveTime+fastAging;
//    				}
    				String arriveTimes = fastArriveTime%NumberConstants.NUMBER_2400+"";
    				String[] arriveTime = arriveTimes.split("[.]");
    				String arriveHour;
    				if(arriveTime[0].length()==NumberConstants.NUMBER_2){
    					arriveHour="00"+arriveTime[0]+"0";
    				}else if(arriveTime[0].length()==NumberConstants.NUMBER_3){
    					arriveHour="0"+arriveTime[0]+"0";
    				}else if(arriveTime[0].length()==1){
    					arriveHour="000"+arriveTime[0]+"0";
    				}else{
    					arriveHour=arriveTime[0]+"0";
    				}
    				double arriveDay = fastArriveTime/NumberConstants.NUMBER_2400;
    				double min = new Double(arriveHour.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_3));
    				String hour;
    				//判断分数是否超多60
    				if(min>=NumberConstants.NUMBER_6){
    					if((new Double(arriveHour)+NumberConstants.NUMBER_400)>=NumberConstants.NUMBER_24000){//如果大于24小时天数加1
    						arriveDay=+1;
    						hour = (new Double(arriveHour)-NumberConstants.NUMBER_23600)+"";
    					}else{
    						hour = (new Double(arriveHour)+NumberConstants.NUMBER_400)+"";
    					}
    				}else{
    					hour=arriveHour;
    				}
    				String[] hours = hour.split("[.]");
    				String arrive;
    				String date;
    				if(new Double((hours[0]+"000").substring(NumberConstants.STRING_LOCATION_0, NumberConstants.STRING_LOCATION_2))>NumberConstants.NUMBER_23||new Double((hours[0]+"000").
    						substring(NumberConstants.STRING_LOCATION_2, NumberConstants.STRING_LOCATION_4))>NumberConstants.NUMBER_60||new Double(arriveTimes)<NumberConstants.NUMBER_201){
    					if(new Double(hours[0])<NumberConstants.NUMBER_100){
    						date = "00"+hour;
    					}else if(min>=NumberConstants.NUMBER_6){
    						date = "0"+hour;
    					}else{
    						date = hour;
    					}
    				}else{
    					date=hour.split("[.]")[0];
    				}
    				if(new Double((date+"00000").substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4))>=NumberConstants.NUMBER_60){
    					arrive = ("0"+date+"00").substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+("0"+date+"00000").substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    				}else{
    					arrive = (date+"00").substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+(date+"00000").substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    				}
//    				if(hours.length>1){
    					 
//    				}else{
//    					 arrive = (hours[0]+"00").substring(0,2)+":00";
//    				}
//    				result.add(arrive+"+"+Math.floor(new Integer(arriveDay))+"天");
    				result.add(arrive+"+"+(int)arriveDay+"天");
    			}
    		}else{
    			result.add(" ");
    		}
    	}else{
    		result.add(" ");
    	}
	}
    
	/**
	 * sonar优化拆分
	 * 
	 * @author 313353
	 */
	private void sonarSplitFour(ExpressLineEntity line, List<String> result, 
			List<LineItemEntity> lineItemEntityList) {
		if(StringUtils.isNotBlank(line.getCommonAging()+"")){
    		if(StringUtils.isNotBlank(line.getLeaveTime())){
    			String time = line.getLeaveTime();
    			double leaveTime = new Double(time);
    			if(CollectionUtils.isEmpty(lineItemEntityList)){
    				result.add(" ");
    			}else{
    				long a = lineItemEntityList.get(0).getCommonAging();
    				
    				double commonAgingHour = (new Double(a))/NumberConstants.NUMBER_1000;
    				String stringhour = commonAgingHour+"";
    				String[] commonAgingTime = stringhour.split("[.]");
    				String b;
    				String c;
    				double commonAging = new Double(a);
//    				String sfastAging = fastAging+"";
    				if(commonAgingTime.length>1){
    					b = commonAgingTime[0];
    					c = commonAgingTime[1];
    					commonAging = (new Double(b))*NumberConstants.NUMBER_100+(new Double((c+"0000").substring(NumberConstants.STRING_LOCATION_0, NumberConstants.STRING_LOCATION_2)))*NumberConstants.MUTT_06;
    				}else{
    					commonAging = (new Double(commonAgingTime[0]))*NumberConstants.NUMBER_100;
    				}
    				
//    				String scommonAging = commonAging+"";
    				double commonAgTime;
//    				if(scommonAging.length()>5){
//    					commonAgTime = leaveTime+commonAging/10;
//    				}else{
    					commonAgTime = leaveTime+commonAging;
//    				}
    				
    				//double commonAgTime = (leaveTime+commonAging/10);
    				String arriveTimes = commonAgTime%NumberConstants.NUMBER_2400+"";
    				String[] arriveTime = arriveTimes.split("[.]");
    				String arriveHour;
    				if(arriveTime[0].length()==NumberConstants.NUMBER_2){
    					arriveHour="00"+arriveTime[0]+"0";
    				}else if(arriveTime[0].length()==NumberConstants.NUMBER_3){
    					arriveHour="0"+arriveTime[0]+"0";
    				}else if(arriveTime[0].length()==NumberConstants.NUMBER_1){
    					arriveHour="000"+arriveTime[0]+"0";
    				}else{
    					arriveHour=arriveTime[0]+"0";
    				}
    				double arriveDay = commonAgTime/NumberConstants.NUMBER_2400;
    				double min = new Double(arriveHour.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_3));
    				String hour;
    				//判断分数是否超多60
    				if(min>=NumberConstants.NUMBER_6){
    					hour = (new Double(arriveHour)+NumberConstants.NUMBER_400)+"";
    					if((new Double(arriveHour)+NumberConstants.NUMBER_400)>=NumberConstants.NUMBER_24000){
    						arriveDay=+1;
    						hour = (new Double(arriveHour)-NumberConstants.NUMBER_23600)+"";
    					}else{
    						hour = (new Double(arriveHour)+NumberConstants.NUMBER_400)+"";
    					}
    				}else{
    					hour=arriveHour;
    				}
    				String[] hours = hour.split("[.]");
    				String  arrive;
    				String date;
    				if(new Double((hours[0]+"000").substring(NumberConstants.STRING_LOCATION_0, NumberConstants.STRING_LOCATION_2))>NumberConstants.NUMBER_23||new Double((hours[0]+"000").
    						substring(NumberConstants.STRING_LOCATION_2, NumberConstants.STRING_LOCATION_4))>NumberConstants.NUMBER_60||new Double(arriveTimes)<NumberConstants.NUMBER_201){
    					if(new Double(hours[0])<NumberConstants.NUMBER_100){
    						date = "00"+hour;
    					}else if(min>=NumberConstants.NUMBER_6){
    						date = "0"+hour;
    					}else{
    						date = hour;
    					}
    				}else{
    					date=hour.split("[.]")[0];
    				}
    				
    				
    				if(new Double((date+"00000").substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4))>=NumberConstants.NUMBER_60){
    					arrive = ("0"+date+"00").substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+("0"+date+"00000").substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    				}else{
    					arrive = (date+"00").substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+(date+"00000").substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    				}
//    				if(hours.length>1){
//    					arrive = (date+"00").substring(0,2)+":"+(date+"00000").substring(2,4);
//    				}else{
//    					arrive = (hours[0]+"00").substring(0,2)+":00";
//    				}
    				result.add(arrive+"+"+(int)arriveDay+"天");
    			}
    		}else{
    			result.add(" ");
    		}
//    		String time = line.getArriveTime();
//    		String times = time.substring(0,2)+":"+time.substring(2,4);
//    		result.add(times);
    	}else{
    		result.add(" ");
    	}
	}

    /**
     * 
     * <p>导出始发到达线路</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:28:34 AM
     * @param line
     * @return
     * @see
     */
    private List<String> exportSourceTargetLine(ExpressLineEntity line, Map<String, String> transTypeMap){
    	List<String> result = new ArrayList<String>();
    	result.add(line.getLineName());
    	result.add(line.getSimpleCode());
    	result.add(transTypeMap.get(line.getTransType()));
    	result.add(line.getOrginalOrganizationName());
    	result.add(line.getOrginalCityName());
    	result.add(line.getDestinationOrganizationName());
    	result.add(line.getDestinationCityName());
    	result.add(String.valueOf(line.getDistance()));
    	result.add(line.getOrganizationName());
    	result.add(Integer.toString(line.getFrequencyNo()));
    	if(StringUtils.isNotBlank(line.getLeaveTime())){
    		String time = line.getLeaveTime();
    		String times = time.substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+time.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    		result.add(times);
    	}else{
    		result.add(" ");
    	}
    	//求到达时长
    	if(StringUtils.isNotBlank(line.getArriveTime())){
    		String arriveTimes;
    		String leaveTimes; 
    		Calendar arriveTime=Calendar.getInstance();
    		Calendar leaveTime=Calendar.getInstance();
    		arriveTimes = line.getArriveTime();
    		leaveTimes = line.getLeaveTime();
    		String arriveHour = arriveTimes.substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2);
    		String arriveMinute = arriveTimes.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    		String leaveHour = leaveTimes.substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2);
    		String leaveMinute = leaveTimes.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4); 
    		arriveTime.set(NumberConstants.NUMBER_1988, NumberConstants.NUMBER_8, NumberConstants.NUMBER_9+line.getArriveDay(), Integer.valueOf(arriveHour), Integer.valueOf(arriveMinute), 0);
    		leaveTime.set(NumberConstants.NUMBER_1988, NumberConstants.NUMBER_8, NumberConstants.NUMBER_9, Integer.valueOf(leaveHour), Integer.valueOf(leaveMinute), 0);
    		double a = arriveTime.getTimeInMillis()-leaveTime.getTimeInMillis();
//    		long aa= arriveTime.getTimeInMillis();
//    		long aaa = leaveTime.getTimeInMillis();
    		double b = a/NumberConstants.NUMBER_3600000;
    		result.add(b+"");
    	}else{
    		result.add(" ");
    	}
    	//格式为：HH:MM，若不在当天到达，则后缀为“+n天”
    	if(StringUtils.isNotBlank(line.getArriveTime())){
    		String arriveTime;
    		String time = line.getArriveTime();
    		String times = time.substring(NumberConstants.STRING_LOCATION_0,NumberConstants.STRING_LOCATION_2)+":"+time.substring(NumberConstants.STRING_LOCATION_2,NumberConstants.STRING_LOCATION_4);
    		if(StringUtils.isNotBlank(line.getArriveTime())){
    			arriveTime = times +"+"+line.getArriveDay()+"天";
    		}else{
    			arriveTime = times;
    		}
    		result.add(arriveTime);
    	}else{
    		result.add(" ");
    	}
    	//根据工号查询姓名
    	//result.add(line.getModifyUserCode());
    	String modifyUserName;
    	if(StringUtils.isNotBlank(line.getModifyUserCode())){
    		modifyUserName = employeeService.queryEmpNameByEmpCode(line.getModifyUserCode());
    		if(StringUtils.isNotBlank(modifyUserName)){
    			result.add(modifyUserName);
    		}else{
    			result.add(line.getModifyUserCode());
    		}
    	}else{
    		result.add(line.getModifyUserCode());
    	}
    	
    	if(!(line.getModifyTime()==null)){
    		SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");  
    		String modifyTime=sdf.format(line.getModifyTime());  
    		if(StringUtils.equals("2099-12-31",modifyTime)||StringUtils.equals("2999-12-31",modifyTime)){
    			result.add(null); 
    		}else{
    			result.add(modifyTime); 
    		}
    		
    	}else{
    		result.add(" ");
    	}
    	result.add(line.getNotes());
//    	result.add(line.getArriveDeadTime());
    	
    	if(FossConstants.YES.equals(line.getIsDefault())){
    		result.add(QueryingConstant.YES);
    	}else{
    		result.add(QueryingConstant.NO);
    	}
    	return result;
        }
    
    /**
     * 
     * <p>通过中转线路虚拟编码查出该线路途径的外场列表</p> 
     * @author foss-zhujunyong
     * @date Dec 13, 2012 5:08:29 PM
     * @param lineVirtualCode
     * @return
     * @see
     */
    @Override
    public LineStationsDto queryLineStations(String lineVirtualCode) {
	if (StringUtils.isBlank(lineVirtualCode)) {
	    return null;
	}
	ExpressLineEntity line = queryLineByVirtualCode(lineVirtualCode);
	if (line == null) {
	    return null;
	}

	LineStationsDto result = new LineStationsDto();
	result.setLineSimpleCode(line.getSimpleCode());
	Map<String, String> stationMap = new LinkedHashMap<String, String> ();

	// 如果是偏线或者空运
	if (!StringUtils.equals(line.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN)) {
	    stationMap.put(line.getOrginalOrganizationCode(), line.getOrginalOrganizationName());
	    stationMap.put(line.getDestinationOrganizationCode(), line.getDestinationOrganizationName());
	    result.setStationMap(stationMap);
	    return result;
	}

	// 以下为专线情况
	// 取出线段列表
	List<LineItemEntity> itemList = lineItemService.queryLineItemListByLineVirtualCode(lineVirtualCode);
	// 运作线路的专线类型情况线段不可能为空
	if (CollectionUtils.isEmpty(itemList)) {
	    return null;
	}
	// 把线段的出发到达站点放入集合
	for (LineItemEntity item : itemList) {
	    if (!stationMap.containsKey(item.getOrginalOrganizationCode())) {
		stationMap.put(item.getOrginalOrganizationCode(), item.getOrginalOrganizationName());
	    }
	    if (!stationMap.containsKey(item.getDestinationOrganizationCode())) {
		stationMap.put(item.getDestinationOrganizationCode(), item.getDestinationOrganizationName());
	    }
	}
	
	result.setStationMap(stationMap);
	return result;
    }

    /**
     * 
     * 计算在一条线路上指定起点和终点的半截线路的卡车时效和普车时效
     * @author foss-zhujunyong
     * @date Nov 18, 2012 14:13:39 PM
     * @param lineVirtualCode 线路虚拟编码
     * @param sourceCode 出发部门
     * @param targetCode 到达部门
     * @param productCode 第三级产品代码
     * @return
     * @see
     */
    @Override
    public Long calculateAging(String lineVirtualCode,
	    String sourceCode, String targetCode, String productCode) {
	if (StringUtils.isBlank(lineVirtualCode)) {
	    return null;
	}
	ExpressLineEntity line = queryLineByVirtualCode(lineVirtualCode);
	return calculateAging(line, sourceCode, targetCode, productCode);
    }
    
    /**
     * 
     * <p>通过出发部门和到达部门找出最早一班途经班车的发车标准dto</p> 
     * @author foss-zhujunyong
     * @date Dec 28, 2012 3:38:31 PM
     * @param sourceCode
     * @param targetCode
     * @return
     * @see
     */
    @Override
    public DepartureStandardDto queryEarliestDepartureStandard(String sourceCode, String targetCode) {
	if (StringUtils.isBlank(sourceCode) || StringUtils.isBlank(targetCode)) {
	    return null;
	}
	//找到达线路
	ExpressLineEntity targetLineCondition = new ExpressLineEntity();
	targetLineCondition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TARGET);
	targetLineCondition.setOrginalOrganizationCode(sourceCode);
	targetLineCondition.setDestinationOrganizationCode(targetCode);
	targetLineCondition.setActive(FossConstants.ACTIVE);
	List<ExpressLineEntity> lineList = queryLineListByCondition(targetLineCondition);
	
	//找中转线路的线段
	LineItemEntity lineItemCondition = new LineItemEntity();
	lineItemCondition.setOrginalOrganizationCode(sourceCode);
	lineItemCondition.setDestinationOrganizationCode(targetCode);
	lineItemCondition.setActive(FossConstants.ACTIVE);
	List<LineItemEntity> itemList = lineItemService.querySimpleLineItemListByCondition(lineItemCondition);

	//合并上述线路到list中
	if (CollectionUtils.isNotEmpty(itemList)) {
	    for (LineItemEntity item : itemList) {
		ExpressLineEntity line = queryLineByVirtualCode(item.getLineVirtualCode());
		lineList.add(line);
	    }
	}

	//找出所有的头班车,放在standardList中
	List<ExpressDepartureStandardEntity> standardList = new ArrayList<ExpressDepartureStandardEntity>();
	for (ExpressLineEntity line : lineList) {
	    List<ExpressDepartureStandardEntity> standList = line.getStandardList();
	    if (CollectionUtils.isNotEmpty(standList)) {
		for (ExpressDepartureStandardEntity entity : standList) {
		    if (entity != null && StringUtils.isNotBlank(entity.getLeaveTime())) {
			standardList.add(entity);
		    }
		}
	    }
	}
	
	// 取头班车中的最早出发时间，设置一个出发时间列表做比较用
	List<String> leaveTimeList = new ArrayList<String>();
	for (ExpressDepartureStandardEntity standard : standardList) {
	    if (standard != null && StringUtils.isNotBlank(standard.getLeaveTime())) {
		leaveTimeList.add(standard.getLeaveTime());
	    }
	}
	
	if (CollectionUtils.isEmpty(leaveTimeList)) {
	    return null;
	}
	
	Collections.sort(leaveTimeList);
	String early = leaveTimeList.get(0);

	// 取出最早的发车标准
	ExpressDepartureStandardEntity standard = null;
	for (ExpressDepartureStandardEntity stand : standardList) {
	    if (StringUtils.equals(stand.getLeaveTime(), early)) {
		standard = stand;
		break;
	    }
	}
	if (standard == null) {
	    return null;
	}
	
	//算出该线路指定始发和到达那一截的到达时间
	ExpressLineEntity line = queryLineByVirtualCode(standard.getLineVirtualCode());
	FreightRouteLineAgingDto aging = calculateAging(line, sourceCode, targetCode);
	return LineUtils.calculateDepartureStandardBySourceTarget(standard, aging);
    }
    
    /**
     * 
     * <p>使线路生效，需要验证业务规则</p> 
     * @author foss-zhujunyong
     * @date Jan 9, 2013 2:11:17 PM
     * @param virtualCode
     * @param modifyUser
     * @return
     * @see
     */
    @Override
    @Transactional
    public ExpressLineEntity valid(String virtualCode, String modifyUser) {
	ExpressLineEntity line = queryLineByVirtualCode(virtualCode);
	// 如果线路不存在或线路已经是生效状态或不是运作到运作线路，则不作处理
	if (line == null
		|| line.checkValid()
		|| !StringUtils.equals(line.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER)
		|| !StringUtils.equals(line.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN)) {
	    return null;
	}
	
	// 如果已经是生效状态，则不用再更新了
	if (StringUtils.equals(line.getValid(), FossConstants.YES)) {
	    return line;
	}
	
	String lineSource = line.getOrginalOrganizationCode();
	String lineTarget = line.getDestinationOrganizationCode();
	if (StringUtils.equals(lineSource, lineTarget)) {
	    // 线路的出发站和到达站不能相同
	    throw new LineException(LineException.LINESITE_CAN_NOT_DUPLICATION);
	}
	
	List<LineItemEntity> itemList = lineItemService.querySimpleLineItemListByLineVirtualCode(virtualCode);
	if (CollectionUtils.isEmpty(itemList)) {
	    // 运作到运作线路必须添加线段
	    throw new LineException(LineException.LINEITEM_NOT_EXIST_IN_TRANSFER_LINE);
	}
	
	//313353 sonar
	this.sonarSplitFive(itemList, lineTarget, lineSource, line, modifyUser);
	
	/**
	 * 快递线路不同步给GPS zengJunFan
	 */
	//int result = expresslineDao.validLine(line);
	//boolean back;
	/*//	 把有效的线路同步到长途GPS接口
	if (result > 0) {
	    invalidEntity(virtualCode);
	    syncToGps(line, NumberConstants.ZERO);
	}
	// 把有效的线路同步到短途GPS接口
	if (result > 0) {
		invalidEntity(virtualCode);
		back = syncLineInfoToGps(line, NumberConstants.ONE);
	}*/
	
	return enhanceLine(line);
    }
    
	/**
	 * sonar优化拆分
	 * 
	 * @author 313353
	 */
	private void sonarSplitFive(List<LineItemEntity> itemList, String lineTarget,
			String lineSource, ExpressLineEntity line, String modifyUser) {
		int seq = NumberConstants.NUMBER_1;
		String target = null;
		int itemSize = itemList.size();
		for (LineItemEntity entity : itemList) {
		    String itemSource = entity.getOrginalOrganizationCode();
		    String itemTarget = entity.getDestinationOrganizationCode();
		    if (entity.getSequence() == null || StringUtils.isBlank(itemSource) || StringUtils.isBlank(itemTarget)) {
				// 线段的序号,出发站，到达站都不能为空
				throw new LineException(LineException.SOURCE_TARGET_SEQUENCE_CANNOT_BE_EMPTY);
			    }
			    if (StringUtils.equals(itemSource, itemTarget)) {
				// 线段的出发站和到达站不能相同
				throw new LineException(LineException.LINEITEM_SITE_CAN_NOT_DUPLICATION);
			    }
			    if (entity.getSequence() != seq) {
				// 序号不合法，必须从1开始，按顺序递增。
				throw new LineException(LineException.SEQUENCE_MUST_BE_NUMBER);
			    }
			    if (seq == NumberConstants.NUMBER_1 && !StringUtils.equals(itemSource, lineSource)) {
				// 第一条线段的开始节点和线路的开始节点不同
				throw new LineException(LineException.LINEITEM_MUST_BY_ORDER);
			    }
			    if (seq == itemSize && !StringUtils.equals(itemTarget, lineTarget)) {
				// 最后一条线段的结束节点和线路的结束节点不同
				throw new LineException(LineException.LINEITEM_MUST_BY_ORDER);
			    }
			    if (entity.getSequence() != NumberConstants.NUMBER_1 && !StringUtils.equals(target, itemSource)) {
				// 线段必须首尾相接
				throw new LineException(LineException.LINEITEM_MUST_BY_ORDER);
			    }
		    target = itemTarget;
		    seq++;
		}
		line.setValid(FossConstants.YES);
		line.setModifyUser(modifyUser);
	}
    
    /**
     * 
     * <p>使线路失效</p> 
     * @author foss-zhujunyong
     * @date Jan 9, 2013 2:39:35 PM
     * @param virtualCode
     * @param modifyUser
     * @return
     * @see
     */
    @Override
    @Transactional
    public ExpressLineEntity invalid(String virtualCode, String modifyUser) {
	if (StringUtils.isBlank(virtualCode)) {
	    return null;
	}
	
	ExpressLineEntity line = queryLineByVirtualCode(virtualCode);
	if (line == null) {
	    return null;
	}
	// 如果已经是失效状态，则不用再更新了
	if (StringUtils.equals(line.getValid(), FossConstants.NO)) {
	    return line;
	}

	// 检查该线路在走货路径中是否已经引用，若引用则不让失效
	List<FreightRouteLineEntity> list = freightRouteLineDao.queryFreightRouteLineListByLine(virtualCode);
	if (CollectionUtils.isNotEmpty(list)) {
	    for (FreightRouteLineEntity entity : list) {
		FreightRouteEntity freightRoute = freightRouteDao.queryFreightRouteByVirtualCode(entity.getFreightRouteVirtualCode());
		if (freightRoute.checkValid()) {
		    throw new LineException(LineException.USED_BY_FREIGHTROUTE);
		}
	    }
	}
	
	line.setValid(FossConstants.NO);
	line.setModifyUser(modifyUser);
	/**
	 * 快递线路不同步给GPS  zengJunFan
	 */
	//int result = expresslineDao.validLine(line);
	// 把有效的线路同步到GPS接口
	/*if (result > 0) {
	    invalidEntity(virtualCode);
	    syncToGps(line, NumberConstants.NUMBER_1);
	}
	// 把有效的线路同步到短途GPS接口
	if (result > 0) {
	    invalidEntity(virtualCode);
	    syncLineInfoToGps(line, NumberConstants.THREE);
	}*/
	return enhanceLine(line);
    }
    
    /**
     * 
     * <p>查询以指定站点为起点的，所有能到达的所有站点列表</p> 
     * @author foss-zhujunyong
     * @date Jan 18, 2013 11:09:25 AM
     * @param sourceCode
     * @param orgName 模糊查询部门名称
     * @return
     * @see
     */
    @Override
    public Map<String, String> queryTargetSiteForSiteGroup(String sourceCode, String orgName) {
	Map<String, String> result = new LinkedHashMap<String, String> ();
	if (StringUtils.isBlank(sourceCode)) {
	    return result;
	}
	
	ExpressLineEntity c = new ExpressLineEntity();
	c.setOrginalOrganizationCode(sourceCode);
	c.setActive(FossConstants.YES);
	List<ExpressLineEntity> lineList = queryLineListByCondition(c);
	
	LineItemEntity i = new LineItemEntity();
	i.setOrginalOrganizationCode(sourceCode);
	i.setActive(FossConstants.YES);
	List<LineItemEntity> itemList = lineItemService.queryLineItemListByCondition(i);
	
	if (CollectionUtils.isNotEmpty(lineList)) {
	    for (ExpressLineEntity entity : lineList) {
		if (StringUtils.isBlank(orgName) || (StringUtils.isNotBlank(entity.getDestinationOrganizationName()) && entity.getDestinationOrganizationName().contains(orgName))) {
		    result.put(entity.getDestinationOrganizationCode(), entity.getDestinationOrganizationName());
		}
	    }
	}
	if (CollectionUtils.isNotEmpty(itemList)) {
	    for (LineItemEntity entity : itemList) {
		if (StringUtils.isBlank(orgName) || (StringUtils.isNotBlank(entity.getDestinationOrganizationName()) && entity.getDestinationOrganizationName().contains(orgName))) {
		    result.put(entity.getDestinationOrganizationCode(), entity.getDestinationOrganizationName());
		}
	    }
	}
	return result;
    }

    /**
     * 
     * <p>查询以指定站点为终点的，所有能出发的所有站点列表</p> 
     * @author foss-zhujunyong
     * @date Jan 18, 2013 11:09:25 AM
     * @param targetCode
     * @param orgName 模糊查询部门名称
     * @return
     * @see
     */
    @Override
    public Map<String, String> querySourceSiteForSiteGroup(String targetCode, String orgName) {
	Map<String, String> result = new LinkedHashMap<String, String> ();
	if (StringUtils.isBlank(targetCode)) {
	    return result;
	}
	
	ExpressLineEntity c = new ExpressLineEntity();
	c.setDestinationOrganizationCode(targetCode);
	c.setActive(FossConstants.YES);
	List<ExpressLineEntity> lineList = queryLineListByCondition(c);
	
	LineItemEntity i = new LineItemEntity();
	i.setDestinationOrganizationCode(targetCode);
	i.setActive(FossConstants.YES);
	List<LineItemEntity> itemList = lineItemService.queryLineItemListByCondition(i);
	
	if (CollectionUtils.isNotEmpty(lineList)) {
	    for (ExpressLineEntity entity : lineList) {
		if (StringUtils.isBlank(orgName) || (StringUtils.isNotBlank(entity.getOrginalOrganizationName()) && entity.getOrginalOrganizationName().contains(orgName))) {
		    result.put(entity.getOrginalOrganizationCode(), entity.getOrginalOrganizationName());
		}
	    }
	}
	if (CollectionUtils.isNotEmpty(itemList)) {
	    for (LineItemEntity entity : itemList) {
		if (StringUtils.isBlank(orgName) || (StringUtils.isNotBlank(entity.getOrginalOrganizationName()) && entity.getOrginalOrganizationName().contains(orgName))) {
		    result.put(entity.getOrginalOrganizationCode(), entity.getOrginalOrganizationName());
		}
	    }
	}
	return result;
    }

    /**
     * 
     * <p>通过营业部查找默认的到达配载外场编码</p> 
     * @author foss-zhujunyong
     * @date Jan 28, 2013 3:25:56 PM
     * @param saleOrgCode
     * @return
     * @see
     */
    @Override
    public MapDto queryDefaultArriveTransferOrgCode(String saleOrgCode) {
	if (StringUtils.isBlank(saleOrgCode)) {
	    return null;
	}
	// 查找默认到达配置线路
	ExpressLineEntity c = new ExpressLineEntity();
	c.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TARGET);
	c.setActive(FossConstants.ACTIVE);
	c.setDestinationOrganizationCode(saleOrgCode);
	c.setIsDefault(FossConstants.YES);
	List<ExpressLineEntity> list = queryLineListByCondition(c);
	
	if (CollectionUtils.isEmpty(list)) {
	    return null;
	}
	// 找到默认配置部门的编码返回
	for (ExpressLineEntity line : list) {
	    if (line != null) {
		MapDto result = new MapDto();
		result.setCode(line.getOrginalOrganizationCode());
		result.setName(line.getOrginalOrganizationName());
		return result;
	    }
	}
	return null;
    }
    
    /**
     * 
     * <p>通过出发部门查询到达部门列表（运作线路），只查询线路的最终到达部门列表，传入的出发部门可以是线路的起点或中转点</p>
     * 只找专线的 
     * @author foss-zhujunyong
     * @date Apr 10, 2013 10:45:00 AM
     * @param sourceCode
     * @return
     * @see
     */
    @Override
    public List<String> queryArriveOrgListBySource(String sourceCode){
	List<String> result = new ArrayList<String>();
	// 检查参数
	if (StringUtils.isBlank(sourceCode)) {
	    return result;
	}
	// 该map用于把线路表和线段表中找出来的数据做合并去重
	Map<String, ExpressLineEntity> lineMap = new HashMap<String, ExpressLineEntity>();

	// 在线路表中找符合条件的线路列表
	ExpressLineEntity c = new ExpressLineEntity();
	c.setActive(FossConstants.ACTIVE);
	c.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TRANSFER);
	c.setLineType(DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN);
	c.setOrginalOrganizationCode(sourceCode);
	List<ExpressLineEntity> list = querySimpleLineListByCondition(c);
	// 把找到的线路列表放到map中准备去重
	for (ExpressLineEntity ExpressLineEntity : list) {
	    lineMap.put(ExpressLineEntity.getVirtualCode(), ExpressLineEntity);
	}
	// 到线段表中找符合条件的线路虚拟编码列表
	LineItemEntity d = new LineItemEntity();
	d.setActive(FossConstants.ACTIVE);
	d.setOrginalOrganizationCode(sourceCode);
	List<String> lineVirtualCodeList = lineItemService.queryLineVirtualCodeListByCondition(d);
	// 把符合条件的线路虚拟编码列表放到map中并做去重操作
	for (String virtualCode : lineVirtualCodeList) {
	    if (lineMap.get(virtualCode) == null) {
		lineMap.put(virtualCode, querySimpleLineByVirtualCode(virtualCode));
	    }
	}
	// 把map中的记录转换成返回结果要求的到达部门编码并返回
	for (Map.Entry<String, ExpressLineEntity> entry : lineMap.entrySet()) {
	    ExpressLineEntity line = entry.getValue();
	    if (line != null && StringUtils.isNotBlank(line.getDestinationOrganizationCode())) {
		result.add(line.getDestinationOrganizationCode());
	    }
	}
	return result;
    }
    
    /**
     * 
     * <p>在作废一条线路时检查是否有相同起点和终点的线路，如果有，则不用更新网点组，否则需要同步作废相应的网点组信息</p> 
     * 
     * 返回true表明不用更新网点组，返回false表明需要更新网点组
     * 
     * @author foss-zhujunyong
     * @date Jun 26, 2013 3:34:31 PM
     * @see
     */
    private boolean checkSameSourceTargetLineExist(String sourceCode, String targetCode, String lineSort, String virtualCode){
	if (StringUtils.isBlank(sourceCode) || StringUtils.isBlank(targetCode) || StringUtils.isBlank(lineSort)) {
	    return false;
	}
	ExpressLineEntity c = new ExpressLineEntity();
	c.setLineSort(lineSort);
	c.setOrginalOrganizationCode(sourceCode);
	c.setDestinationOrganizationCode(targetCode);
	c.setActive(FossConstants.ACTIVE);
	List<ExpressLineEntity> list = querySimpleLineListByCondition(c);
	if (CollectionUtils.isEmpty(list)) {
	    return false;
	}

	if (StringUtils.isBlank(virtualCode)) {
	    return false;
	}
	// 只要有一条不同的线路存在，就返回true
	for (ExpressLineEntity entity : list) {
	    if (entity != null && !StringUtils.equals(virtualCode, entity.getVirtualCode())) {
		return true;
	    }
	}
	return false;
    }


    /**
     * 
     * <p>将指定key的缓存失效</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:30:58 AM
     * @param key 
     * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#invalidEntity(java.lang.String)
     */
    @SuppressWarnings("unchecked")
    @Override
    public void invalidEntity(String key) {
	((ICache<String, ExpressLineEntity>)CacheManager.getInstance().getCache(FossTTLCache.EXPRESS_LINE_ENTITY_CACHE_UUID)).invalid(key);
    }


    /**
     * 
     * <p>取缓存</p> 
     * @author foss-zhujunyong
     * @date Mar 5, 2013 10:30:44 AM
     * @param key
     * @return
     * @see
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    private ExpressLineEntity queryEntityCache(String key) {
	ExpressLineEntity result = null;
	try {
	    CacheManager cacheManager = CacheManager.getInstance();
	    if (cacheManager == null) {
		return null;
	    }
	    ICache cache = cacheManager.getCache(FossTTLCache.EXPRESS_LINE_ENTITY_CACHE_UUID);
	    if (cache == null) {
		return null;
	    }
	    result = (ExpressLineEntity) cache.get(key);
	} catch (Exception t) {
		t.printStackTrace();
	    log.error("cache找不到", t);
	}
	return result;
    }

    /**
     * 
     * <p>查找指定营业部所能到达的所有始发配置部门</p> 
     * 
     * @author foss-zhujunyong
     * @date Mar 18, 2013 11:12:41 AM
     * @param sourceCode
     * @return
     * @see
     */
    @Override
    public List<String> queryTransferCodeListBySourceCode(String sourceCode) {
	// 初始化返回对象，保证不为null
	List<String> result = new ArrayList<String>();
	// 检查参数
	if (StringUtils.isBlank(sourceCode)) {
	    return result;
	}
	// 查询数据库中所有符合条件的始发配置线路
	ExpressLineEntity c = new ExpressLineEntity();
	c.setOrginalOrganizationCode(sourceCode);
	c.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_SOURCE);
	c.setActive(FossConstants.ACTIVE);
	List<ExpressLineEntity> lineList = querySimpleLineListByCondition(c);
	// 如果该营业部无始发配置线路，则直接返回
	if (CollectionUtils.isEmpty(lineList)) {
	    return result;
	}
	// 将找到的始发配置部门的部门编码放到返回结果中
	for (ExpressLineEntity line : lineList) {
	    result.add(line.getDestinationOrganizationCode());
	}
	return result;
    }
    
    /**
     * 
     * <p>批量重命名</p> 
     * @author foss-zhujunyong
     * @date Jun 13, 2013 10:14:31 AM
     * @param orgCode
     * @param orgName
     * @param modifyUser 
     * @see
     */
    @Transactional
    @Override
    public synchronized void rename(String orgCode, String orgName, String modifyUser) {
	// 检查参数
	if (StringUtils.isBlank(orgCode) || StringUtils.isBlank(orgName)) {
	    return;
	}
	// 找出该部门出发的所有线路
	ExpressLineEntity c1 = new ExpressLineEntity();
	c1.setOrginalOrganizationCode(orgCode);
	c1.setActive(FossConstants.ACTIVE);
	List<ExpressLineEntity> list1 = querySimpleLineListByCondition(c1);
	if (CollectionUtils.isNotEmpty(list1)) {
	    for (ExpressLineEntity entity : list1) {
		String lineName = entity.getLineName();
		if (StringUtils.isBlank(lineName)) {
		    continue;
		}
		String[] s = lineName.split(SymbolConstants.EN_BAR, 2);
		if (ArrayUtils.isEmpty(s)){
		    continue;
		}
		// 名称相同就不用更新了
		if (StringUtils.equals(orgName, s[0])) {
		    continue;
		}
		s[0] = orgName;
		String newLineName = StringUtils.join(s, SymbolConstants.EN_BAR);
		entity.setLineName(newLineName);
		if (StringUtils.isNotBlank(modifyUser)) {
		    entity.setModifyUser(modifyUser);
		}
		ExpressLineEntity result = expresslineDao.updateLine(entity);
		// 清空缓存
		if (result != null) {
		    invalidEntity(result.getVirtualCode());
		    invalidEntity(result.getSimpleCode());
		}
	    }
	}
	
	// 找出该以部门到达的所有线路
	ExpressLineEntity c2 = new ExpressLineEntity();
	c2.setDestinationOrganizationCode(orgCode);
	c2.setActive(FossConstants.ACTIVE);
	List<ExpressLineEntity> list2 = querySimpleLineListByCondition(c2);
	if (CollectionUtils.isNotEmpty(list2)) {
	    for (ExpressLineEntity entity : list2) {
		String lineName = entity.getLineName();
		if (StringUtils.isBlank(lineName)) {
		    continue;
		}
		String[] s = lineName.split(SymbolConstants.EN_BAR, 2);
		if (ArrayUtils.isEmpty(s) || s.length != 2){
		    continue;
		}
		// 名称相同就不用更新了
		if (StringUtils.equals(orgName, s[1])) {
		    continue;
		}
		s[1] = orgName;
		String newLineName = StringUtils.join(s, SymbolConstants.EN_BAR);
		entity.setLineName(newLineName);
		if (StringUtils.isNotBlank(modifyUser)) {
		    entity.setModifyUser(modifyUser);
		}
		ExpressLineEntity result = expresslineDao.updateLine(entity);
		// 清空缓存
		if (result != null) {
		    invalidEntity(result.getVirtualCode());
		    invalidEntity(result.getSimpleCode());
		}
	    }
	}
    }
    
	/**
	 * 根据出发外场和到达快递代理公司编码查询到达线路
	 * 
	 * @author WangPeng
	 * @Date 2013-9-11 下午6:49:56
	 * @param sourceCode
	 * @param targetCode
	 * @param date
	 * @return DepartureStandardDto
	 * 
	 * 
	 */
	public DepartureStandardDto queryDepartureStandardListByLdpAgentDepts(
			String sourceCode, String ldpCompanyCode, Date date) {
		// 判断参数是否合法
		if (StringUtils.isBlank(sourceCode)
				|| StringUtils.isBlank(ldpCompanyCode)
				|| StringUtils.equals(sourceCode, ldpCompanyCode)
				|| date == null) {
			return null;
		}
		// 根据快递代理公司查询其所管辖的快递代理网点编码
		List<OuterBranchExpressEntity> ldpOuterBranchList = ldpAgencyDeptService
				.queryLdpAgencyDeptsByagencyCompanyCode(ldpCompanyCode,
						FossConstants.ACTIVE);
		// 判断是否存在快递代理网点
		if (CollectionUtils.isEmpty(ldpOuterBranchList)) {
			return null;
		}
		// 先按照快递代理公司编码去查询
		ExpressLineEntity conditionCompany = new ExpressLineEntity();
		conditionCompany.setOrginalOrganizationCode(sourceCode);
		conditionCompany.setDestinationOrganizationCode(ldpCompanyCode);
		conditionCompany.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TARGET);
		conditionCompany.setActive(FossConstants.ACTIVE);
		List<ExpressLineEntity> list = querySimpleLineListByCondition(conditionCompany);
		for (ExpressLineEntity line : list) {
			if (null == line) {
				continue;
			}
			return LineUtils.createExpressDepartureStandardDto(line, null);
		}

		// 再按照快递代理网点查询
		for (OuterBranchExpressEntity entity : ldpOuterBranchList) {
			if (null == entity) {
				continue;
			}
			// 在线路表中查找符合的线路
			ExpressLineEntity condition = new ExpressLineEntity();
			condition.setOrginalOrganizationCode(sourceCode);
			condition.setDestinationOrganizationCode(entity.getAgentDeptCode());
			condition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TARGET);
			condition.setActive(FossConstants.ACTIVE);
			List<ExpressLineEntity> lineList = querySimpleLineListByCondition(condition);

			// 如果该快递代理网点找不到符合的线路，跳出当前循环
			if (CollectionUtils.isEmpty(lineList)) {
				continue;
			}
			for (ExpressLineEntity line : lineList) {
				if (null == line) {
					continue;
				}
				return LineUtils.createExpressDepartureStandardDto(line, null);
			}
		}
		// 找不到合适的线路，则返回null
		return null;
	}

	/**
	 * @param ldpAgencyDeptService the ldpAgencyDeptService to set
	 */
	public void setLdpAgencyDeptService(ILdpAgencyDeptService ldpAgencyDeptService) {
		this.ldpAgencyDeptService = ldpAgencyDeptService;
	}
	
	/**
	 * <p>根据始发站、到达站编码查询运作到运作线路（是否不奖线路）</p> 
	 * @author 094463-foss-xieyantao
	 * @date 2013-12-11 上午11:19:07
	 * @param sourceCode 始发站编码
	 * @param targetCode 到达站编码
	 * @return 
	 * @see com.deppon.foss.module.base.baseinfo.api.server.service.ILineService#queryExpressLineEntityByCondition(java.lang.String, java.lang.String)
	 */
	@Override
	public ExpressLineEntity queryExpressLineEntityByCondition(String sourceCode,
		String targetCode) {
	    if (StringUtils.isEmpty(sourceCode)) {
		return null;
	    }
	    if (StringUtils.isEmpty(targetCode)) {
		return null;
	    }
	    // 在线路表中查找符合的线路
	    ExpressLineEntity condition = new ExpressLineEntity();
	    condition.setOrginalOrganizationCode(sourceCode);
	    condition.setDestinationOrganizationCode(targetCode);
	    condition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_TRANSFER);
	    condition.setValid(FossConstants.YES);
	    condition.setActive(FossConstants.ACTIVE);
	    List<ExpressLineEntity> lineList = querySimpleLineListByCondition(condition);
	    
	    if(CollectionUtils.isNotEmpty(lineList)){
		return lineList.get(0);
	    }
	    return null;
	}

	  
    
}
