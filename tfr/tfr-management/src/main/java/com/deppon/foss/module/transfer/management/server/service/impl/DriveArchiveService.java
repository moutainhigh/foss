/**
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 *  initial comments.
 */
/*******************************************************************************
 * Copyright 2013 TFR TEAM
 *  
 *  Licensed under the DEPPON License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  
 *     http://www.deppon.com/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  Contributors:
 *  038300-foss-pengzhen - initial API and implementation
 * 
 *  PROJECT NAME  : tfr-management
 *  
 *  FILE PATH     : src/main/java/com/deppon/foss/module/transfer/management/server/service/impl/DriveArchiveService.java
 *  
 *  FILE NAME          :DriveArchiveService.java
 * 
 *  AUTHOR  : FOSS中转系统开发组
 *  
 *  TIME              : 
 *  
 *  HOME PAGE    :  http://www.deppon.com
 * 
 *  COPYRIGHT    : Copyright (c) 2013  Deppon All Rights Reserved.
 ******************************************************************************/
package com.deppon.foss.module.transfer.management.server.service.impl;

import java.math.BigDecimal;
import java.util.Date;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.time.DateFormatUtils;
import org.springframework.transaction.annotation.Transactional;

import com.deppon.foss.module.base.baseinfo.api.server.service.IExpressLineService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ILineService;
import com.deppon.foss.module.base.baseinfo.api.server.service.complex.IVehicleService;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.ExpressLineEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.LineEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.DepartureStandardDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.VehicleAssociationDto;
import com.deppon.foss.module.frameworkimpl.server.context.FossUserContext;
import com.deppon.foss.module.transfer.common.api.shared.exception.TfrBusinessException;
import com.deppon.foss.module.transfer.management.api.server.dao.IDriveArchiveDao;
import com.deppon.foss.module.transfer.management.api.server.service.IDriveArchiveService;
import com.deppon.foss.module.transfer.management.api.shared.domain.DriveArchiveEntity;
import com.deppon.foss.module.transfer.management.api.shared.dto.DriveArchiveDto;
import com.deppon.foss.module.transfer.management.api.shared.dto.DriveArchiveLineInfoDto;
import com.deppon.foss.module.transfer.management.api.shared.dto.DriveArchiveVehicleInfoDto;
import com.deppon.foss.module.transfer.scheduling.api.shared.util.ConstantsNumberSonar;
import com.deppon.foss.util.DateUtils;
import com.deppon.foss.util.UUIDUtils;

/**
 * 车辆行驶档案相关操作
 * @author foss-liuxue(for IBM)
 * @date 2012-11-8 上午10:51:06
 */
public class DriveArchiveService implements IDriveArchiveService {
	
	/**
	 *  车辆行驶档案dao
	 */
	private IDriveArchiveDao driveArchiveDao;
	
	/**
	 * 查询车辆信息的接口
	 */
	private IVehicleService vehicleService;  
	
	/**
	 * 根据线路去的预计出发时间和到达时间的接口
	 */
	private ILineService lineService;  
	
	private IExpressLineService expresslineService ;
	
	/**
	 * 设置 查询车辆信息的接口.
	 *
	 * @param vehicleService the new 查询车辆信息的接口
	 */
	public void setVehicleService(IVehicleService vehicleService) {
		this.vehicleService = vehicleService;
	}
	
	public void setExpresslineService(IExpressLineService expresslineService) {
		this.expresslineService = expresslineService;
	}

	/**
	 * 设置 车辆行驶档案dao.
	 *
	 * @param driveArchiveDao the new 车辆行驶档案dao
	 */
	public void setDriveArchiveDao(IDriveArchiveDao driveArchiveDao) {
		this.driveArchiveDao = driveArchiveDao;
	}

	/**
	 * 设置 根据线路去的预计出发时间和到达时间的接口.
	 *
	 * @param lineService the new 根据线路去的预计出发时间和到达时间的接口
	 */
	public void setLineService(ILineService lineService) {
		this.lineService = lineService;
	}

	/**
	 * 根据查询条件查询行驶档案
	 * @author LiuXue
	 * @date 2012-10-29 15:55:17
	 */
	@Override
	@Transactional(readOnly = true)
	public List<DriveArchiveEntity> queryDriveArchive(DriveArchiveDto driveArchiveDto,int start,int limit) {
		//根据查询条件查询行驶档案
		return driveArchiveDao.queryDriveArchive(driveArchiveDto,start,limit);
	}

	/**
	 * 获取当前数据库中记录的总条数
	 * @author LiuXue
	 * @date 2012-10-29 15:56:08
	 */
	@Override
	@Transactional(readOnly = true)
	public Long getCount(
			DriveArchiveDto driveArchiveDto) {
		//获取当前数据库中记录的总条数
		return driveArchiveDao.getCount(driveArchiveDto);
	}

	/**
	 * 执行sava/update操作
	 * @author foss-liuxue(for IBM)
	 * @date 2012-10-29 15:53:19
	 */
	@Override
	@Transactional
	public int saveOrUpdate(DriveArchiveDto driveArchiveDto) {
		DriveArchiveEntity driveArchiveEntity = driveArchiveDto.getDriveArchiveEntity();
		//设置实际发车时间
		driveArchiveEntity.setDepartureTime(DateUtils.convert(driveArchiveDto.getDepartureTime()));  
		//设置规定到达时间
		driveArchiveEntity.setArriveTime(DateUtils.convert(driveArchiveDto.getArriveTime()));  
		//设置规定发车时间
		driveArchiveEntity.setStipulateDepartureTime(DateUtils.convert(driveArchiveDto.getStipulateDepartureTime()));  
		//设置实际发车时间
		driveArchiveEntity.setStipulateArriveTime(DateUtils.convert(driveArchiveDto.getStipulateArriveTime()));  
		//如果ID为空，则为新增
		if(StringUtils.isBlank(driveArchiveEntity.getId())){
			//设置ID
			driveArchiveEntity.setId(UUIDUtils.getUUID());
			//制单人名称
			driveArchiveEntity.setArchiveUserName(FossUserContext.getCurrentUser().getEmployee().getEmpName());
			//制单人code
			driveArchiveEntity.setArchiveUserCode(FossUserContext.getCurrentUser().getEmployee().getEmpCode());
			//创建时间
			driveArchiveEntity.setCreateTime(new Date());
			//将ID存入DTO
			driveArchiveDto.setId(driveArchiveEntity.getId());
			//新增行驶档案
			return driveArchiveDao.addDriveArchive(driveArchiveEntity);
		}else{
			driveArchiveDto.setId(driveArchiveEntity.getId());
			//修改行驶档案
			return driveArchiveDao.updateDriveArchive(driveArchiveEntity);
		}
	}

	/**
	 * 删除选中的记录
	 * @author LiuXue
	 * @date 2012-10-29 15:56:14
	 */
	@Override
	@Transactional
	public int deleteByPrimaryKey(String driveArchiveId) {
		//删除选中的记录
		return driveArchiveDao.deleteByPrimaryKey(driveArchiveId);
	}

	/**
	 * 根据ID查询行驶档案
	 * @author LiuXue
	 * @date 2012-10-29 15:56:17
	 */
	@Override
	@Transactional(readOnly = true)
	public DriveArchiveEntity displayDriveArchiveDetail(String id) {
		//根据ID查询行驶档案
		List<DriveArchiveEntity> driveArchiveList = driveArchiveDao.displayDriveArchiveDetail(id);
		//如果没有找到，则抛出异常
		if(null == driveArchiveList || driveArchiveList.size() < 1){
			throw new TfrBusinessException("未找到此条记录，请确认记录是否已经被删除","");
		}
		return driveArchiveList.get(0);
	}

	/**
	 * 根据车牌号获取车辆信息
	 * @author foss-liuxue(for IBM)
	 * @date 2012-12-21 下午4:12:26
	 */
	@Override
	@Transactional(readOnly = true)
	public DriveArchiveEntity queryVehicleInfo(DriveArchiveDto driveArchiveDto) {
		//根据车牌号获取车辆信息
		VehicleAssociationDto vehicleAssociationDto = vehicleService.queryVehicleAssociationDtoByVehicleNo(driveArchiveDto.getVehicleNo());
		//为null则抛出异常
		if(null == vehicleAssociationDto){
			throw new TfrBusinessException("根据当前车牌号没有找到相应车辆信息","");
		}
		//车辆行驶档案实体
		DriveArchiveEntity driveArchiveEntity = new DriveArchiveEntity();
		//小组
		driveArchiveEntity.setGroupCode(vehicleAssociationDto.getVehicleOrganizationCode());  
		//车队
		driveArchiveEntity.setTransDepartment(vehicleAssociationDto.getVehicleMotorcadeCode()); 
		//品牌
		driveArchiveEntity.setVehicleBrand(vehicleAssociationDto.getVehicleBrandName());  
		//车型
		driveArchiveEntity.setVehicleTypeLength(vehicleAssociationDto.getVehicleLengthName());  
		//货柜号
		driveArchiveEntity.setContainerNo(vehicleAssociationDto.getVehicleContainerCode());
		return driveArchiveEntity;
	}
	
	/**
	 * 根据配载号查询车辆信息
	 * @author foss-liuxue(for IBM)
	 * @date 2012-12-29 下午4:19:49
	 */
	@Override
	@Transactional(readOnly = true)
	public DriveArchiveVehicleInfoDto queryVehicleNoByVehicleAssembleNo(DriveArchiveDto driveArchiveDto){
		//根据配载号查询车辆信息
		List<DriveArchiveVehicleInfoDto> driveArchiveVehicleInfoList =  driveArchiveDao.queryVehicleNoByVehicleAssembleNo(driveArchiveDto);
		//为空则抛出异常
		if(driveArchiveVehicleInfoList.size() < 1){
			throw new TfrBusinessException("根据此配载单号未找到相应信息","");
		}
		DriveArchiveVehicleInfoDto driveArchiveVehicleInfoDto = driveArchiveVehicleInfoList.get(0);
		//获取出发时间
		Date departTime = driveArchiveVehicleInfoDto.getActualDepartTime();
		//获取到达时间
		Date arriveTime = driveArchiveVehicleInfoDto.getActualArriveTime();
		//出发时间和打到时间都不为空
		if(null!=departTime && null!=arriveTime){
			Long timeDiff = DateUtils.getMinuteDiff(departTime, arriveTime);
			//计算实际时效
			BigDecimal prescription = BigDecimal.valueOf(timeDiff).divide(BigDecimal.valueOf(ConstantsNumberSonar.SONAR_NUMBER_60), 1, BigDecimal.ROUND_HALF_UP);
			if(prescription.intValue() < 0.1){
				prescription = BigDecimal.valueOf(0.1);
			}
			//设置实际时效
			driveArchiveVehicleInfoDto.setPreion(prescription);
		}
		return driveArchiveVehicleInfoDto;
	}
	
	/**
	 * 根据班次号和线路带出预计发车日期，预计到达日期，标准时效
	 * @author foss-liuxue(for IBM)
	 * @date 2013-1-4 下午3:59:44
	 */
	@Override
	@Transactional(readOnly = true)
	public DriveArchiveLineInfoDto queryLineInfoByLineSequence(DriveArchiveDto driveArchiveDto){
		//班次号
		int frequency = 0;
		try{
			//将前台录入的班次号转换为数字
			frequency = Integer.parseInt(driveArchiveDto.getFrequencyNo());
		}catch(NumberFormatException numberFormatException){
			//失败则抛出异常
			throw new TfrBusinessException("班次号录入格式错误","");
		}
		//根据线路Code找出线路实体对象
		LineEntity lineEntity = lineService.queryLineBySimpleCode(driveArchiveDto.getLineNo());
		//通过线路虚拟编码和班次，查出发车时间和到达时间
		DepartureStandardDto departureStandardDto = lineService.queryDepartureStandardByLineSequence(lineEntity.getVirtualCode(),frequency);
		if(null == departureStandardDto){
			//没有找到则抛出异常
			ExpressLineEntity explineEntity = expresslineService.queryLineBySimpleCode(driveArchiveDto.getLineNo());
			DepartureStandardDto departureStandardDto2 = expresslineService.queryDepartureStandardByLineSequence(explineEntity.getVirtualCode(),frequency);
			if(null == departureStandardDto2){
				throw new TfrBusinessException("根据线路和班次号未找到匹配的信息，请手动录入","");
			}else{
				//modify by wwb at 2016年10月29日08:40:31  下面会用到departureStandardDto，此处抛出异常
				throw new TfrBusinessException("查询出发车时间和到达时间失败","");
			}
		}
		//实例化车辆档案中线路的信息
		DriveArchiveLineInfoDto driveArchiveLineInfoDto = new DriveArchiveLineInfoDto();
		
		//设置目的站
		driveArchiveLineInfoDto.setArriveRegionName(lineEntity.getDestinationOrganizationName());
		
		//设置始发站
		driveArchiveLineInfoDto.setDeptRegionName(lineEntity.getOrginalOrganizationName());
		
	
		//因为没有
		if(StringUtils.isNotBlank(driveArchiveDto.getBaseDate())){
			//获取出发时间
			Date departTime = departureStandardDto.getLeaveDate(DateUtils.convert(driveArchiveDto.getBaseDate(), "yyyy-MM-dd"));
			//获取到达时间
			Date arriveTime = departureStandardDto.getArriveDate(DateUtils.convert(driveArchiveDto.getBaseDate(), "yyyy-MM-dd"));
			
			//出发时间和达到时间都不为空
			if(null!=departTime && null!=arriveTime){
				Long timeDiff = DateUtils.getMinuteDiff(departTime, arriveTime);
				//计算实际时效
				BigDecimal prescription = BigDecimal.valueOf(timeDiff).divide(BigDecimal.valueOf(ConstantsNumberSonar.SONAR_NUMBER_60), 1, BigDecimal.ROUND_HALF_UP);
				if(prescription.intValue() < 0.1){
					prescription = BigDecimal.valueOf(0.1);
				}
				//设置实际时效
				driveArchiveLineInfoDto.setStandardPreion(prescription.toString());
			}
			
			//预计出发时间
			driveArchiveLineInfoDto.setStipulateDepartureTime(DateFormatUtils.format(departTime, "yyyy-MM-dd hh:mm:ss"));
			//预计到达时间
			driveArchiveLineInfoDto.setStipulateArriveTime(DateFormatUtils.format(arriveTime, "yyyy-MM-dd hh:mm:ss"));
		}
		
		return driveArchiveLineInfoDto;
	}

}