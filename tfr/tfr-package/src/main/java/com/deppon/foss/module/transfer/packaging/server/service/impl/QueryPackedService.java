/**
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 *  initial comments.
 */
/*******************************************************************************
 * Copyright 2013 TFR TEAM
 *  
 *  Licensed under the DEPPON License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  
 *     http://www.deppon.com/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  Contributors:
 *  038300-foss-pengzhen - initial API and implementation
 * 
 *  PROJECT NAME  : tfr-package
 *  
 *  FILE PATH     : src/main/java/com/deppon/foss/module/transfer/packaging/server/service/impl/QueryPackedService.java
 *  
 *  FILE NAME          :QueryPackedService.java
 * 
 *  AUTHOR  : FOSS中转系统开发组
 *  
 *  TIME              : 
 *  
 *  HOME PAGE    :  http://www.deppon.com
 * 
 *  COPYRIGHT    : Copyright (c) 2013  Deppon All Rights Reserved.
 ******************************************************************************/
/*
 * PROJECT NAME: tfr-package
 * PACKAGE NAME: com.deppon.foss.module.transfer.packaging.server.service.impl
 * FILE    NAME: QueryPackedService.java
 * COPYRIGHT: Copyright(c) 2012 Deppon All Rights Reserved.
 */
package com.deppon.foss.module.transfer.packaging.server.service.impl;

import java.io.InputStream;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.springframework.transaction.annotation.Transactional;

import com.deppon.foss.base.util.define.BizTypeConstants;
import com.deppon.foss.framework.exception.BusinessException;
import com.deppon.foss.framework.server.components.export.excel.ExcelExport;
import com.deppon.foss.framework.server.components.export.excel.SheetData;
import com.deppon.foss.module.base.baseinfo.api.server.service.IGoodsAreaService;
import com.deppon.foss.module.base.baseinfo.api.server.service.complex.IOrgAdministrativeInfoComplexService;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.EmployeeEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.GoodsAreaEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.OrgAdministrativeInfoEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.UserEntity;
import com.deppon.foss.module.base.dict.api.server.service.IConfigurationParamsService;
import com.deppon.foss.module.base.dict.api.server.service.IDataDictionaryValueService;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryConstants;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryValueConstants;
import com.deppon.foss.module.base.dict.api.shared.domain.ConfigurationParamsEntity;
import com.deppon.foss.module.base.dict.api.shared.domain.DataDictionaryValueEntity;
import com.deppon.foss.module.frameworkimpl.server.context.FossUserContext;
import com.deppon.foss.module.frameworkimpl.shared.domain.CurrentInfo;
import com.deppon.foss.module.pickup.waybill.api.server.service.ILabelPrintInfoService;
import com.deppon.foss.module.pickup.waybill.api.server.service.ILabeledGoodService;
import com.deppon.foss.module.pickup.waybill.api.server.service.IWaybillManagerService;
import com.deppon.foss.module.pickup.waybill.api.server.service.IWaybillPackBIService;
import com.deppon.foss.module.pickup.waybill.shared.define.WaybillConstants;
import com.deppon.foss.module.pickup.waybill.shared.domain.WaybillEntity;
import com.deppon.foss.module.pickup.waybill.shared.dto.BarcodePrintLabelDto;
import com.deppon.foss.module.pickup.waybill.shared.dto.LabeledGoodDto;
import com.deppon.foss.module.pickup.waybill.shared.dto.NeedCreateTodoDto;
import com.deppon.foss.module.pickup.waybill.shared.dto.ResultDto;
import com.deppon.foss.module.transfer.common.api.shared.exception.TfrBusinessException;
import com.deppon.foss.module.transfer.exceptiongoods.api.server.service.IPrintLabelService;
import com.deppon.foss.module.transfer.exceptiongoods.api.shared.domain.PrintLabelEntity;
import com.deppon.foss.module.transfer.packaging.api.server.dao.IPackOutDao;
import com.deppon.foss.module.transfer.packaging.api.server.dao.IQueryPackedDao;
import com.deppon.foss.module.transfer.packaging.api.server.service.IPackCommonService;
import com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService;
import com.deppon.foss.module.transfer.packaging.api.shared.define.PackagingConstants;
import com.deppon.foss.module.transfer.packaging.api.shared.define.PackagingConstants.packing;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.PackagingRequireDetailsEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.PackagingRequireEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.PackedPersonEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.QueryPackedConditionEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.QueryPackedResultEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.QueryWaybillPackEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.SerialRelationEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.domain.WaybillPackEntity;
import com.deppon.foss.module.transfer.packaging.api.shared.dto.CurrentDeptDto;
import com.deppon.foss.module.transfer.packaging.api.shared.dto.QueryPackedDto;
import com.deppon.foss.module.transfer.packaging.api.shared.exception.PackagingException;
import com.deppon.foss.module.transfer.pda.api.shared.dto.SerialNoAreaDto;
import com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService;
import com.deppon.foss.module.transfer.stock.api.define.StockConstants;
import com.deppon.foss.module.transfer.stock.api.server.service.IStockService;
import com.deppon.foss.module.transfer.stock.api.shared.domain.InOutStockEntity;
import com.deppon.foss.util.UUIDUtils;
import com.deppon.foss.util.define.FossConstants;

/**
 * 该类为包装录入、查询和修改的service层
 * 
 * SUC-30查询并修改外场代包装货物
 *  步骤1、	打开包装信息查询界面，
 *  
 *  		输入【查询包装信息条件】，点击查询按钮。
 *  
 *		           显示【查询包装信息显示列表】。
 *		           
 *	步骤2、	外场人员已查询出包装信息，此时点击查看按钮。
 *	
 *			点击编辑按钮，进入修改状态；
 *			
 *			选中原流水号，点击合并按钮，可生产新的流水号
 *			
 *			选中新流水号码，点击撤销按钮，可撤销此前产生新流水号的操作
 *			
 *			点击添加，则包装人员列表新增一行，此时可以输入工号或姓名；
 *			
 *			点击包装人员行信息的删除按钮，删除此行包装人员信息；
 *			
 *			修改完成后，点击保存按钮，保存修改后的数据。
 *			
 *	步骤3、	外场人员已查询出包装信息，此时点击打印新标签按钮。
 *	
 *			选择一个或多个流水号，点击确定按钮；
 *			
 *	步骤4、 	外场人员在查询包装信息界面点击添加包装信息按钮。
 *	
 *			输入运单号；
 *			
 *			输入其他信息，流水号的合并和撤销已经人员的添加和删除见包装修改功能；
 *			
 *			点击保存；
 *			
 *	步骤5、	点击查询包装信息的重置按钮，重置查询条件为默认值；
 *	
 *			鼠标放在合并后运单流水号时；
 *			
 *			编辑状态下，如果没选中原流水号，点击合并按钮，则提示：“请选择原流水号码”；
 *			
 *			编辑状态下，如果没选中新流水号，点击撤销按钮，则提示：“请选择新流水号码”；
 *			
 *			点击修改包装信息的重置按钮，重置修改前状态；
 *			
 *			点击取消编辑按钮，变为查看状态；
 *
 * 业务规则    打开查询界面：
 *			1、	查询条件中的包装时间的终止时间默认为当前时间，
 * 			
 *				起始时间默认为当前时间前48小时，可以修改，
 *				
 *				时间间隔不超过2天，不能为空；
 *				
 *			2、	包装部门为当前登录人所在部门，不能为空，不可修改；
 *			
 *			3、	运单号默认为空，开单部门默认为空；
 *			
 *			4、	包装人员只能输入一个人的工号或姓名；
 *			
 *			5、	默认不执行查询操作；
 *			
 *			6、	当运单号不为空时，忽略开单部门和包装时间查询条件，包装部门不可忽略；
 *			
 *			7、	列表显示规则默认按包装时间降序排列；
 *			
 *			8、	当前运单只要只要一件货还在包装库区库存中则是否在包装库区字段显示是，否则显示否；
 *			
 *			9、	打开界面时，原流水号明细显示流水号有：
 *			
 *				a、需要代打包装且未包装的流水号，
 *				
 *				b、需要代打包装且已包装且在本部门包装的流水号，
 *				
 *				c、在到达本部门之前合并生成的新流水号；
 *				
 *				默认所有流水号都未勾选，如果有原流水号明细在本外场此前有合并，则流水号不可编辑；
 *				
 *				以上显示规则重在对于二次包装的考虑，
 *				
 *				二次包装的重点在于如何在原流水号中显示需要二次包装的流水号，
 *				
 *				递增规则可采用一次包装时相同的递增规则；
 *				
 *			10、	打开界面时，新流水号明细为所有在本部门合并后的流水号，
 *	 		
 *				且都未选中，都可以编辑；
 *				
 *			11、	对于撤销操作，只能选中且只能选择一个新流水号进行操作，
 *			
 *				撤销后，新流水号从新流水号明细中删除，
 *				
 *				产生该新流水号的原流水号变为可编辑状态，
 *				
 *				同时包装状态为未包装，即可再次合并，如果之前是单个流水号合并的操作，
 *				
 *				则将该流号码移至原流水号明细中，并从新流水号明细中删除此流水号，
 *				
 *				保证运单中流水号码唯一性，同时状态变为未包装；
 *				
 *			13、	对于合并操作，如果选中流水号的原流水号超过一个，
 *			
 *				合并后，在新流水号明细中产生新流水号，规则为在最大流水号基础上递增，
 *	 			
 *				不可重复，原流水号变为不可编辑状态，同时标记为已包装；
 *				
 *				如果选中流水号的原流水号等于一个，
 *				
 *				合并后，将原流水号码从原流水号明细中移至新流水号明细，
 *				
 *				即原流水号明细中无此流水号码，同时标记为已包装；
 *				
 *			14、	以上规则旨在说明：
 *			
 *				1、原流水号和新流水号不存在重复流水号；
 *				
 *				2、对于已经做过合并的流水号，状态变为已包装
 *				
 *			15、	修改保存后，记录原流水号和新流水号之间的关系，
 *			
 *				对于单个合并的流水号，记录自身关系，
 *				
 *				便于在综合查询中显示两者之间的关系；
 *				
 *			16、	保存后，新流水号入当前部门库存中，
 *			
 *				记录新流水号库存和原库存之间的关系，
 *				
 *				便于在综合查询中显示两者之间的关系，
 *				
 *				同时根据当前运单最新流水号数据，得到最新运单件数，
 *				
 *				如果该件数不等于开单件数，则调用接送货接口，修改运单开单件数；
 *				
 *			17、	包装人员列表不能为空；
 *
 * 
 * @author 046130-foss-xuduowei
 * @date 2012-10-17 上午8:15:10
 */
public class QueryPackedService implements IQueryPackedService {
	
	
	/**
	 * PDA与PC端公共service
	 * */
	private IPackCommonService packCommonService;
	/**
	 * 接送货修改运单件数接口
	 */
	private IWaybillManagerService waybillManagerService;
	/**
	 * 接送货新增、修改流水号接口
	 */
	private ILabeledGoodService labeledGoodService;
	/**
	 * 库存接口
	 */
	private IStockService stockService;
	/**
	 * DAO层接口
	 */
	private IQueryPackedDao queryPackedDao;
	/**
	 * DAO层接口
	 */
	private IPackOutDao packOutDao;
	/**
	 * 综合货区接口
	 */
	private IGoodsAreaService goodsAreaService;
	/**
	 * 获取标签打印信息接口
	 */
	private ILabelPrintInfoService labelPrintInfoService;
	/**
	 * 走货路径接口
	 */
	private ICalculateTransportPathService calculateTransportPathService;
	/**
	 * 获取指定部门接口
	 */
	private IOrgAdministrativeInfoComplexService orgAdministrativeInfoComplexService;
	/**
	 * 数据字典
	 */
	private IDataDictionaryValueService dataDictionaryValueService;
	/**
	 * 
	 */
	private IPrintLabelService printLabelService;
	
	/**
	 * 获取配置参数
	 */
	private IConfigurationParamsService configurationParamsService;

	/**
	 * 
	 */
	private static Logger LOGGER = LogManager.getLogger(QueryPackedService.class);
	
	/**
	 * 默认流水号按1递增
	 */
	private int interval = 1;
	/**
	 * 
	 */
	
   //配合BI修改运单件数后续调接送接口修改modifytime
    private IWaybillPackBIService waybillPackBIService;
	
	final static int[] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
			99999999, 999999999, Integer.MAX_VALUE };

	/**
	 * 
	 * 获得数字的位数
	 * 
	 * @param x
	 *            输入的数字
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-19 下午5:36:09
	 */
	static int sizeOfInt(int x) {
		for (int i = 0;; i++) {
			if (x <= sizeTable[i]) {
				return i + 1;
			}
		}
	}
	
	/**
	 * 获取 打包装的时候需要获取的
	 * @param packedDept 当前部门
	 * @return
	 */
	private Double goodsPackingVolume(String packedDept){
		if(StringUtils.isBlank(packedDept)){
			return null;
		}
		//获取配置参数
				Double packageVolume = null;
				try {
					ConfigurationParamsEntity entity = configurationParamsService
							.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__PKP,
									WaybillConstants.GOODS_PACKING_VOLUME, packedDept.trim());

					if (null == entity) {
						packageVolume = Double.valueOf(1);
					} else {
						packageVolume = Double.valueOf(entity.getConfValue());
					}
				} catch (Exception e) {
					packageVolume = Double.valueOf(1);
				}
				return packageVolume;
	}

	/**
	 * 
	 * 
	 * 查询包装录入信息列表的service层的方法，其中涉及到对查询条件的规则判断
	 * 
	 * @param queryPackedConditionEntity
	 *            查询条件
	 * @param limit
	 *            每页限制个数
	 * @param start
	 *            每页开始数
	 * @return List<QueryPackedResultEntity> 已包装信息列表
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-19 上午8:17:21
	 * @see com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService#queryPackedAll(com.deppon.foss.module.transfer.packaging.api.shared.domain.QueryPackedConditionEntity,
	 *      int, int)     
	 *      
	 */
	@Override
	public List<QueryPackedResultEntity> queryPackedAll(
			QueryPackedConditionEntity queryPackedConditionEntity, int limit,
			int start) {
		// 获取处理后的查询条件
		QueryPackedConditionEntity newQueryPackedConditionEntity = obtainQueryPackedCondition(queryPackedConditionEntity);
		// 得到查询结果
		List<QueryPackedResultEntity> queryPackedResultList = queryPackedDao
				.queryPackedAll(newQueryPackedConditionEntity, limit, start);

		return queryPackedResultList;
	}

	/**
	 *
	 * 前端包装录入的时候，
	 * 输入运单号得到包装录入主信息，
	 * 主信息也有可能不存在（还未录入） 取的当前运单的需要包装流水号和已生成新流水号之间的关系
	 * 同时进行整合，
	 * 新流水单独放在一个list中，
	 * 作为在前台显示 新旧流水号放在另一个list中，
	 * 在前台隐藏显示
	 *
	 * 包装录入主信息，
	 * 新旧流水号关系，
	 * 最大流水号，
	 * 包装人员，
	 * 新流水号
     * @param waybillno -> 运单号
     * @param packageType -> 包装类型
     * @return Map<String, Object>
	 * @author 046130-foss-xuduowei
	 * @update-author 134019-foss-yuyongxiang
	 * @date 2012-10-20 上午9:41:27
	 * @see com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService#queryWaybillPack(java.lang.String,java.lang.String)
	 */
	@Override
	public QueryPackedDto queryWaybillPack(String waybillno,String packageType) {
		
		String unPackageType="";
		
		if(!packing.MAKE_WOODEN_STOCK.getValue().equals(packageType)){
			packageType =packing.WOODEN_FRAME.getValue();
			unPackageType=packing.MAKE_WOODEN_STOCK.getValue();
		}else{
			packageType =packing.MAKE_WOODEN_STOCK.getValue();
			unPackageType=packing.WOODEN_FRAME.getValue();
		}
		
		// 封装所有查询结果的dto
		QueryPackedDto qpDto = new QueryPackedDto();
		// 查询包装录入表，判断输入的运单号是否已包装
		List<WaybillPackEntity> waybillPackList = queryPackedDao
				.queryWaybillPack(waybillno,packageType);

		/**
		 * 
		 * 1、货物包装录入主信息或需要包装信息以及包装人员
		 * 
		 */
		//新增是会调用此段逻辑
		if (waybillPackList == null || waybillPackList.isEmpty()) {
			/**
			 * 此处需要再次查询包装需求表
			 */
			waybillPackList = queryPackedDao.queryUnWaybillPack(waybillno);
			if (waybillPackList == null || waybillPackList.isEmpty()) {
				throw new PackagingException("不存在此运单的包装需求");
			}
			WaybillPackEntity waybillPackEntity = (WaybillPackEntity) waybillPackList
					.get(0);
			//获取配置参数
			Double packageVolume = this.goodsPackingVolume(waybillPackEntity.getOrgCode());
			
			//获取未乘以1.4倍系数到体积
			if(null != waybillPackEntity.getUnPackedVolume()){
				BigDecimal packageVolumeTemp= new BigDecimal(waybillPackEntity.getUnPackedVolume().doubleValue()/packageVolume);
				waybillPackEntity.setUnPackedVolumeCreate(packageVolumeTemp.setScale(PackagingConstants.SONAR_NUMBER_3, RoundingMode.HALF_DOWN));
			}
			// 将ID设置为空，避免新增时误认为是修改
			waybillPackEntity.setId(null);
			// 设置包装录入主信息
			qpDto.setWaybillPackEntity(waybillPackEntity);
			// 设置包装人员
			qpDto.setPackedPersonList(null);
			
		} else {      //修改是会调用下面逻辑
			
			// 生成包装录入主信息
			WaybillPackEntity waybillPackEntity = (WaybillPackEntity) waybillPackList
					.get(0);
			
			//获取配置参数
			Double packageVolume = this.goodsPackingVolume(waybillPackEntity.getOrgCode());
			
			//获取未乘以1.4倍系数到体积
			if(null != waybillPackEntity.getUnPackedVolume()){
				BigDecimal packageVolumeTemp= new BigDecimal(waybillPackEntity.getUnPackedVolume().doubleValue()/packageVolume);
				waybillPackEntity.setUnPackedVolumeCreate(packageVolumeTemp.setScale(PackagingConstants.SONAR_NUMBER_3, RoundingMode.HALF_DOWN));
			}
			
			// 加入到list
			// 设置未包装录入信息
			qpDto.setWaybillPackEntity(waybillPackEntity);

			/**
			 * 当在包装录入表中找到该运单时，
			 * 需要查询包装人员信息，
			 * 并增加包装信息列表到list
			 */
			String id = waybillPackEntity.getId();
			// 设置包装人员信息
			qpDto.setPackedPersonList(queryPackedDao.queryPackedPerson(id));
		}
		/**
		 * 2、 获取流水号及相关信息
		 */
		List<SerialRelationEntity> serialRelationList;
		//根据运单号获取新旧流水号关系
		
		serialRelationList = queryPackedDao.querySerialRelation(waybillno,packageType);
		
		//如果上面的查询数据为空则判定无当前的类型的包装需求
		if(null == serialRelationList || serialRelationList.isEmpty()){
			serialRelationList = queryPackedDao.querySerialRelation(waybillno,unPackageType);
			qpDto.getWaybillPackEntity().setPackedMate(unPackageType);
            qpDto.getWaybillPackEntity().setMsg("此运单没有打"+packing.getName(packageType)+"包装需求!");
		}
		
		//如果还是没有包装明细流水号
		if(null == serialRelationList || serialRelationList.isEmpty()){
			throw new PackagingException("不存在此运单的包装需求明细");
		}

		//流水号set
		//用于对新流水号去重
		Set<String> serialRelationSet = new HashSet<String>();
		// 遍历查询结果集
		for (int i = 0; i < serialRelationList.size(); i++) {
			//获取流水号关系实体对象
			SerialRelationEntity serialRelationEntity = (SerialRelationEntity) serialRelationList
					.get(i);
			//新流水号
			String newSerialNo = serialRelationEntity.getNewSerialNo();
			//判断新流水号是否为空
			//最好使用isEmpty 可对null，""," "返回false
			if (!StringUtils.isEmpty(newSerialNo)) {
				//将新流水号加入到集合中
				serialRelationSet.add(serialRelationEntity.getNewSerialNo());
			}
		}
		// 设置新旧流水号关系
		qpDto.setSerialRelationList(serialRelationList);
		//迭代器
		Iterator<String> iterator = serialRelationSet.iterator();
		//新流水号集合
		List<SerialRelationEntity> newSerialRelationList = new ArrayList<SerialRelationEntity>();
		while (iterator.hasNext()) {
			//新增新旧流水号关系对象
			SerialRelationEntity serialRelationEntity = new SerialRelationEntity();
			//设置新流水号
			serialRelationEntity.setNewSerialNo(iterator.next().toString());
			//加入到集合中
			newSerialRelationList.add(serialRelationEntity);
		}
		// 设置新流水号
		qpDto.setNewSerialRelationList(newSerialRelationList);

		/**
		 * 3、 获取最大流水号
		 */
		// 增加最大流水号到list
		String maxSerialNo;
		try {
			//获取最大流水号
			maxSerialNo = queryPackedDao.queryMaxSerialNo(waybillno);
		} catch (NullPointerException e) {
			throw new PackagingException("未查询到流水号数据");
		}
		// 设置最大流水号
		qpDto.setMaxSerialNo(obtainMaxSerialNo(maxSerialNo, interval));
		//返回至ACTION
		return qpDto;
	}

	/**
	 * 在最大流水号上加1
	 * 
	 * @param serialNo
	 *            流水号
	 * @param interval
	 *            递增公差
	 * @return 最大流水号值
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-19 下午5:35:00
	 */
	@Override
	public String obtainMaxSerialNo(String serialNo, int interval) {
		//流水号数字
				int serialNum;
				try {
					serialNum = Integer.parseInt(serialNo) + interval;
					//强转至int
					int num = sizeOfInt(serialNum);
					//生成字符串
					String newSerialNum = serialNum + "";
					// 根据流水号长度确定在数值前加0的个数，流水号长度为常量
					for (; num < PackagingConstants.SERIAL_LENGTH; num++) {
						newSerialNum = "0" + newSerialNum;
					}
					//返回新流水号
					return newSerialNum;
				} catch (NumberFormatException e) {
					//数字格式异常
					throw new NumberFormatException();
				}

	}

	/**
	 * 录入包装信息，根据前台数据结构，
	 * 分为包装录入主信息，
	 * 新旧流水号关系信息，
	 * 包装人员信息，
	 * 并加事务控制
	 * 
	 * @param waybillPackEntity
	 *            包装录入主信息列表
	 * @param serialRelationList
	 *            新旧流水号关系列表
	 * @param newSerialList
	 *            新流水号列表
	 * @param packedPersonList
	 *            包装人列表
	 * @return 0或1
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-20 下午2:29:45
	 * @see com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService#addPackageInfo(
     * com.deppon.foss.module.transfer.packaging.api.shared.domain.WaybillPackEntity,
	 *      java.util.List, java.util.List)
	 *
	 */
	@Transactional
	@Override
	public int addPackageInfo(WaybillPackEntity waybillPackEntity,
			List<SerialRelationEntity> serialRelationList,
			List<SerialRelationEntity> newSerialList,
			List<PackedPersonEntity> packedPersonList) {
		
		
		//获取包装材料--->根据包装材料获取包装类型
		if(packing.MAKE_WOODEN_STOCK.getValue().equals(waybillPackEntity.getPackedMate())){
			waybillPackEntity.setPackageType(packing.MAKE_WOODEN_STOCK.getValue());
			waybillPackEntity.setUnPackageType(packing.WOODEN_FRAME.getValue());
		}else{
			waybillPackEntity.setPackageType(packing.WOODEN_FRAME.getValue());
			waybillPackEntity.setUnPackageType(packing.MAKE_WOODEN_STOCK.getValue());
		}
		
		// 用户
		UserEntity user = FossUserContext.getCurrentUser();
		// 职员
		EmployeeEntity employee = user.getEmployee();

		// 当前操作部门
		List<String> bizTypes = new ArrayList<String>();
		// 设置外场类型
		bizTypes.add(BizTypeConstants.ORG_TRANSFER_CENTER);
		OrgAdministrativeInfoEntity activeDeptInfo = FossUserContext
				.getCurrentDept();
		//组织对象
		OrgAdministrativeInfoEntity org = orgAdministrativeInfoComplexService
				.queryOrgAdministrativeInfoByCode(activeDeptInfo.getCode(),
						bizTypes);
		if (org == null) {
			throw new PackagingException("当前登录人无操作部门");
		} else {
			// 无操作
		}
		// 是否修改
		boolean isUpdate = false;
        //包装主信息id
        String id = waybillPackEntity.getId();


       //原始开单件数
      //根据运单号查询运单基本信息
  		WaybillEntity waybillEntity=waybillManagerService.queryWaybillBasicByNo(waybillPackEntity.getWayBillNumber());
  		if(waybillEntity==null)
  		{
  			throw new TfrBusinessException("运单不存在");
  		}
      
  		
		/**
		 * 此处需要再次查询包装需求表进行校验
		 */
		List<WaybillPackEntity> waybillList = queryPackedDao.queryUnWaybillPack(waybillPackEntity.getWayBillNumber());
		if (waybillList == null || waybillList.isEmpty()) {
			throw new PackagingException("不存在此运单的包装需求");
		}
		waybillPackEntity.setBillTime(waybillList.get(0).getBillTime());
		
		/**
		 * 1、为包装录入主信息设值,
		 * 并判断是新增还是修改
		 */
		// 新增
        List<WaybillPackEntity> waybillPackList = queryPackedDao
                .queryWaybillPack(waybillPackEntity.getWayBillNumber(),waybillPackEntity.getPackageType());

        ////判断输入的运单号是否已录入
        if(CollectionUtils.isNotEmpty(waybillPackList) && StringUtils.isEmpty(id)){
            throw new PackagingException("该运单号已录入，请重新查询后修改");
        }else if(CollectionUtils.isNotEmpty(waybillPackList) && StringUtils.isNotBlank(id)){
            //这个地方是防止在PDA先打木托在由FOSS打木架产生不一致数据
            id = waybillPackList.get(0).getId();
        }

		if (StringUtils.isEmpty(id)) {
			// 查询包装录入表，
			if (waybillPackList == null || waybillPackList.isEmpty()) {
				// id
				waybillPackEntity.setId(UUIDUtils.getUUID());
				// 创建时间
				waybillPackEntity.setCreateDate(new Date());
				// 创建人
				waybillPackEntity.setCreateUser(employee.getEmpCode());
				// 修改时间
				waybillPackEntity.setModifyDate(new Date());
				// 修改人
				waybillPackEntity.setModifyUser(employee.getEmpCode());
				//PDA
				waybillPackEntity.setIsPDA(FossConstants.NO);
				// 部门编码
				waybillPackEntity.setOrgCode(org.getCode());
				// 创建人姓名
				waybillPackEntity.setCreateUserName(employee.getEmpName());
				// 修改人姓名
				waybillPackEntity.setModifyUserName(employee.getEmpName());
				// 部门名称
				waybillPackEntity.setOrgName(org.getName());
				
				//调用DAO，执行包装录入
				try {
					queryPackedDao.insertWaybillPackEntity(waybillPackEntity);
				} catch (Exception e) {
					throw new PackagingException("录入失败，请稍后再试");
				}

            } else {
                throw new PackagingException("该运单号已录入，请重新查询后修改");
			}
			// 修改
		} else {
			//设置修改日期
			waybillPackEntity.setModifyDate(new Date());
			//修改人工号
			waybillPackEntity.setModifyUser(employee.getEmpCode());
			//修改人姓名
			waybillPackEntity.setModifyUserName(employee.getEmpName());
			//更新标志
			isUpdate = true;
			//成功个数
			if (queryPackedDao.updatePDAWaybillPackEntity(waybillPackEntity) == 0) {
				//由于增加了乐观锁，
				//修改失败的抛出异常，
				//前台可做重新录入操作
				throw new PackagingException("修改失败，请重新查询后修改");
			}
		}
		// 获取成功更新后的id和运单号
		String packedId = waybillPackEntity.getId();
		//运单号
		String waybillNo = waybillPackEntity.getWayBillNumber();
		// 2 调用DAO接口，进行新旧流水号关系的处理操作
		updateSerialRelation(serialRelationList, newSerialList, packedId,
				waybillNo,waybillPackEntity);

		// 3 调用DAO接口，进行包装人员信息录入
		updatePackedPerson(packedPersonList, packedId, isUpdate);
		/*
		*@desc 判断是否生成代办
		*@author foss-105795-wqh
		*@date 2014-04-15
		*/
		unpackByAllBringTodo(serialRelationList,waybillNo,waybillPackEntity.getUnPackageType(),waybillEntity);
		return FossConstants.SUCCESS;
	}
	
	
	/**
	 * 还原
	 * 删除实际包装记录
	 * 
	 * @param waybillno
	 * @param packageType
	 */
	@Transactional
	@Override
	public int deleteWaybillPack(String waybillno,String packageType){
		 String unPackageType = null;
		 if(packing.MAKE_WOODEN_STOCK.getValue().equals(packageType)){
			 unPackageType = packing.WOODEN_FRAME.getValue();
		 }else if(packing.WOODEN_FRAME.getValue().equals(packageType)){
			 unPackageType= packing.MAKE_WOODEN_STOCK.getValue();
		 }else if(StringUtils.isBlank(packageType)){
			 throw new PackagingException("还原失败!请勿随意修改界面属性"); 
		 }
		//
		//QueryPackedDto unQpd = queryWaybillPack(waybillno,packageType);
		QueryPackedDto qpd = queryWaybillPack(waybillno,unPackageType);
		 //新流水号列表
		 //List<SerialRelationEntity> newSerialRelationEntityList=qpd.getNewSerialRelationList();
		 List<SerialRelationEntity> serialRelationEntityList=qpd.getSerialRelationList();
		
		 // 查询新流水号对应的
		 /*List<SerialRelationEntity> serialRelationListTemp = queryPackedDao.querySerialRelation(waybillno,unPackageType);
		 for(SerialRelationEntity newSerial : newSerialRelationEntityList)
		 for(SerialRelationEntity sre : serialRelationListTemp){
			 if(StringUtils.equals(sre.getOldSerialNo(),newSerial.getNewSerialNo()) && "Y".equals(sre.getIsPacked())){
				 LOGGER.error("新流水号: "+sre.getOldSerialNo()+" 已经被打"+packing.getName(unPackageType)+",不能还原,请先解除"+sre.getOldSerialNo()+"的"+packing.getName(qpd.getWaybillPackEntity().getUnPackageType())+"包装");
				 throw new PackagingException("新流水号: "+sre.getOldSerialNo()+" 已经被打"+packing.getName(unPackageType)+",不能还原,请先解除"+sre.getOldSerialNo()+"的"+packing.getName(unPackageType)+"包装");
			 }
		 }*/

		 
		 if(StringUtils.isBlank(qpd.getWaybillPackEntity().getId())){
			 throw new PackagingException("还原失败! 未查询到已包装记录"); 
		 }
        if(CollectionUtils.isNotEmpty(serialRelationEntityList)){
            for(SerialRelationEntity serialRelationEntity : serialRelationEntityList){
                serialRelationEntity.setWaybillNo(waybillno);
                serialRelationEntity.setNewSerialNo("");

            }

        //处理流水号关系
        updateSerialRelation(serialRelationEntityList,null,qpd.getWaybillPackEntity().getId(),waybillno,qpd.getWaybillPackEntity());
        }

		 //删除
		 delete(qpd.getWaybillPackEntity().getId());

		 return FossConstants.SUCCESS;
	}
	
	private int delete(String id){
		queryPackedDao.deleteActualPackageById(id);
		queryPackedDao.deleteActualPackageDetailByActualPackageId(id);
		//queryPackedDao.deletePackageRequestDetailByActualPackageId(id);
		return FossConstants.SUCCESS;
	}
	
	
	
	
	
	
	/**
	 * 校验包装的流水号是否在当前部门库存
	 * 
	 * @param validateStockSet
	 * @param waybillNo
	 *            本次操作的流水号
	 * 
	 * @author 046130-foss-xuduowei
	 * @date 2013-04-01 下午4:47:21
	 */
	@SuppressWarnings("rawtypes")
	private void verifySerialNoInstock(Set<String> validateStockSet,String waybillNo){
		//首先校验是否有修改的流水号
		if(validateStockSet != null && !validateStockSet.isEmpty()){
			//获取当前部门信息
			CurrentDeptDto cd = queryCurrentDept();
			//新增查询条件map
			Map<String,Object> map = new HashMap<String,Object>();
			//运单号
			map.put("waybillNo", waybillNo);
			//部门
			map.put("deptCode", cd.getDeptCode());
			//获取库存信息
			List<SerialNoAreaDto> areaList = queryPackedDao.querySerialNoStockByWaybill(map);
			if(areaList == null || areaList.isEmpty()){
				throw new PackagingException("当前运单不在库存中");
			}
			//生成迭代器
			Iterator iterator = validateStockSet.iterator();
			//循环取修改的流水号
			while(iterator.hasNext()){
				//获取流水 号
				String serialNo = iterator.next().toString();
				//是否存在
				boolean isExist = false;
				//遍历库存信息。判断需要修改的流水号是否在库存中
				for(SerialNoAreaDto sn : areaList){
					//流水号相同，库存部门为本部门，表名流水号在当前部门库存，可以修改
					if(StringUtils.equals(serialNo, sn.getSerialNo())
							&& StringUtils.equals(cd.getDeptCode(), sn.getOrgCode())){
						isExist = true;
					}
				}
				if(!isExist){//否则，抛出异常
					throw new PackagingException(serialNo + "不在当前部门库存中");
				}
			}
		}else{
			//无操作
		}
	}

	/**
	 * 对包装人员进行新增、修改和删除
	 * 
	 * @param packedPersonList
	 *            包装人员列表
	 * @param packedId
	 *            包装录入的id，包装人员的外键
	 * @param isUpdate
	 *            是否修改
	 * @return 0或1 代表成功或失败
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-24 下午4:47:21
	 */
	private int updatePackedPerson(List<PackedPersonEntity> packedPersonList,
			String packedId, boolean isUpdate) {
		// 判断是否修改
		if (isUpdate) {
			queryPackedDao.deletePackedPersonList(packedId);
		}
		//遍历包装人集合
		for (int i = 0; i < packedPersonList.size(); i++) {
			//员工工号不能为空
			//员工姓名不能为空
			if (!StringUtils.isEmpty(packedPersonList.get(i).getEmpCode())
					&& !StringUtils.isEmpty(packedPersonList.get(i)
							.getEmpName())) {
				//id
				packedPersonList.get(i).setId(UUIDUtils.getUUID());
				//创建时间
				packedPersonList.get(i).setCreateDate(new Date());
				//包装外键
				packedPersonList.get(i).setPackedId(packedId);
			}

		}
		//调用DAO，执行保存操作
		queryPackedDao.insertPackedPersonList(packedPersonList);
		//成功
		return FossConstants.SUCCESS;
	}

	/**
	 * 保存流水号相关信息
	 * 
	 * @param serialRelationList
	 *            新旧流水号关系列表
	 * @param newSerialList
	 *            新流水号关系
	 * @param packId
	 *            包装录入id
	 * @param waybillNo
	 *            运单号
	 * @return
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-22 上午11:38:00
	 */
	@SuppressWarnings("rawtypes")
	private int updateSerialRelation(
			List<SerialRelationEntity> serialRelationList,
			List<SerialRelationEntity> newSerialList, String packId,
			String waybillNo,WaybillPackEntity waybillPackEntity) {

		// 新增新旧流水号关系
		List<SerialRelationEntity> addSerialRelationList = new ArrayList<SerialRelationEntity>();
		// 修改新旧流水号关系
		List<SerialRelationEntity> updateSerialRelationList = new ArrayList<SerialRelationEntity>();
		// 删除新旧流水号关系
		List<SerialRelationEntity> deleteSerialRelationList = new ArrayList<SerialRelationEntity>();
		
		
		// 入库流水号列表
		Set<String> inStockSerialRelationSet = new HashSet<String>();
		// 出库流水号列表
		Set<String> outStockSerialRelationSet = new HashSet<String>();

		// 需要新增的流水号
		Set<String> needAddSerialSet = new HashSet<String>();

		// 变更货签信息状态为激活状态
		Set<String> activeSerialSet = new HashSet<String>();

		// 变更货签信息状态为作废状态
		Set<String> diableSerialSet = new HashSet<String>();
		
		//需要校验修改的流水号是否在当前部门库存
		Set<String> validateStockSet = new HashSet<String>();
		
		//KEY=>新流水号 ; value => 新流水号对应的原流水号关系列表
		Map<String, List<SerialRelationEntity>> packageRequireNewMap=new HashMap<String, List<SerialRelationEntity>>();
		//KEY=> 待作废的新流水号 ; value => 待作废的新流水号对应的原流水号关系列表
		Map<String, List<SerialRelationEntity>> packageRequireOldMap=new HashMap<String, List<SerialRelationEntity>>();
		
		//单独包装的需要更新的
		List<SerialRelationEntity> updatePackageRequireSerialRelationList=new ArrayList<SerialRelationEntity>();
		//新增包装需求
		List<PackagingRequireDetailsEntity> addPackageRequireSerialRelationList = new ArrayList<PackagingRequireDetailsEntity>();
		//作废的包装需求  ==> (active ='Y')->(active ='N')
		List<SerialRelationEntity> disPackageRequireSerialRelationList=new ArrayList<SerialRelationEntity>();
		//开启的包装需求  ==> (active ='N')->(active ='Y')
		List<SerialRelationEntity> unDisPackageRequireSerialRelationList=new ArrayList<SerialRelationEntity>();
		//校验当前包装是否可以拆开重新包装
		List<SerialRelationEntity> validatePackageRequireSerialRelationList=new ArrayList<SerialRelationEntity>();

		//作废包装需求流水号
		List<String> cancleSeriaList=new ArrayList<String>();
		Set<String> cancleSeriaSet=new HashSet<String>();

		for(int i=0;i<serialRelationList.size();i++){
			if(StringUtils.equals(serialRelationList.get(i).getIsPacked(), FossConstants.YES)
					&&StringUtils.isNotBlank(serialRelationList.get(i).getNewSerialNo())
					&&!StringUtils.equals(serialRelationList.get(i).getTempSerialNo(),serialRelationList.get(i).getOldSerialNo())
					&&!StringUtils.equals(serialRelationList.get(i).getTempSerialNo(),serialRelationList.get(i).getNewSerialNo())){
				//之前包装流水号
				String oldSeria=serialRelationList.get(i).getTempSerialNo();
				//将之前生成需求流水号作废
				cancleSeriaSet.add(oldSeria);
				
			}
		}
		if(cancleSeriaSet.size()>0){
			Iterator<String> ite=cancleSeriaSet.iterator();
			while(ite.hasNext()){
				cancleSeriaList.add(ite.next());
			}
		}
		
		// 遍历新旧流水号关系集合
		for (int i = 0; i < serialRelationList.size(); i++) {
			//获取新旧流水号关系对象
			SerialRelationEntity serialRelationEntity = (SerialRelationEntity) serialRelationList
					.get(i);
			serialRelationEntity.setPackedId(packId);
			serialRelationEntity.setWaybillNo(waybillNo);
			// 是否已包装

            //防止NULL值
            if(StringUtils.isBlank(serialRelationEntity.getIsPacked())){
            	serialRelationEntity.setIsPacked("");
            }
            if(StringUtils.isBlank(serialRelationEntity.getNewSerialNo())){
            	serialRelationEntity.setNewSerialNo("");
            }
            if(StringUtils.isBlank(serialRelationEntity.getOldSerialNo())){
            	serialRelationEntity.setOldSerialNo("");
            }
            if(StringUtils.isBlank(serialRelationEntity.getTempSerialNo())){
            	serialRelationEntity.setTempSerialNo("");
            }

			String isPacked = serialRelationEntity.getIsPacked().trim();
			// 新流水号
			String newSerialNo = serialRelationEntity.getNewSerialNo().trim();
			// 原流水号
			String oldSerialNo = serialRelationEntity.getOldSerialNo().trim();
			// 新流水号，前端修改是此位不会变动
			String tempSerialNo = serialRelationEntity.getTempSerialNo().trim();
			
			//只获取所有被修改过的包装需求
			if(!StringUtils.equals(tempSerialNo, newSerialNo)){
				// 以新流水号为KEY 看看新流水号是否需要生成新的包装需求
				if(StringUtils.isNotBlank(newSerialNo) && packageRequireNewMap.containsKey(newSerialNo)){
					packageRequireNewMap.get(newSerialNo).add(serialRelationEntity);
				}else if(StringUtils.isNotBlank(newSerialNo)){
					List<SerialRelationEntity> serialRelationEntityListTemp=new ArrayList<SerialRelationEntity>();
					serialRelationEntityListTemp.add(serialRelationEntity);
					packageRequireNewMap.put(newSerialNo, serialRelationEntityListTemp);
				}
				
				// 以待作废的新流水号为KEY 看看待作废的新流水号是否需要删除包装需求
				if(StringUtils.isNotBlank(tempSerialNo) && packageRequireOldMap.containsKey(tempSerialNo)){
					packageRequireOldMap.get(tempSerialNo).add(serialRelationEntity);
				}else if(StringUtils.isNotBlank(tempSerialNo)){
					List<SerialRelationEntity> serialRelationEntityListTemp=new ArrayList<SerialRelationEntity>();
					serialRelationEntityListTemp.add(serialRelationEntity);
					packageRequireOldMap.put(tempSerialNo, serialRelationEntityListTemp);
				}
				
			}
			
			
			/**
			 * 1.原来合并现在拆开原合并改单独包装
			 * 2.原来合并现在拆开原合并组合其他流水号
			 * 3.原来单独包装现在改成合并包装
			 * 4.原来单独包装现在改成不包装
			 * 5.原来合并现在拆开包装
			 * 6.原来未包装现在独立包装
			 * 7.原来未包装现在合并包装
			 * 
			 *	以上7中处理了 流水号组合可能产生的变化  => PS : (对于为产生变化的流水号不做业务处理)
			 *
			 * 
			 * StringUtils.equals(isPacked, FossConstants.YES) ==> 表示已包装条件
			 * StringUtils.isNotBlank(newSerialNo) ==> 新流水号不为空
			 * !StringUtils.equals(tempSerialNo, newSerialNo) ==> 当前记录是被被拆开之后合并的记录
			 * StringUtils.equals(oldSerialNo, newSerialNo) => 新流水号是否等于原流水号 如果等于则判定为单独包装否则是合并包装
			 * 对包装状态进行判断，
			 * 已包装的可能需要修改，
			 * 删除流水号关系，
			 * 未包装的可能需要新增流水号关系
			 */
			
			// 原来合并，后来拆分，
			//并单独包装，
			//此时需要激活原流水号，
			//也不需要新增
			if (StringUtils.equals(isPacked, FossConstants.YES)
					&& StringUtils.isNotBlank(newSerialNo)
					&& !StringUtils.equals(tempSerialNo, newSerialNo)
					&& StringUtils.equals(oldSerialNo, newSerialNo)) {

						// 修改新旧流水号关系
						updateSerialRelationList.add(serialRelationEntity);
						// 作废已拆分的流水号
						diableSerialSet.add(tempSerialNo);
						// 出库已拆分的流水号
						outStockSerialRelationSet.add(tempSerialNo);
						//需要校验修改的流水号是否在库存中
						validateStockSet.add(tempSerialNo);
						//validateStockSet.add(oldSerialNo);
						//激活原流水号
						activeSerialSet.add(oldSerialNo);
						//入库原流水号
						inStockSerialRelationSet.add(oldSerialNo);
			
			//原来合并，后来拆分，与其他流水号包装
			}else if (StringUtils.equals(isPacked, FossConstants.YES)
					&& StringUtils.isNotBlank(newSerialNo)
					&& !StringUtils.equals(tempSerialNo, newSerialNo)
					&& !StringUtils.equals(oldSerialNo, newSerialNo)) {
				
						// 修改新旧流水号关系，同时生成新流水号
						updateSerialRelationList.add(serialRelationEntity);
						// 新流水号需要做入库操作
						inStockSerialRelationSet.add(newSerialNo);
						/**
						 * 已包装，但新流水号有变化，
						 * 需要新增新流水号，
						 * 同时激活新增加的流水号，
						 * 对于变更前的新流水
						 * 号，需要作废此流水号
						 * 
						 */
						// 需要新增的流水号
						needAddSerialSet.add(newSerialNo);
						// 激活新流水号
						//activeSerialList.add(newSerialNo);
						// 作废修改的流水号
						diableSerialSet.add(tempSerialNo);
						// 出库修改的流水号
						outStockSerialRelationSet.add(tempSerialNo);
						//需要校验修改的流水号是否在库存中
						validateStockSet.add(tempSerialNo);
						//validateStockSet.add(oldSerialNo);
						
			//原来是单独包装，后来合并，需要校验原流水号
			}else if (StringUtils.equals(isPacked, FossConstants.YES)
					&& StringUtils.isNotBlank(newSerialNo)
					&& !StringUtils.equals(tempSerialNo, newSerialNo)
					&& StringUtils.equals(oldSerialNo, tempSerialNo)) {

                        //校验修改的流水号是否在库
						validateStockSet.add(oldSerialNo);
                        // 修改新旧流水号关系
                        updateSerialRelationList.add(serialRelationEntity);
						
			//前端对已包装的取消包装，新流水号为空,并且是单独包装的
			}else if (StringUtils.equals(isPacked, FossConstants.YES)
					&& StringUtils.isBlank(newSerialNo)
					&& StringUtils.equals(tempSerialNo, oldSerialNo)){
						
						//删除流水号
						deleteSerialRelationList.add(serialRelationEntity);
						//需要校验修改的流水号是否在库存中
						validateStockSet.add(oldSerialNo);
						
			//前端对已包装的取消包装，新流水号为空,并且不是单独包装的	
			}else if (StringUtils.equals(isPacked, FossConstants.YES)
					&& StringUtils.isBlank(newSerialNo)
					&& !StringUtils.equals(tempSerialNo, oldSerialNo)){
				
						// 删除新旧流水号关系，
						//同时将该流水号标记为未包装，激活货签信息
						deleteSerialRelationList.add(serialRelationEntity);
		
						// 原流水号需要做入库操作
						inStockSerialRelationSet.add(oldSerialNo);
						// 原包装流水号做出库操作
						outStockSerialRelationSet.add(tempSerialNo);
						
						//需要校验修改的流水号是否在库存中
						//validateStockSet.add(oldSerialNo);
						validateStockSet.add(tempSerialNo);
						/**
						
						 * 已包装但取消包装的，
						 * 只需作废之前生成的新流水号，
						 * 同时激活原流水号
						
						 */
						// 激活流水号
						activeSerialSet.add(oldSerialNo);
						// 作废流水号
						diableSerialSet.add(tempSerialNo);
						
			//未包装==>新包装的流水号,并且单独包装的
			}else if(!StringUtils.equals(isPacked, FossConstants.YES)
						&& StringUtils.isNotBlank(newSerialNo)
						&& StringUtils.equals(newSerialNo, oldSerialNo)){
				
							//id
							serialRelationEntity.setId(UUIDUtils.getUUID());
							//创建日期
							serialRelationEntity.setCreateDate(new Date());
							//加入到集合中
							addSerialRelationList.add(serialRelationEntity);
			
							//需要校验修改的流水号是否在库存中
							validateStockSet.add(oldSerialNo);
			
			//未包装==>新包装的流水号,并且合并包装方式
			}else if(!StringUtils.equals(isPacked, FossConstants.YES)
						&& StringUtils.isNotBlank(newSerialNo)
						&& !StringUtils.equals(newSerialNo, oldSerialNo)){
				
							/**			
							 * 新增新旧流水号关系，
							 * 同时生成新流水号，
							 * 将原流水号标记为已包装
							 * 
							 */
							// 生成id
							serialRelationEntity.setId(UUIDUtils.getUUID());
							// 得到创建日期
							serialRelationEntity.setCreateDate(new Date());
							//加入到集合中
							addSerialRelationList.add(serialRelationEntity);
							// 新流水号需要做入库操作
							inStockSerialRelationSet.add(newSerialNo);
							// 原流水号做出库操作
							outStockSerialRelationSet.add(oldSerialNo);
							/**				
							 * 未包装，但是新增包装，
							 * 需要新增流水号，同时激活，
							 * 另需要作废原流水号
							 */
							// 新增流水号
							needAddSerialSet.add(newSerialNo);
							// 作废流水号
							diableSerialSet.add(oldSerialNo);
							// 激活流水号
							//activeSerialSet.add(newSerialNo);
			
							//需要校验修改的流水号是否在库存中
							validateStockSet.add(oldSerialNo);
							//validateStockSet.add(newSerialNo);
			}
		}
		
		

		//获取所有的包装需求
		List<SerialRelationEntity> serialRelationListTemp=new ArrayList<SerialRelationEntity>();
		serialRelationListTemp.addAll(queryPackedDao.querySerialRelation(waybillNo,packing.WOODEN_FRAME.getValue(),null));
		serialRelationListTemp.addAll(queryPackedDao.querySerialRelation(waybillNo,packing.MAKE_WOODEN_STOCK.getValue(),null));

		if(!packageRequireOldMap.isEmpty()){
			
			 //遍历所有的新流水号MAP
		    for (Iterator it = packageRequireOldMap.keySet().iterator(); it.hasNext();) {
	            String s = (String) it.next();
	            List<SerialRelationEntity> serialRelationEntityList= packageRequireOldMap.get(s);
	            
	            //独立包装且
	            if(serialRelationEntityList.size() == 1){
	            	
	            	SerialRelationEntity sre= serialRelationEntityList.get(0);
	            	//遍历所有的包装需求
 	            	for(SerialRelationEntity sreTemp:serialRelationListTemp){
 	            		//如果这个流水号实际包装的ID为空则这个流水号是正常生成的
	            		if(StringUtils.isBlank(sreTemp.getActualPackageId())){
	            			continue;
	            		}
 	            		//流水号相同,包装需求不同
 		            	if(StringUtils.equals(s, sreTemp.getOldSerialNo())
 		            			&& StringUtils.equals(waybillPackEntity.getUnPackageType(), sreTemp.getPackageType())){
 		            	 	//直接赋值非当前包装类型
                            sre.setActualPackageId("");
 		              		updatePackageRequireSerialRelationList.add(sre);
 		              		//需要校验当前的流水号是否能拆开
 		              		validatePackageRequireSerialRelationList.add(sreTemp);
 		              		break;
 		            	}
 	            	}
	            }else if(serialRelationEntityList.size() > 1){
	            	
	            	 int sizeTemp=0;
	 	            //遍历当前所有流水号下面的所有的原流水号
	 	            	//遍历所有的包装需求
	 	            	for(SerialRelationEntity sreTemp:serialRelationListTemp){
	 	            		
	 	            		//如果这个流水号实际包装的ID
		            		if(StringUtils.isBlank(sreTemp.getActualPackageId())){
		            			continue;
		            		}
	 	            		// 要判定当前这条记录是否已包装
	 		            	if(StringUtils.equals(s, sreTemp.getOldSerialNo()) 
	 		            			&& StringUtils.equals(waybillPackEntity.getUnPackageType(), sreTemp.getPackageType())){
	 		            		validatePackageRequireSerialRelationList.add(sreTemp);

                                //并且删除新生成的包装需求
                                SerialRelationEntity deleteTemp = new SerialRelationEntity();

                                deleteTemp.setId(sreTemp.getPackageRequestDetailId());
                                deleteTemp.setWaybillNo(waybillPackEntity.getWayBillNumber());
                                deleteTemp.setPackageType(sreTemp.getPackageType());
                                deleteTemp.setOldSerialNo(sreTemp.getOldSerialNo());

                                deleteSerialRelationList.add(deleteTemp);

                                sizeTemp++;
	 		            		break;
	 		            	}
	 	            	}
	 	            
	 	            if(sizeTemp > 0){
	 	            	//把原流水号改成有效
	            		unDisPackageRequireSerialRelationList.addAll(serialRelationEntityList);
	 	            }
	            }
	        }
		}
		//新生成包装需求的
		 if(!packageRequireNewMap.isEmpty()){
			 //遍历所有的新流水号MAP
		    for (Iterator it = packageRequireNewMap.keySet().iterator(); it.hasNext();) {
	            String s = (String) it.next();
	            List<SerialRelationEntity> serialRelationEntityList= packageRequireNewMap.get(s);
	            
	            if(serialRelationEntityList.size() == 1){
	            	//直接赋值非当前包装类型
            		serialRelationEntityList.get(0).setActualPackageId(packId);
            		updatePackageRequireSerialRelationList.add(serialRelationEntityList.get(0));
	            	
	            }else if(serialRelationEntityList.size() > 1){
	            	
	            	 int sizeTemp=0;
	 	            //遍历当前所有流水号下面的所有的原流水号
	 	            sizeTemp = checkSerialRelation(waybillPackEntity,
							serialRelationListTemp, serialRelationEntityList,
							sizeTemp);
	 	            
	 	            if(sizeTemp == serialRelationEntityList.size()){
	 	            	
	 					PackagingRequireEntity pre =packOutDao.queryPackagingRequireWithId(waybillNo);

	 	            	PackagingRequireDetailsEntity prd=new PackagingRequireDetailsEntity();
	 	            	
	 	            	prd.setId(UUIDUtils.getUUID());
						//运单号
						prd.setWaybillNo(waybillNo);
						//流水号
						prd.setSerialNo(s);
						//包装需求主表id
						//重新获取主表ID
						prd.setRequireId(pre.getId());
						//prd.setRequireId(waybillPackEntity.getId());
						//开单时间
						prd.setWaybillCreateDate(waybillPackEntity.getBillTime());
						//默认为未包装
						prd.setIsPacked(FossConstants.NO);
						//设置包装需求类型
	 	            	prd.setPackageType(waybillPackEntity.getUnPackageType());
	 	            	//获取实际包装主表ID
	 	            	prd.setActualPackageId(packId);
	 	            	addPackageRequireSerialRelationList.add(prd);
	 	            	
	 	            	//生成新的包装之后要作废原来的包装需求
 	            		disPackageRequireSerialRelationList.addAll(serialRelationEntityList);
	 	            }else if(sizeTemp != 0){
	 	            	throw new PackagingException("包装信息存在错误");
	 	            }
	            }
	        }
		}
		 
		 /*************************************************************************/
		 
		//检验当前流水号是否能够拆解
		validatePackageRequire(validatePackageRequireSerialRelationList,waybillPackEntity);
		//校验需要出入库的流水号是否在当前部门库存
		//2013-04-17，046130-foss-xuduowei
		verifySerialNoInstock(validateStockSet,waybillNo);
		
		/**
		 * 调用接送货接口，增加货签号
		 */

		if (needAddSerialSet.size() > 0) {
			//增加货签号
			addWaybillSerial(needAddSerialSet,serialRelationList,waybillNo);
		}
		
		/**
		 * 修改货签号状态为激活状态
		 */
		if (activeSerialSet.size() > 0) {
			Iterator<String> iterator = activeSerialSet.iterator();
			while(iterator.hasNext()){
				// 调用接送货接口修改流水号状态为激活
				ResultDto resultDto = labeledGoodService.updateSerialNo(
						waybillNo, iterator.next().toString(),
						FossConstants.ACTIVE);
				// 获取成功标示
				String code = resultDto.getCode();
				// 判断是否失败，如果失败抛出失败原因
				if (StringUtils.equals(code,
						PackagingConstants.PACKAGING_FAILURE)) {
					throw new PackagingException(resultDto.getMsg());
				}
			}
		}
		/**
		 * 修改货签号状态为作废状态
		 */
		if (diableSerialSet.size() > 0) {

			Iterator<String> iterator = diableSerialSet.iterator();
			while (iterator.hasNext()) {
				// 调用接送货接口修改流水号状态为作废
				ResultDto resultDto = labeledGoodService.updateSerialNo(
						waybillNo, iterator.next().toString(),
						FossConstants.INACTIVE);
				// 获取成功标示
				String code = resultDto.getCode();
				// 判断是否失败，如果失败抛出失败原因
				if (StringUtils.equals(code,
						PackagingConstants.PACKAGING_FAILURE)) {
					//抛出接送货给出的失败原因
					throw new PackagingException(resultDto.getMsg());
				}
			}
		}

		/**
		 * 
		 * 
		 * 此处需要调用运单接口，
		 * 更新运单开单件数
		 * 
		 * 
		 */
		// 首先获取运单号件数
		int serialNum = queryPackedDao.querySerialNoCount(waybillNo);
		// 用户
		UserEntity user = FossUserContext.getCurrentUser();
		// 职员
		EmployeeEntity employee = user.getEmployee();
		CurrentDeptDto currentDept = queryCurrentDept();
		// 调用接口修改运单开单件数
		ResultDto resultDto = waybillManagerService.updateGoodsNum(waybillNo,
				serialNum,employee.getEmpCode(),currentDept.getDeptCode());
		// 获取成功标示
		String code = resultDto.getCode();
		// 判断是否失败，
		//如果失败抛出失败原因
		if (StringUtils.equals(code,
				PackagingConstants.PACKAGING_FAILURE)) {
			//抛出接送货给出的失败原因
			throw new PackagingException(resultDto.getMsg());
		}
		//根据运单号查询运单基本信息
		WaybillEntity waybillEntity=waybillManagerService.queryWaybillBasicByNo(waybillNo);
		/**
		 * 新增表“异常运单信息表”，表结构与运单表保持一致，用于记录： 
         * ①有打木架操作的运单信息。 
		 * 
		 * **/
		try {
			waybillPackBIService.addWaybillPackBIEntity(waybillEntity);
			
		} catch (BusinessException e) {
			throw new TfrBusinessException("调接送货接口，新增表 异常运单信息表 异常："+e.getErrorCode());
		}
		
		//修改包装需求的开单件数
		Map<String,Object> map = new HashMap<String,Object>();
		//运单号
		map.put("waybillNo", waybillNo);
		//件数
		map.put("num", serialNum);
		queryPackedDao.updateWaybillNum(map);
		
		// 修改走货路径
		handleAfPackedTransPath(serialRelationList, waybillNo);
		
		/**
		 * 
		 * 
		 * 调用库存接口，
		 * 处理流水号出入库操作
		 * 
		 * 
		 */
		handleSerialStock(inStockSerialRelationSet, outStockSerialRelationSet,
			waybillNo);

		/**
		 * 调用DAO接口，
		 */
		// 新增新旧流水号关系
		if (addSerialRelationList.size() > 0) {
			// 新增加新旧流水号关系
			queryPackedDao.insertSerialRelation(addSerialRelationList);
			// 更新需要包装的流水号包装状态为已包装
			queryPackedDao.addSerialStatus(addSerialRelationList);
		}
		// 修改新旧流水号关系
		if (updateSerialRelationList.size() > 0) {
			// 修改新旧流水号关系
			queryPackedDao.updateSerialRelation(updateSerialRelationList);
		}
		// 删除新旧流水号关系
		if (deleteSerialRelationList.size() > 0) {
			// 删除新旧流水号关系
			queryPackedDao.deleteSerialRelation(deleteSerialRelationList);
			// 复位需要包装的流水号包装状态为未包装
			queryPackedDao.updateSerialStatus(deleteSerialRelationList);
		}

		// 更新流水号状态后，同步更新包装需求表中的已包装件数
		queryPackedDao.updatePackedNum(waybillNo);
		//修改包装状态
		queryPackedDao.updatePacakageRequirePackedStatus(waybillNo);
		
		//更新流水号明细
		updatePackageRequireSerial(updatePackageRequireSerialRelationList,waybillPackEntity);
		//激活流水号
		undisPackageRequireSerial(unDisPackageRequireSerialRelationList,waybillPackEntity);
		//作废流水号
		disPackageRequireSerial(disPackageRequireSerialRelationList,waybillPackEntity);
		//添加新的包装需求
		packOutDao.addPackagingRequireDetails(addPackageRequireSerialRelationList);
		//作废包装需求中无效的流水号
		if(cancleSeriaList.size()>0)
		{
			packCommonService.cancleUnPackReSerias(waybillNo, getOutFieldCode().getCode(), cancleSeriaList);
		}
		
		return FossConstants.SUCCESS;
	}

	/**
	 * @param waybillPackEntity
	 * @param serialRelationListTemp
	 * @param serialRelationEntityList
	 * @param sizeTemp
	 * @return
	 */
	//sonar 218427 降低循环嵌套层数  遍历当前所有流水号下面的所有的原流水号
	private int checkSerialRelation(WaybillPackEntity waybillPackEntity,
			List<SerialRelationEntity> serialRelationListTemp,
			List<SerialRelationEntity> serialRelationEntityList, int sizeTemp) {
		for(SerialRelationEntity sre :serialRelationEntityList){
			//遍历所有的包装需求
			for(SerialRelationEntity sreTemp:serialRelationListTemp){
				//流水号相同,包装需求不同,并且此流水号要为未包装并且是有效的
		    	if(StringUtils.equals(sre.getOldSerialNo(), sreTemp.getOldSerialNo()) 
		    			&& StringUtils.equals(waybillPackEntity.getUnPackageType(), sreTemp.getPackageType())
		                && StringUtils.equals("N",sreTemp.getIsPacked())
		                && StringUtils.equals("Y",sreTemp.getActive())){
		    		sizeTemp++;
		    		break;
		    	}
			}
		}
		return sizeTemp;
	}
	
	
	/**
	 * 校验所有的列表里面的数据是否已包装如果已包装则抛出当前打包不能拆开
	 * @param validatePackageRequireSerialRelationList
	 */
	private void validatePackageRequire(List<SerialRelationEntity> validatePackageRequireSerialRelationList,WaybillPackEntity waybillPackEntity){
		if(!validatePackageRequireSerialRelationList.isEmpty()){
			for(SerialRelationEntity sre : validatePackageRequireSerialRelationList){
				if("Y".equals(sre.getIsPacked())){
					throw new PackagingException("流水号 : "+sre.getTempSerialNo()+" 为已包装状态,请先拆解当前流水号的" + packing.getName(waybillPackEntity.getUnPackageType())+"包装");
				}
			}
		}
	}
	
	/**
	 * 更新单独包装的包装需求流水号
	 * @param updatePackageRequireSerialRelationList
	 */
	private void updatePackageRequireSerial(List<SerialRelationEntity> updatePackageRequireSerialRelationList,WaybillPackEntity waybillPackEntity){
		Map<String, Object> map=null;
		
		if(CollectionUtils.isNotEmpty(updatePackageRequireSerialRelationList)){
			for(SerialRelationEntity sre : updatePackageRequireSerialRelationList){
				map=new HashMap<String, Object>(PackagingConstants.SONAR_NUMBER_4);
				map.put("actualPackageId", sre.getActualPackageId());
				map.put("waybillNo", waybillPackEntity.getWayBillNumber());
				map.put("oldSerialNo", sre.getOldSerialNo()); 
				map.put("packageType", waybillPackEntity.getUnPackageType());	
				queryPackedDao.updateSerialdetail(map);
			}
		}
	}
	/**
	 * 修改为生效
	 * @param undisPackageRequireSerialRelationList
	 */
	private void undisPackageRequireSerial(List<SerialRelationEntity> undisPackageRequireSerialRelationList,WaybillPackEntity waybillPackEntity){
		Map<String, Object> map=null;
		
		if(CollectionUtils.isNotEmpty(undisPackageRequireSerialRelationList)){
			for(SerialRelationEntity sre : undisPackageRequireSerialRelationList){
				map=new HashMap<String, Object>(PackagingConstants.SONAR_NUMBER_4);
				map.put("active", "Y");
				map.put("waybillNo", waybillPackEntity.getWayBillNumber());
				map.put("oldSerialNo", sre.getOldSerialNo()); 
				map.put("packageType", waybillPackEntity.getUnPackageType());	
				queryPackedDao.updateSerialdetail(map);
			}
		}
	}
	
	/**
	 * 作废有效流水号
	 * @param disPackageRequireSerialRelationList
	 * @param waybillPackEntity
	 */
	private void disPackageRequireSerial(List<SerialRelationEntity> disPackageRequireSerialRelationList,WaybillPackEntity waybillPackEntity){
		Map<String, Object> map=null;
		
		if(CollectionUtils.isNotEmpty(disPackageRequireSerialRelationList)){
			for(SerialRelationEntity sre : disPackageRequireSerialRelationList){
				map=new HashMap<String, Object>(PackagingConstants.SONAR_NUMBER_4);
				map.put("active", "N");
				map.put("waybillNo", waybillPackEntity.getWayBillNumber());
				map.put("oldSerialNo", sre.getOldSerialNo()); 
				map.put("packageType", waybillPackEntity.getUnPackageType());	
				queryPackedDao.updateSerialdetail(map);
			}
		}
	}
	
	

	/**
	 * 增加货签号
	 * @author 046130-foss-xuduowei
	 * @date 2013-1-15 上午11:00:15
	 */
	private void addWaybillSerial(Set<String> needAddSerialSet,
			List<SerialRelationEntity> serialRelationList,
			String waybillNo){

		// 需要新增的流水号
		List<String> addSerialNoList = convertSetToList(needAddSerialSet);
		// 标签列表
		List<LabeledGoodDto> labeledGoodList = new ArrayList<LabeledGoodDto>();
		for (int i = 0; i < addSerialNoList.size(); i++) {
			// 新增的标签号
			String serialNo = addSerialNoList.get(i);
			// 标签对象
			LabeledGoodDto labeledGoodDto = new LabeledGoodDto();
			// 关联原运单流水号
			StringBuffer labelSb = new StringBuffer();
			// 变动事项
			StringBuffer itemsSb = new StringBuffer();
			int length = serialRelationList.size();
			for (int j = 0; j < length; j++) {
				SerialRelationEntity sre = serialRelationList.get(j);
				// 新流水号
				String nSerialNo = sre.getNewSerialNo();
				// 原流水号
				String oSerialNo = sre.getOldSerialNo();
				// 判断新流水号是否由原流水号合并的
				if (StringUtils.equals(nSerialNo, serialNo)) {
					labelSb.append(oSerialNo);
					//增加斜杠
					//在合适的未知添加
					//避免了后期做删除处理
					if (length > 1 && j != length - 1) {
						//添加斜杠
						labelSb.append(PackagingConstants.PACKAGING_LABEL_SLASH);
					}
					int a = Integer.parseInt(oSerialNo);
					//增加到变动事项
					itemsSb.append(a);
					//增加斜杠
					//在合适的未知添加
					//避免了后期做删除处理
					if (length > 1 && j != length - 1) {
						//添加斜杠
						itemsSb.append(PackagingConstants.PACKAGING_LABEL_SLASH);
					}
				}

			}
			//运单号
			labeledGoodDto.setWaybillNo(waybillNo);
			//流水号
			labeledGoodDto.setSerialNo(serialNo);
			//原流水号
			labeledGoodDto.setOldSerialNo(labelSb.toString());
			//流水号变动事项
			labeledGoodDto.setNumberChangItems(
			// 打木架：第
					PackagingConstants.PACKAGING_CHANGE_ITEMS_BEFORE
							+ itemsSb.toString() +
							// 件合并
							PackagingConstants.PACKAGING_CHANGE_ITEMS_BACK);
			//增加对原流水号和变动事项的长度判断，避免长度过长
			if(labeledGoodDto.getOldSerialNo().length()>PackagingConstants.SONAR_NUMBER_3000 
					|| labeledGoodDto.getNumberChangItems().length()>PackagingConstants.SONAR_NUMBER_3000){
				throw new PackagingException("合并的流水号过多，建议缩小合并流水号个数");
			}
			//增加到 集合中
			labeledGoodList.add(labeledGoodDto);
		}
		// 调用接送货接口插入新增的流水号
		ResultDto resultDto = labeledGoodService.insertSerialNo(waybillNo,
				labeledGoodList);
		// 获取成功标示
		String code = resultDto.getCode();
		// 判断是否失败，如果失败抛出失败原因
		if (StringUtils.equals(code,
				PackagingConstants.PACKAGING_FAILURE)) {
			throw new PackagingException(resultDto.getMsg());
		}
	}
	/**
	 * 将Set转为List
	 * 
	 * @param needAddSerialSet
	 *            新增的流水号
	 * @author 046130-foss-xuduowei
	 * @date 2012-11-5 上午9:29:20
	 * 
	 */
	private List<String> convertSetToList(Set<String> needAddSerialSet) {
		//list集合
		List<String> addSerialNoList = new ArrayList<String>();
		//迭代器
		Iterator<String> iterator = needAddSerialSet.iterator();
		//遍历迭代器
		while (iterator.hasNext()) {
			//加入到集合中
			addSerialNoList.add(iterator.next().toString());
		}
		//返回
		return addSerialNoList;
	}
	/**
	 * 出入库操作
	 * 
	 * @param inStockSerialRelationSet
	 *            入库流水号
	 * @param outStockSerialRelationSet
	 *            出库流水号
	 * @param waybillNo
	 *            运单号
	 * @return true或false
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-29 上午11:36:54
	 */
	@Override
	public int handleSerialStock(Set<String> inStockSerialRelationSet,
			Set<String> outStockSerialRelationSet, String waybillNo) {
		// 用户
		UserEntity user = FossUserContext.getCurrentUser();
		// 职员
		EmployeeEntity employee = user.getEmployee();
		// 当前操作部门
		List<String> bizTypes = new ArrayList<String>();
		// 设置外场类型
		bizTypes.add(BizTypeConstants.ORG_TRANSFER_CENTER);
		//获取当前登录人信息
		OrgAdministrativeInfoEntity activeDeptInfo = FossUserContext
				.getCurrentDept();
		//获取原始组织信息
		OrgAdministrativeInfoEntity org = orgAdministrativeInfoComplexService
				.queryOrgAdministrativeInfoByCode(activeDeptInfo.getCode(),
						bizTypes);
		if (org == null) {
			throw new PackagingException("当前登录人无操作部门");
		} else {
			// 无操作
		}
		/**
		 * 1、获取货区编号，
		 * 名称，
		 * 操作人工号，
		 * 操作人姓名，
		 * 出入库类型类型，
		 * 设备类型
		 */
		InOutStockEntity ioStockEntity = new InOutStockEntity();
		// 运单号
		ioStockEntity.setWaybillNO(waybillNo);
		// 操作人工号
		ioStockEntity.setOperatorCode(employee.getEmpCode());
		// 操作人姓名
		ioStockEntity.setOperatorName(employee.getEmpName());
		// 外场编码
		ioStockEntity.setOrgCode(org.getCode());
		// 出入库事件
		ioStockEntity.setInOutStockTime(new Date());
		/**
		 * 入库操作
		 */
		Iterator<String> iteratorIn = inStockSerialRelationSet.iterator();
		while (iteratorIn.hasNext()) {
			// 入库类型类型
			ioStockEntity
					.setInOutStockType(StockConstants.AFTER_PACKAGE_NEW_GOODS_IN_STOCK_TYPE);
			//入库流水号
			String serialNo = iteratorIn.next().toString();
			if (!StringUtils.isEmpty(serialNo)) {
				//设置id
				ioStockEntity.setId(UUIDUtils.getUUID());
				//设置流水号
				ioStockEntity.setSerialNO(serialNo);
				try {
					//调用库存接口做入库操作
					stockService.inStockPC(ioStockEntity);
				} catch (BusinessException e) {
					//抛出库存接口业务异常
					throw new PackagingException(e.getErrorCode());
				}
			}
		}
		/**
		 * 出库操作
		 */
		Iterator<String> iteratorOut = outStockSerialRelationSet.iterator();
		while (iteratorOut.hasNext()) {
			// 出库类型类型
			ioStockEntity
					.setInOutStockType(StockConstants.AFTER_PACKAGE_OLD_GOODS_OUT_STOCK_TYPE);
			//出库流水号
			String serialNo = iteratorOut.next().toString();
			if (!StringUtils.isEmpty(serialNo)) {
				//设置id
				ioStockEntity.setId(UUIDUtils.getUUID());
				//设置流水号
				ioStockEntity.setSerialNO(serialNo);
				try {
					//调用库存接口做出库操作
					stockService.outStockPC(ioStockEntity);
				} catch (BusinessException e) {
					//抛出库存接口业务异常
					throw new PackagingException(e.getErrorCode());
				}
			}
		}
		return FossConstants.SUCCESS;
	}
	/**
	 * 
	 * 包装后调用走货路径接口修改走货路径
	 * 
	 * @param serialRelationList
	 *            新旧流水号关系列表
	 * @param waybillNo
	 *            运单号
	 * @author 046130-foss-xuduowei
	 * @date 2012-11-30 上午8:46:26
	 */
	private int handleAfPackedTransPath(
			List<SerialRelationEntity> serialRelationList, String waybillNo) {
		// 拆分流水号
		List<SerialRelationEntity> splitList = serialRelationList;
		//当前组织信息
		CurrentDeptDto currentDept = queryCurrentDept();
		if (currentDept == null) {
			throw new PackagingException("当前部门为空");
		}
		//包装部门编码
		String packingOrgCode = currentDept.getDeptCode();
		/**
		 * 对拆分的流水号进行遍历取值
		 */
		for (int i = 0; i < splitList.size(); i++) {
			// 原流水号
			String oldSerialNo = splitList.get(i).getOldSerialNo();
			// 新流水号
			String newSerialNo = splitList.get(i).getNewSerialNo();
			// 临时流水号，本次修改是从数据库读取的新流水号
			String tempSerialNo = splitList.get(i).getTempSerialNo();
			// 标志位
			String flag = splitList.get(i).getFlag();
			/**
			 * 临时流水号不为空
			 * 临时流水号和原流水号不相等
			 * 临时流水号和新流水号不相等
			 * 标志位为为已操作 
			 */
			if (!StringUtils.isEmpty(tempSerialNo)
					&& !StringUtils.equals(tempSerialNo, oldSerialNo)
					&& !StringUtils.equals(tempSerialNo, newSerialNo)
					&& !StringUtils.equals(flag, FossConstants.NO)) {
				//拆分前流水号集合
				List<String> beforeSplit = new ArrayList<String>();
				//拆分后流水号集合
				List<String> afterSplit = new ArrayList<String>();
				// int counter = 0;
				beforeSplit.add(tempSerialNo);
				for (int j = 0; j < splitList.size(); j++) {
					//临时流水号
					String tSerialNo = splitList.get(j).getTempSerialNo();
					//原流水号
					String oSerialNo = splitList.get(j).getOldSerialNo();
					//此情况表明原来合并，此次复原拆分了
					if (StringUtils.equals(tempSerialNo, tSerialNo)) {
						//将原流水号加入到拆分后流水号
						afterSplit.add(oSerialNo);
						//清空标志位
						splitList.get(j).setFlag(FossConstants.NO);
					}
				}
				//调用走货路径接口
				calculateTransportPathService.packing(waybillNo,
						packingOrgCode, afterSplit, beforeSplit);
			}
		}
		// 清除标志位
		for (int i = 0; i < serialRelationList.size(); i++) {
			serialRelationList.get(i).setFlag(null);
		}
		// 合并流水号
		List<SerialRelationEntity> mergeList = serialRelationList;

		/**
		 * 对合并的流水号进行遍历取值
		 */
		for (int i = 0; i < mergeList.size(); i++) {
			// 原流水号
			String oldSerialNo = mergeList.get(i).getOldSerialNo();
			// 新流水号
			String newSerialNo = mergeList.get(i).getNewSerialNo();
			// 临时流水号，本次修改是从数据库读取的新流水号
			String tempSerialNo = mergeList.get(i).getTempSerialNo();
			// 标志位
			String flag = mergeList.get(i).getFlag();
			/**
			 * 新流水号不为空
			 * 新流水号和临时流水号不相等
			 * 原流水号和新流水号不相等
			 */
			if (!StringUtils.isEmpty(newSerialNo)
					&& !StringUtils.equals(newSerialNo, tempSerialNo)
					&& !StringUtils.equals(oldSerialNo, newSerialNo)
					&& !StringUtils.equals(flag, FossConstants.NO)) {
				//合并前流水号
				List<String> beforeMerge = new ArrayList<String>();
				//合并后流水号
				List<String> afterMerge = new ArrayList<String>();
				// int counter = 0;
				afterMerge.add(newSerialNo);
				for (int j = 0; j < mergeList.size(); j++) {
					//新路上号
					String nSerialNo = mergeList.get(j).getNewSerialNo();
					//原流水号
					String oSerialNo = mergeList.get(j).getOldSerialNo();
					if (StringUtils.equals(newSerialNo, nSerialNo)) {
						beforeMerge.add(oSerialNo);
						mergeList.get(j).setFlag(FossConstants.NO);
					}
				}
				//调用走货路径接口
				calculateTransportPathService.packing(waybillNo,
						packingOrgCode, beforeMerge, afterMerge);
			}
		}
		//返回成功
		return FossConstants.SUCCESS;
	}

	/**
	 * 获取打印新标签流水号
	 * 
	 * @param waybillNo
	 *            运单号
	 * @return List<SerialRelationEntity> 新标签
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-25 上午11:42:28
	 * @see com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService#queryNewSerialNo(java.lang.String)
	 */
	@Override
	public QueryPackedDto queryNewSerialNo(String waybillNo) {

		//String[] Enum = packing.values();
		List<SerialRelationEntity> serialRelationList=new ArrayList<SerialRelationEntity>();
		for(int j=0;j<packing.values().length;j++){
			serialRelationList.addAll(queryPackedDao
					.querySerialRelation(waybillNo,packing.values()[j].getValue()));
		}
		
		// 封装所有查询结果的dto
		QueryPackedDto qpDto = new QueryPackedDto();
		Set<String> serialRelationSet = new HashSet<String>();
		// 遍历查询结果集
		for (int i = 0; i < serialRelationList.size(); i++) {
			SerialRelationEntity serialRelationEntity = (SerialRelationEntity) serialRelationList
					.get(i);
			//新流水号
			String newSerialNo = serialRelationEntity.getNewSerialNo();
			//新流水号是否为空
			if (!StringUtils.isEmpty(newSerialNo)) {
				serialRelationSet.add(serialRelationEntity.getNewSerialNo());
			}
		}
		qpDto.setSerialRelationList(serialRelationList);
		// 将set转为list
		Iterator<String> iterator = serialRelationSet.iterator();
		//新流水号集合
		List<SerialRelationEntity> newSerialRelationList = new ArrayList<SerialRelationEntity>();
		while (iterator.hasNext()) {
			//新流水号对象
			SerialRelationEntity serialRelationEntity = new SerialRelationEntity();
			//设置新流水号
			serialRelationEntity.setNewSerialNo(iterator.next().toString());
			//添加到集合中
			newSerialRelationList.add(serialRelationEntity);
		}
		// 增加新流水号列表到list
		qpDto.setNewSerialRelationList(newSerialRelationList);
		return qpDto;
	}

	/**
	 * 获取最大分页数
	 * 
	 * @param queryPackedConditionEntity
	 *            查询条件
	 * @return 总个数
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-19 上午8:26:41
	 * @see com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService#queryTotalCount(com.deppon.foss.module.transfer.packaging.api.shared.domain.QueryPackedConditionEntity)
	 */
	@Override
	public Long queryTotalCount(
			QueryPackedConditionEntity queryPackedConditionEntity) {
		// 获取处理后的查询条件
		QueryPackedConditionEntity newQueryPackedConditionEntity = obtainQueryPackedCondition(queryPackedConditionEntity);
		//返回符合条件的总数
		return queryPackedDao.queryTotalCount(newQueryPackedConditionEntity);
	}

	/**
	 * 整合处理查询条件
	 * 
	 * @param queryPackedConditionEntity
	 *            查询条件
	 * @return QueryPackedConditionEntity 处理后的查询条件
	 * @author 046130-foss-xuduowei
	 * @date 2012-10-29 上午10:21:48 
	 */
	private QueryPackedConditionEntity obtainQueryPackedCondition(
			QueryPackedConditionEntity queryPackedConditionEntity) {
		// 运单号
		queryPackedConditionEntity.setWayBillNumber(queryPackedConditionEntity
				.getWayBillNumber().trim());
		// 包装部门
		queryPackedConditionEntity.setPackedDept(queryPackedConditionEntity
				.getPackedDept().trim());
		//货区列表
		List<GoodsAreaEntity> areaList = goodsAreaService
				.queryGoodsAreaListByType(queryPackedConditionEntity
						.getPackedDept().trim(),
						DictionaryValueConstants.BSE_GOODSAREA_TYPE_PACKING);
		if (areaList.size() == 0) {
			throw new PackagingException("你所处的外场无打木架货区");
		}
		// 查找该包装部门的打木架货区
		GoodsAreaEntity goodsArea = areaList.get(0);
		//判断货区是否为空
		if (goodsArea == null) {
			throw new PackagingException("你所处的外场无打木架货区");
		}
		// 设置包装货区code
		queryPackedConditionEntity.setAreaCode(goodsArea.getGoodsAreaCode());
		String wayBillNumber = queryPackedConditionEntity.getWayBillNumber();
		// 当运单号不为空时，忽略开单部门和包装时间查询条件；
		if (!StringUtils.isEmpty(wayBillNumber)) {
			//设置开单部门为空
			queryPackedConditionEntity.setWaybillCreateDept(null);
			//设置包装开始时间为空
			queryPackedConditionEntity.setPackedBeginDate(null);
			//设置包装结束时间为空
			queryPackedConditionEntity.setPackedEndDate(null);
		}
		return queryPackedConditionEntity;
	}

	/**
	 * 打印新流水号
	 * 
	 * @param waybillNo
	 *            运单号
	 * @param serialRelationList
	 *            流水号列表
	 * @author 046130-foss-xuduowei
	 * @date 2012-11-6 下午2:16:16
	 * @see com.deppon.foss.module.transfer.packaging.api.server.service.IQueryPackedService#printNewSerialNo(java.lang.String,
	 *      java.util.List)
	 */

	@Override
	public List<BarcodePrintLabelDto> printNewSerialNo(String waybillNo,
			List<SerialRelationEntity> serialRelationList) {
		// 需要打印的新流水号
		List<String> serialNoList = new ArrayList<String>();
		if (serialRelationList.size() == 0) {
			throw new PackagingException("流水号为空");
		}
		//遍历流水号列表
		for (int i = 0; i < serialRelationList.size(); i++) {
			serialNoList.add(((SerialRelationEntity) serialRelationList.get(i))
					.getNewSerialNo());
		}
		/**
		 * 调用接送货接口获取打印标签的数据
		 * 
		 */
		try {
			//调用接送货接口获取打印数据，中转的流水号
			List<BarcodePrintLabelDto> barcodePrintDtoList = labelPrintInfoService.getLabelPrintInfoForDepart(waybillNo,serialNoList);
			
			//打印数据是否为空
			if(barcodePrintDtoList == null || barcodePrintDtoList.isEmpty()){
				throw new PackagingException("运单打印数据为空");
			}
			//返回打印数据集合
			return barcodePrintDtoList;
		} catch (BusinessException e) {
			//获取业务异常
			throw new PackagingException(e.getErrorCode());
		} catch(NullPointerException e){
			//空指针异常
			throw new PackagingException("运单相关打印数据不全");
		}

	}

	/** 
	 * 获取当前登录人组织信息
	 * 
	 * @author 046130-foss-xuduowei
	 * @date 2012-11-26 下午8:01:34
	 */
	@Override
	public CurrentDeptDto queryCurrentDept() {
		CurrentDeptDto deptDto = new CurrentDeptDto();
		// 当前操作部门
		List<String> bizTypes = new ArrayList<String>();
		// 设置外场类型
		bizTypes.add(BizTypeConstants.ORG_TRANSFER_CENTER);
		//当前登录人信息
		OrgAdministrativeInfoEntity activeDeptInfo = FossUserContext
				.getCurrentDept();
		//原始部门信息
		OrgAdministrativeInfoEntity org = orgAdministrativeInfoComplexService
				.queryOrgAdministrativeInfoByCode(activeDeptInfo.getCode(),
						bizTypes);
		//如果不为空，则进行返回值设置
		if (org != null) {
			//组织编码
			deptDto.setDeptCode(org.getCode());
			//组织名称
			deptDto.setDeptName(org.getName());
			return deptDto;
		} else {
			throw new PackagingException("当前登录人无操作部门");
		}
	}
	
	/** 
	 * 导出已包装信息到excel
	 * 
	 * @author 046130-foss-xuduowei
	 * @date 2013-03-23 下午8:01:34
	 */
	@Override
	public InputStream exportExcelStream(
			QueryPackedConditionEntity queryPackedConditionEntity) {
		//输出流
		InputStream excelStream = null; 
		//excel表头信息
		SheetData sheetData = new SheetData();
		String[] rowHeads = null;
		rowHeads = PackagingConstants.PACKAGING_EXPORT_PACKED_HEADER;
		sheetData.setRowHeads(rowHeads);
		//根据条查询需要导出的集合
		List<QueryPackedResultEntity> packedList = queryPackedDao.queryPackedAll(obtainQueryPackedCondition(queryPackedConditionEntity));
		//包装材料集合对象
		List<DataDictionaryValueEntity> materialList = 
				dataDictionaryValueService.queryDataDictionaryValueByTermsCode(
						DictionaryConstants.PACKAGING_PACKED_MATERIAL);
		if(materialList == null || materialList.isEmpty()){
			throw new PackagingException("未找到货物材料数据字典");
		}
		//新增状态map
		Map<String,Object> statusMap = new HashMap<String,Object>();
		//设置到map中，在导出时根据code从map中取name
		for(DataDictionaryValueEntity dataDict : materialList){
			statusMap.put(dataDict.getValueCode(), dataDict.getValueName());
		}
		//时间格式
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		//excel列表
		List<List<String>> excelList = new ArrayList<List<String>>();
		List<String> tempList = null;
		//"运单号","包装时间","开单部门","是否在包装区","包装部门","货物名称",
		//"开单件数","包装件数","加托个数","包装材料","包装体积","包装人","创建人","修改人","登入包装货区时间","登出包装货区时间","包装需求",
		//"备注","原流水号","新流水号","运输性质","开单体积","需要包装体积"
		
		//获取配置参数
		Double packageVolume = this.goodsPackingVolume(queryPackedConditionEntity.getPackedDept());
		
		for(QueryPackedResultEntity queryPackedResultEntity : packedList){
			tempList = new ArrayList<String>();
			//运单号
			tempList.add(queryPackedResultEntity.getWayBillNumber());
			//包装时间
			if(queryPackedResultEntity.getPackedDate() !=null){
				tempList.add(df.format(queryPackedResultEntity.getPackedDate()));
			}else{
				tempList.add("");
			}
			//开单部门
			tempList.add(queryPackedResultEntity.getWaybillCreateDept());
			//是否在包装区
			tempList.add(queryPackedResultEntity.getIsInPackageArea());
			//包装部门
			tempList.add(queryPackedResultEntity.getPackedDept());
			//货物名称
			tempList.add(queryPackedResultEntity.getGoodsName());
			//开单件数
			tempList.add(queryPackedResultEntity.getWaybillNum() + "");
			//包装件数
			tempList.add(queryPackedResultEntity.getPackedNum() + "");
			//加托个数
			tempList.add(queryPackedResultEntity.getPlusNum() + "");
			//包装材料
			tempList.add(statusMap.get(queryPackedResultEntity.getPackedMate()).toString());
			//包装体积
			tempList.add(queryPackedResultEntity.getPackedVolume().toString());
			//包装人
			tempList.add(queryPackedResultEntity.getPackedPerson());
			//创建人
			tempList.add(queryPackedResultEntity.getCreateUser());
			//修改人
			tempList.add(queryPackedResultEntity.getModifyUser());
			//登入包装货区时间
			if(queryPackedResultEntity.getLoginDate() != null){
				tempList.add(df.format(queryPackedResultEntity.getLoginDate()));
			}else{
				tempList.add("");
			}
			
			//登出包装货区时间
			if(queryPackedResultEntity.getLogoutDate() != null){
				tempList.add(df.format(queryPackedResultEntity.getLogoutDate()));
			}else{
				tempList.add("");
			}
			//包装需求
			tempList.add(queryPackedResultEntity.getPackRequire());
			//备注
			tempList.add(queryPackedResultEntity.getNotes());
			//原流水号
			tempList.add(queryPackedResultEntity.getOldSerialNo());
			//新流水号
			tempList.add(queryPackedResultEntity.getNewSerialNo());
			//运输性质
			tempList.add(queryPackedResultEntity.getProductName());
			//开单体积
			tempList.add(String.valueOf(queryPackedResultEntity.getGoodsVolumeTotal()));
			//需要包装体积
			if (null != queryPackedResultEntity.getPackageVolume()) {
				BigDecimal packageVolumeTemp= new BigDecimal(queryPackedResultEntity.getPackageVolume().doubleValue()/packageVolume);
				tempList.add(packageVolumeTemp.setScale(PackagingConstants.SONAR_NUMBER_3, RoundingMode.HALF_DOWN)+ "");
			} else {
				tempList.add("");
			}
			
			//加入到显示集合中
			excelList.add(tempList);
		}
		
		sheetData.setRowList(excelList);
		ExcelExport excelExportUtil = new ExcelExport();
		// 导出成文件
		excelStream = excelExportUtil.inputToClient(excelExportUtil.exportExcel(
				sheetData,"已包装",PackagingConstants.PACKAGING_EXPORT_FILE_SIZE));
		return excelStream;
	}
	
	
	/**
	 * 
	 * 将成功打印的流水号记录到数据库中
	 * @author 046130-foss-xuduowei
	 * @date 2013-06-29 下午8:01:34
	 */
	@Override
	public int insertLabelRecord(String waybillNo, String serialNo) {
		
		try {
			PrintLabelEntity printLabelEntity = new PrintLabelEntity();
			printLabelEntity.setWaybillNo(waybillNo);
			printLabelEntity.setSerialNo(serialNo);
			printLabelEntity.setPrintTime(new Date());
			printLabelEntity.setPrintUserCode(FossUserContext.getCurrentUser().getEmployee().getEmpCode());
			printLabelEntity.setPrintUserName(FossUserContext.getCurrentUser().getEmployee().getEmpName());
			printLabelService.addPrintLabel(printLabelEntity);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
		}
		return 0;
	}

	/**
	 * set,get方法
	 */

	public void setQueryPackedDao(IQueryPackedDao queryPackedDao) {
		this.queryPackedDao = queryPackedDao;
	}

	/**
	 * 设置 接送货新增、修改流水号接口.
	 * 
	 * @param labeledGoodService
	 *            the new 接送货新增、修改流水号接口
	 */
	public void setLabeledGoodService(ILabeledGoodService labeledGoodService) {
		this.labeledGoodService = labeledGoodService;
	}

	/**
	 * 设置 库存接口.
	 * 
	 * @param stockService
	 *            the new 库存接口
	 */
	public void setStockService(IStockService stockService) {
		this.stockService = stockService;
	}

	/**
	 * 
	 * 
	 * @param labelPrintInfoService
	 */
	public void setLabelPrintInfoService(
			ILabelPrintInfoService labelPrintInfoService) {
		this.labelPrintInfoService = labelPrintInfoService;
	}

	/**
	 * 设置 获取指定部门接口.
	 * 
	 * @param orgAdministrativeInfoComplexService
	 *            the new 获取指定部门接口
	 */
	public void setOrgAdministrativeInfoComplexService(
			IOrgAdministrativeInfoComplexService orgAdministrativeInfoComplexService) {
		this.orgAdministrativeInfoComplexService = orgAdministrativeInfoComplexService;
	}

	/**
	 * 设置 综合货区接口.
	 * 
	 * @param goodsAreaService
	 *            the new 综合货区接口
	 */
	public void setGoodsAreaService(IGoodsAreaService goodsAreaService) {
		this.goodsAreaService = goodsAreaService;
	}

	/**
	 * 设置 走货路径接口.
	 * 
	 * @param calculateTransportPathService
	 *            the new 走货路径接口
	 */
	public void setCalculateTransportPathService(
			ICalculateTransportPathService calculateTransportPathService) {
		this.calculateTransportPathService = calculateTransportPathService;
	}

	/**
	 * 设置 接送货修改运单件数接口.
	 *
	 * @param waybillManagerService the new 接送货修改运单件数接口
	 */
	public void setWaybillManagerService(
			IWaybillManagerService waybillManagerService) {
		this.waybillManagerService = waybillManagerService;
	}

	public void setDataDictionaryValueService(
			IDataDictionaryValueService dataDictionaryValueService) {
		this.dataDictionaryValueService = dataDictionaryValueService;
	}

	public void setPrintLabelService(IPrintLabelService printLabelService) {
		this.printLabelService = printLabelService;
	}
	
	public void setConfigurationParamsService(
			IConfigurationParamsService configurationParamsService) {
		this.configurationParamsService = configurationParamsService;
	}

	public IPackOutDao getPackOutDao() {
		return packOutDao;
	}

	public void setPackOutDao(IPackOutDao packOutDao) {
		this.packOutDao = packOutDao;
	}

	
	public void setPackCommonService(IPackCommonService packCommonService) {
		this.packCommonService = packCommonService;
	}

	public static void setLOGGER(Logger lOGGER) {
		LOGGER = lOGGER;
	}

	/**
	 * @author niuly
	 * @date 2014-1-20上午8:48:12
	 * @function 根据查询条件查询本部门包装的货物信息（为接送货提供的接口）
	 * @param queryPackedConditionEntity
	 * @return
	 */
	@Override
	public List<QueryPackedResultEntity> queryPackedAllInfo(QueryPackedConditionEntity queryPackedConditionEntity) {
		// 得到查询结果
		List<QueryPackedResultEntity> queryPackedResultList = queryPackedDao.queryPackedAllInfo(queryPackedConditionEntity);		
		return queryPackedResultList;
	}
	
	/*
	 * @desc 在代包装信息录入完成后，进行检验，若符合以下条件，则调用接送货接口生成待办事项（参考RULE-A2）：
     *1、开单件数<=30且开单件数>代打包装件数（非全包装）
     *2、提货方式为送货（包含送货上楼/送货（不含上楼）/送货进仓/免费送货）
     *3、货物需要打木架，且有合打记录
     *4、包装后货物总件数<开单件数的运单（有合打）
     *5、系统后台生成一条更改记录，更改明细为件数变更；
     *6、生成待办事项，待办类型为更改单标签重打，需要打标签的货物为未打包装的货物（通过开单时标记的流水号区分）
	 *@ author foss-105795-wqh
	 *@ date  2014-04-10
	 * */
	@SuppressWarnings("unused")
	private void unpackByAllBringTodo(List<SerialRelationEntity> serialRelationList,String waybillNo,
			String unPackType,WaybillEntity waybillEntity){
		//当前外场组织
		OrgAdministrativeInfoEntity orgOutField=getOutFieldCode();
		//旧流水号集合
		Set<String> oldSeriaSet=new HashSet<String>();
		//新流水号集合
		Set<String> newSeriaSet=new HashSet<String>();
		//需要生成代办的流水号集合
		List<String> toDoSeriaList;
		
		//获取原来流水号集合与新流水号
		for(int i=0;i<serialRelationList.size();i++){
			
			oldSeriaSet.add(serialRelationList.get(i).getOldSerialNo());
			newSeriaSet.add(serialRelationList.get(i).getNewSerialNo());
		}
		//所有的送货方式
		List<String> deliverWayList=new ArrayList<String>();
		
		/*初始化送货方式*/
		//汽运送货(不含上楼)
		deliverWayList.add(WaybillConstants.DELIVER_NOUP);
		//汽运免费派送
		deliverWayList.add(WaybillConstants.DELIVER_FREE);
		//汽运送货进仓
		deliverWayList.add(WaybillConstants.DELIVER_STORAGE);
		//汽运送货（上楼）
		deliverWayList.add(WaybillConstants.DELIVER_UP);
		
		//
		//判断提货方式为送货
		boolean isDeliver=false;
		if(deliverWayList.contains(waybillEntity.getReceiveMethod()))
		{
			isDeliver=true;
		}
		
		//获取开单件数
		int goodsTotalQty=waybillEntity.getGoodsQtyTotal();
		//是否合打，根据旧流水号件数大于新流水号件数
		boolean isJoinPacked=false;
		if(oldSeriaSet.size()>newSeriaSet.size())
		{
			isJoinPacked=true;
		}
		//获取包装需求中需要打包的件数
		int rePackQty=0;
		QueryWaybillPackEntity waybillPackEntity=
				packCommonService.queryRePackByWaybillNo(waybillNo, orgOutField.getCode());
		if(waybillPackEntity!=null){
			rePackQty=Integer.parseInt(waybillPackEntity.getPackedNum());
		}
		//包装后运单总件数
		int packedTotalQty=0;
		if(waybillPackEntity!=null){
			packedTotalQty=Integer.parseInt(waybillPackEntity.getWaybillNum());
		}		
		
		CurrentInfo currentInfo=FossUserContext.getCurrentInfo();
		//该运单原来不需要打包的件数 总件数-需打包装件数
		int unReUnpackQty=goodsTotalQty-rePackQty; 
		/*
		 * 满足以下条件，调用接送代办接口：
		 *1、开单件数<=30且开单件数>代打包装件数（非全包装）
         *2、提货方式为送货（包含送货上楼/送货（不含上楼）/送货进仓/免费送货）
         *3、货物需要打木架，且有合打记录
         *4、包装后货物总件数<开单件数的运单（有合打）
		 * */
	    if(goodsTotalQty<=PackagingConstants.PACKAGE_BILL_GOODSQTY
	    		&&goodsTotalQty>rePackQty
	    		&&isDeliver
	    		&&isJoinPacked
	    		&&newSeriaSet.size()<goodsTotalQty)
	    {
	    	//获取当前用户及部门信息
	    	OrgAdministrativeInfoEntity org=getOutFieldCode();
	    	//包装NeedCreateTodoDto ,提供给接送货
	    	NeedCreateTodoDto needToDo=new NeedCreateTodoDto();
	    	//运单号
	    	needToDo.setWaybillNo(waybillNo);
	    	//获取需生成代办的流水号
			List<String> toDoList=
					packCommonService.queryToDoSeriasByWaybillNo(waybillNo,orgOutField.getCode());
			//将单独包装的流水号去掉
			for(int i=0;i<serialRelationList.size();i++){
				
				if(toDoList.contains(serialRelationList.get(i).getNewSerialNo()))
				{
					toDoList.remove(serialRelationList.get(i).getNewSerialNo());
				}
			}
	    	//需要生成待办的流水号集合
	    	needToDo.setNeedCreateSerialList(toDoList);
	    	//用户所在部门编码
	    	needToDo.setUserOrgCode(orgOutField.getCode());
	    	//用户所在部门名称
	    	needToDo.setUserOrgName(org.getName());
	    	//用户编码
	    	needToDo.setUserCode(currentInfo.getEmpCode());
	    	//用户姓名
	    	needToDo.setUserName(currentInfo.getEmpName());
	    	//修改运单对应的件数
	    	needToDo.setNewGoodNum(packedTotalQty);
	    	//运单原来的件数
	    	needToDo.setOldGoodNum(goodsTotalQty);
	    	try {
				
	    		waybillManagerService.createNotAllPackageTodo(needToDo);
			} catch (BusinessException e) {
				throw new TfrBusinessException("调用接送货接口出错,错误信息：{"+e.getErrorCode()+"}");
			}
	    }
	}
	/*
	 * @desc 获取当前外场部门的code
	 * @author foss-105795-wqh
	 * @param 
	 * @ date 2014-04-11
	 * 
	 * */
    private OrgAdministrativeInfoEntity getOutFieldCode(){
		// 当前操作部门
		List<String> bizTypes = new ArrayList<String>();
		// 设置外场类型
		bizTypes.add(BizTypeConstants.ORG_TRANSFER_CENTER);
		OrgAdministrativeInfoEntity activeDeptInfo = FossUserContext
				.getCurrentDept();
		//组织对象
		OrgAdministrativeInfoEntity org = orgAdministrativeInfoComplexService
					.queryOrgAdministrativeInfoByCode(activeDeptInfo.getCode(),
							bizTypes);
	   if(org==null)
	   {
		   throw new TfrBusinessException("当前部门不存在");
		   
	   }
	   return org;
     }

	public void setWaybillPackBIService(IWaybillPackBIService waybillPackBIService) {
		this.waybillPackBIService = waybillPackBIService;
	}
	
}