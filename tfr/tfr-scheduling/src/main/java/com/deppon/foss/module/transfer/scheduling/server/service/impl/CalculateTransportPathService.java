/**
 *  initial comments.
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *    
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 ** 
 * 计算并调整走货路径
 * 
 * 1.1	相关业务用例
 * 
 * BUC_FOSS_5.30.10_110上报异常库存
 * 
 * 
 * 
 * 1.2	用例描述
 * 
 * 理货员卸车结束之后，
 * 
 * 提交卸车任务，
 * 
 * 系统比对上一装车环节生成的交接单，
 * 
 * 然后在比对上一装车环节扫描纪录，最终生成差异性报告并上报。
 * 
 * 差异信息包含多货、少货两种情况，
 * 
 * 供相关人员核对和后续处理。
 * 
 * 一旦出现多货,
 * 
 * 多出货物将需要重新安排走货路径.
 * 
 * 本用例会针对货物信息,
 * 
 * 计算新的走货路径并顶替之前的路径.
 * 
 * 接送货开单时,
 * 
 * 会针对该批货物的开单信息,
 * 
 * 生成走货路径.
 * 
 * 保存到开单信息中.
 * 
 * 走货路径查询&修改时,
 * 
 * 会针对一批货物进行人工的调整其走货路径,
 * 
 * 新建保存.
 * 
 * 合车调整修改货物走货路径后,
 * 
 * 在货物出库最终确定选择路径时,
 * 
 * 需要生成新的走货路径并对原路径进行修改替换.
 * 
 * PDA扫描货物后,
 * 
 * 将会把货物的走货路径中没有使用的条目删除.
 * 
 * 确定一批货的唯一走货路径.
 * 
 * 入库时,如本货物路径处于被调整路段,
 * 
 * 切调整处于生效阶段,
 * 
 * 则需要按照调整后的路径进行该货物的走货路径修改.
 * 
 * 修改单生成并且生效后(处理待办事项,打印新标签),
 * 
 * 按照货物的修改目的地,
 * 
 * 重新计算,
 * 
 * 修改货物的走货路径.
 * 
 * 
 * 
 * 1.3	用例条件
 * 
 * 
 * 前置条件	1.	开单时,需要针对货物确定走货路径. 
 * 
 * 或
 * 
 * 
 * 2.	出现异常库存时,需要针对异常货重新修订走货路径.
 * 
 * 
 * 
 * 或
 * 
 * 
 * 3.	调整合车走货路径后,根据出库时的实际情况生成新的走货路径,替换货物原路径.
 * 
 * 
 * 或
 * 
 * 
 * 4.	入库时,如果当前货物的原路径处于路径调整的生效状态,则对该货物的走货路径进行调整.
 * 
 * 
 * 或
 * 
 * 
 * 
 * 5.	修改单生成且生效后,按照货物的新目的地,重新计算并生成走货路径.	接送货-开单
 * 
 * 
 * 
 * 
 *上报异常库存
 *
 *
 *查询&修改走货路
 *
 *
 *后置条件	
 *
 *1.	生成新的走货路径.	
 *
 *查询&修改走货路径
 *
 *
 *1.6	操作步骤
 *
 *
 *1.6.1	开单生成走货路径
 *
 *1	开单模块请求系统计算走货路经，
 *
 *系统根据货物的开单信息,获取货物运单号,
 *
 *流水号,出发营业部,到达营业部，
 *
 *开单时间.	开单信息	
 *
 *
 *
 *2	系统通过开单信息查询基础信息的走货路经模板,
 *
 *传递参数为：出发,到达营业部/虚拟营业部、开单时间	走货路径模板配置.	
 *
 *配置以营业部为单元,
 *
 *根据出发到达营业部,
 *
 *返回走货路径模板，
 *
 *内容包括：整条路径中的全部线路节点、中转场间的线路、以及每段线路的出发到达时间.
 *
 *
 *
 *3	系统根据出发营业部,
 *
 *走货路径模板上的第一个中转外场,
 *
 *查询线路信息，
 *
 *查询走货路径中第一条线路.
 *
 *系统根据走货路径模板上的最后一个中转外场,
 *
 *到达营业部,
 *
 *查询线路信息, 
 *
 *查询走货路径中最后一条线路.	
 *
 *线路	基础资料提供的是营业组到营业组的走货路径模版,
 *
 * 是按照出发组、
 * 
 * 到达组制定走货路径模板的.
 * 
 * 所以始发营业部到第一个中转部门,
 * 
 * 最后一个中转部门到到达营业部的线路未确定.
 * 
 * 根据走货路径模版中提供的通用出发到达时间,
 * 
 * 匹配该段最终选择的线路。
 *
 *
 *4	系统保存完整的走货路径信息，
 *
 *并反馈给开单模块		
 *
 *系统返回走货路径结果给开单信息模块
 *
 *
 *
 *1.6.2	多货修改走货路径
 *
 *
 *1	系统根据多货的货物信息,
 *
 *获取货物运单号,
 *
 *流水号,
 *
 *到达营业部/虚拟营业部.	
 *
 *开单信息	
 *
 *
 *2	系统根据该货物现在所在的中转外场,
 *
 *获取中转场的驻地营业部信息.		
 *
 *多货则该货物本不该出现在该中转场,
 *
 *但是现在已经到达,
 *
 *则需要改变走货路径,
 *
 *以目前位置为起点,到达营业部为终点,
 *
 *重新确定走货路径.
 *
 *
 *
 *3	执行1.6.1的步骤		
 *
 *
 *4	保存新的走货路径,
 *
 *作废原货物走货路径		
 *
 *
 *
 *1.6.3	调整合车货物走货路径A(同一外场合车)
 *
 *
 *1	外场操作员根据需要,
 *
 *提出合车,
 *
 *人工调整中途经过的外场以及线路.		
 *
 *根据该外场,
 *
 *搜索出相应货物的原路径.
 *
 *参考用例”调整合车货物走货路经”
 *
 *
 *
 *2	系统接受多条线路合并的修改走货路径信息.		
 *
 *调整页面可能会将线路A,B 
 *
 *合并至线路C进行统一调配.
 *
 *
 *
 *3	系统将全部被调整线路进行记录		
 *
 *此时不修改货物的实际走货路径.
 *
 *只记录合车调整的动作.
 *
 *
 *
 *4	当有合车操作的货物实际出库装车时,
 *
 *根据实际所选择的路径,
 *
 *记录货物真实走货路径,
 *
 *和系统中的原路径匹配,
 *
 *进行更新和再计算.		
 *
 *此时更新原路径为实际所选择路径,更新后序走货路径.
 *
 *
 *
 *
 *
 *1.6.4	
 *
 *调整合车货物走货路径B(针对某一段路径进行调整不同外场之间合车)
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	外场操作员根据需要,
 *
 *提出合车调整,
 *
 *人工调整中途经过的外场以及线路.	
 *
 *	参考用例”调整合车货物走货路经”
 *
 *人工调整的路径可以是走货路径模板之外的走货方式
 *
 *
 *2	可以选择多个外场和外场之间的线路，重复1步骤		
 *
 *
 *3	系统根据指定的最后一个到达地点及货物的最终到达地点.
 *
 *生成新的走货路径		
 *
 *原货由A-B-C-D,
 *
 *现在人工改为A-E-F,
 *
 *人工指定的最后中转站为F.
 *
 *则系统需要生成F-D的子走货路径.
 *
 *
 *4			以目前位置为起点,到达营业部为终点,重新确定走货路
 *
 *
 *5	执行1.6.1的步骤		
 *
 *
 *6	系统保存新增的走货路径.		
 *
 *目前对于该货物有两条走货路径.替换该货物的原走货路径
 *
 *
 *7	装车后，
 *
 *按照实际装车所走的路径保留最终的走货路径,
 *
 *并且系统作废两条路径中无效的条目.
 *
 *确定唯一走货路径.		
 *
 *操作员对该批货物进行装车扫描时,会调用接口回传最终选择路径,系统根据实际的选择, 作废无效条目.确定该批货物的唯一走货路径.
 *
 *1.6.5	更改单修改走货路径
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	更改单提出后,通过待办事项打印新的货物标签.		
 *
 *此时可能会修改货物的目的地信息
 *
 *
 *2	获取更改信息中的货物目的地,及货物现所在地信息.		
 *
 *货物在途中,则新标签会在下个货物停靠外场或营业部生效.货物所在地信息也使用该外场或营业部.
 *
 *
 *3	系统根据指定新目的地及所在地信息.
 *
 *生成后续的走货路径		
 *
 *
 *4	系统保存新增的走货路径.		
 *
 *替换该货物的原走货路径中未走的部分线路.
 *
 *
 *
 *
 *
 *1.7	业务规则
 *
 *SR-1	
 *
 *所有外场都有其驻地营业部,所以出发或到达地为外场的,将自动转化为该驻地营业部.
 *
 *
 *
 *
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 * 1.	SUC-748 重新计算走货路径
 * 
 * 1.1	相关业务用例
 * 
 * 
 * BUC_FOSS_5.30.10_110上报异常库存
 * 
 * 1.2	用例描述
 * 
 * 在开单时,有可能因为路线和走货路径的配置不全等原因,导致系统自动计算的货物走货路径不对或没有计算成功.这时则需要针对所有走货路径缺失的运单,进行重新计算走货路径操作.
 * 
 * 1.3	用例条件
 * 
 * 条件类型	描述	引用用例
 * 
 * 前置条件
 * 
 * 
 * 	调度员需要对现有货物的走货路径进行重新生成.	
 * 
 * 
 * 后置条件	
 * 
 * 
 * 该货物生成新的走货路径	
 *  
 *  
 *  
 *  
 *  1.5.3	界面描述
 *  
 *  
 *  进入后,
 *  
 *  默认显示全部走货路径为空的运单列表.
 *  
 *  可以根据运单号查询运单相关信息.
 *  
 *  运单号可以多选,
 *  
 *  进行计算路径操作,
 *  
 *  针对选中条目重新计算走货路径.
 *  
 *  计算后,
 *  
 *  刷新页面.
 *  
 *  按照规则重新加载路经为空的运单列表.
 *  
 *  1.5.4	按钮描述
 *  
 *  
 *  查询: 
 *  
 *  
 *  根据输入的运单号进行查询.
 *  
 *  
 *  重置: 
 *  
 *  
 *  清空输入的运单号.
 *  
 *  
 *  计算路径: 
 *  
 *  
 *  将选中的运单进行走货路径重新计算.
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  
 *  序号	基本步骤	相关数据	补充步骤
 *  
 *  
 *  1	操作员根据运单号搜索出需要调整的运单信息		
 *  
 *  
 *  默认显示全部走货路径为空的运单信息
 *  
 *  
 *  2	操作员选择待修改运单(可多选),
 *  
 *  
 *  点击计算路径按钮.		
 *  
 *  
 *  3	系统根据运单信息,进行走货路径的再计算		
 *  
 *  调用”计算并调整走货路径”用例,进行运单的路径计算.
 *  
 *  
 * 4	保存重新计算后各运单新生成的走货路径		
 * 
 * 
 * 5	系统计算后刷新走货路径列.		成功则显示新走货路经
 * 
 * 序号	扩展事件/异常事件	备注
 * 
 * 
 * 5a	仍然计算不出走货路径的	依旧未成功则显示:由于走货路径基础数据配置不全，无法计算.
 * 
 * 
 * 1.7	业务规则
 * 
 * 
 * 序号	描述
 * 
 * 
 * SR-1	可以针对有走货路径的运单进行搜索,之后重新进行路径计算.
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  1.8	数据元素
 *  
 *  字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 *  
 *  
 *  运单号	货物运单号					订单信息
 *  
 *  
 *  件数	该运单包含的货物件数					订单信息
 *  
 *  重量	运单重量					订单信息
 *  
 *  体积	运单体积					订单信息
 *  
 *  开单部门	开单部门					
 *  
 *  到达部门	到达部门					
 *  
 *  运输性质	精准卡行/城运/普货/偏线					开单信息
 *  
 *  开单时间	开单时间					
 *  
 *  走货路径	该运单的走货路经					走货路径信息
 *  
 *  
 *  
 *  
 *  1.9	非功能性需求
 *  
 *  单位时间使用量	每天处理次小于300次
 *  
 *  2012年全网估计用户数	操作员数量约100名
 *  
 *  响应要求（如果与全系统要求 不一致的话）	响应速度为每票3秒 , 多票则是3*N秒
 *  
 *  使用时间段	中转外场上班时间，分为：白班和晚班
 *  
 *  高峰使用时间段	22:00-8:00
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 */
/*******************************************************************************
 * Copyright 2013 TFR TEAM
 *  
 *  
 *  
 *  Licensed under the DEPPON License, Version 2.0 (the "License");
 *  
 *  
 *  you may not use this file except in compliance with the License.
 *  
 *  
 *  You may obtain a copy of the License at
 *  
 *     http://www.deppon.com/licenses/LICENSE-2.0
 *  
 *  
 *  
 *  Unless required by applicable law or agreed to in writing, software
 * 
 *  distributed under the License is distributed on an "AS IS" BASIS,
 * 
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  
 *  limitations under the License.
 *  
 *  PROJECT NAME  : tfr-scheduling
 *  
 *  PACKAGE NAME  : 
 * 
 *  DESCRIPTION   : 调度、发车计划、排班、月台、车辆管理等
 *  
 *  FILE PATH     :src/main/java/com/deppon/foss/module/transfer/scheduling/server/service/impl/CalculateTransportPathService.java
 * 
 *  FILE NAME     :CalculateTransportPathService.java
 *  
 *  AUTHOR        : FOSS中转开发组
 *  
 *  TIME          : 
 *  
 *  HOME PAGE     :  http://www.deppon.com
 *  
 *  COPYRIGHT     : Copyright (c) 2013  Deppon All Rights Reserved.
 * 
 *  VERSION       :0.1
 * 
 *  LAST MODIFY TIME:
 ******************************************************************************/
package com.deppon.foss.module.transfer.scheduling.server.service.impl;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.deppon.foss.framework.exception.BusinessException;
import com.deppon.foss.framework.shared.util.classes.BeanUtils;
import com.deppon.foss.framework.shared.util.string.StringUtil;
import com.deppon.foss.module.base.baseinfo.api.server.service.IBillingGroupTransFerService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IFreightRouteService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ILineService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IOrgAdministrativeInfoService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ISaleDepartmentService;
import com.deppon.foss.module.base.baseinfo.api.server.service.commonselector.ICommonOrgService;
import com.deppon.foss.module.base.baseinfo.api.server.service.complex.ILoadAndUnloadEfficiencyVehicleComplexService;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.BillingGroupTransFerEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.OrgAdministrativeInfoEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.SaleDepartmentEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.complex.LoadAndUnloadEfficiencyVehicleDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.DepartureStandardDto;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.FreightRouteLineDto;
import com.deppon.foss.module.base.dict.api.server.service.IConfigurationParamsService;
import com.deppon.foss.module.base.dict.api.shared.define.ConfigurationParamsConstants;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryConstants;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryValueConstants;
import com.deppon.foss.module.base.dict.api.shared.domain.ConfigurationParamsEntity;
import com.deppon.foss.module.frameworkimpl.server.context.FossUserContext;
import com.deppon.foss.module.pickup.waybill.api.server.service.IWaybillManagerService;
import com.deppon.foss.module.pickup.waybill.shared.domain.WaybillEntity;
import com.deppon.foss.module.transfer.common.api.server.service.ITfrCommonService;
import com.deppon.foss.module.transfer.common.api.shared.define.PricingConstants.ProductEntityConstants;
import com.deppon.foss.module.transfer.common.api.shared.domain.CreateErrorLogEntity;
import com.deppon.foss.module.transfer.common.api.shared.exception.TfrBusinessException;
import com.deppon.foss.module.transfer.load.api.server.service.IHandOverBillService;
import com.deppon.foss.module.transfer.scheduling.api.define.TransportPathConstants;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IChangePathDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IPathDetailDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.ITransportationPathDao;
import com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.ChangePathEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.PathDetailEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.TransportPathEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.dto.FeedbackDto;
import com.deppon.foss.module.transfer.scheduling.api.shared.dto.GeneralQueryDto;
import com.deppon.foss.module.transfer.scheduling.api.shared.util.ConstantsNumberSonar;
import com.deppon.foss.module.transfer.scheduling.api.shared.util.TimeUtils;
import com.deppon.foss.module.transfer.stock.api.define.StockConstants;
import com.deppon.foss.module.transfer.stock.api.server.service.IStockService;
import com.deppon.foss.module.transfer.stock.api.shared.domain.InOutStockEntity;
import com.deppon.foss.module.transfer.stock.api.shared.domain.StockEntity;
import com.deppon.foss.module.transfer.stock.api.shared.domain.WaybillStockEntity;
import com.deppon.foss.util.DateUtils;
import com.deppon.foss.util.UUIDUtils;
import com.deppon.foss.util.define.FossConstants;

/**
 * 计算&调整走货路径类
 * 
 * 
 * 
 * @author huyue
 * @date 2012-10-31 下午5:23:40
 */
public class CalculateTransportPathService implements ICalculateTransportPathService {
	/**
	 * 日志
	 */
	private static final Logger logger = LogManager.getLogger(CalculateTransportPathService.class);
	/**
	 * 空字符串
	 */
	private static final String BLANK_STRING = "";
	/**
	 * 空字符串(一个空格)
	 */
	private static final String BLANK_SPACE_STRING = " ";
	/**
	 * 字符串冒号(:)
	 */
	//未使用-352203
//	private static final String COLON_STRING = " : ";
	/**
	 * 字符串豆号(,)
	 */
//	private static final String COMMA_STRING = " , ";
	/**
	 * 走货路径dao
	 */
	private ITransportationPathDao transportationPathDao;
	/**
	 * 路径明细dao
	 */
	private IPathDetailDao pathDetailDao;
	/**
	 * 路径改变dao
	 */
	private IChangePathDao changePathDao;
	/**
	 * 反馈dto
	 */
	private FeedbackDto feedbackDto;
	/**
	 * 综合生成走货路径service
	 */
	private IFreightRouteService freightRouteService;
	/**
	 * 参数配置service
	 */
	private IConfigurationParamsService configurationParamsService;
	/**
	 * 装卸车工作效率service
	 */
	private ILoadAndUnloadEfficiencyVehicleComplexService loadAndUnloadEfficiencyVehicleComplexService;
	/**
	 * 组织相关service
	 */
	private IOrgAdministrativeInfoService orgAdministrativeInfoService;
	/**
	 * 库存service
	 */
	private IStockService stockService;
	/**
	 * 线路service
	 */
	private ILineService lineService;
	/**
	 * 公共组织service
	 */
	private ICommonOrgService commonOrgService;
	/**
	 * 常量
	 */
	private static final String queryFreightRouteBySourceTarget = "queryFreightRouteBySourceTarget";
	/**
	 * 常量
	 */
	private static final String origOrgCode = "出发部门编码";
	/**
	 * 常量
	 */
	private static final String destOrg = "到达部门编码";
	/**
	 * 常量
	 */
	private static final int sixtyThousand = 60000;
	/**
	 * 常量
	 */
	private static final int threeMillionSixHundredThousand = 3600000;
	
	// modify by liangfuxiang 2013-5-6下午4:21:21 begin BUG-8208
	private IWaybillManagerService waybillManagerService;
	
	/**
	 * 常量
	 */
	private ITfrCommonService tfrCommonService;

	public void setTfrCommonService(ITfrCommonService tfrCommonService) {
		this.tfrCommonService = tfrCommonService;
	}
	
	/**
	 * waybillManagerService
	 * 
	 * @return the waybillManagerService
	 * @since CodingExample Ver(编码范例查看) 1.0
	 */
	public IWaybillManagerService getWaybillManagerService() {
		return waybillManagerService;
	}

	/**
	 * @param waybillManagerService the waybillManagerService to set Date:2013-5-6下午4:21:45
	 */
	public void setWaybillManagerService(IWaybillManagerService waybillManagerService) {
		this.waybillManagerService = waybillManagerService;
	}
	// modify by liangfuxiang 2013-5-6下午4:21:33 end  BUG-8208;
	
	// add by liangfuxiang 2013-4-27下午6:50:35 begin:BUG-8109
	/**
	 * 签收时间间隔(单位/天)
	 */
	private String signInTimeInterval;

	/**
	 * 未签收时间间隔(单位/天)
	 */
	private String unsignInTimeInterval;

	/**
	 * 无效时间间隔(走货路径主表有数据，明细表无数据。在签收表查询也不存在，一个星期之后，移除)。
	 */
	private String invalidTimeInterval;

	/**
	 * invalidTimeInterval
	 * 
	 * @return the invalidTimeInterval
	 * @since CodingExample Ver(编码范例查看) 1.0
	 */

	public String getInvalidTimeInterval() {
		return invalidTimeInterval;
	}

	/**
	 * @param invalidTimeInterval the invalidTimeInterval to set Date:2013-5-1下午2:21:55
	 */

	public void setInvalidTimeInterval(String invalidTimeInterval) {
		this.invalidTimeInterval = invalidTimeInterval;
	}

	/**
	 * signInTimeInterval
	 * 
	 * @return the signInTimeInterval
	 * @since CodingExample Ver(编码范例查看) 1.0
	 */

	public String getSignInTimeInterval() {
		return signInTimeInterval;
	}

	/**
	 * @param signInTimeInterval the signInTimeInterval to set Date:2013-4-27下午6:50:27
	 */

	public void setSignInTimeInterval(String signInTimeInterval) {
		this.signInTimeInterval = signInTimeInterval;
	}

	/**
	 * unsignInTimeInterval
	 * 
	 * @return the unsignInTimeInterval
	 * @since CodingExample Ver(编码范例查看) 1.0
	 */

	public String getUnsignInTimeInterval() {
		return unsignInTimeInterval;
	}

	/**
	 * @param unsignInTimeInterval the unsignInTimeInterval to set Date:2013-4-27下午6:50:27
	 */

	public void setUnsignInTimeInterval(String unsignInTimeInterval) {
		this.unsignInTimeInterval = unsignInTimeInterval;
	}

	// add by liangfuxiang 2013-4-27下午6:51:14 end BUG-8109;
	
	/**
	 * 获取 反馈dto
	 * 
	 * @return
	 */
	public FeedbackDto getFeedbackDto() {
		return feedbackDto;
	}

	/**
	 * 设置 反馈dto
	 * 
	 * @param feedbackDto
	 */
	public void setFeedbackDto(FeedbackDto feedbackDto) {
		this.feedbackDto = feedbackDto;
	}

	/**
	 * 获取 走货路径dao
	 * 
	 * @return
	 */
	public ITransportationPathDao getTransportationPathDao() {
		return transportationPathDao;
	}

	/**
	 * 设置 走货路径dao
	 * 
	 * @param transportationPathDao
	 */
	public void setTransportationPathDao(ITransportationPathDao transportationPathDao) {
		this.transportationPathDao = transportationPathDao;
	}

	/**
	 * 获取 路径明细dao
	 * 
	 * @return
	 */
	public IPathDetailDao getPathDetailDao() {
		return pathDetailDao;
	}

	/**
	 * 设置 路径明细dao
	 * 
	 * @param pathDetailDao
	 */
	public void setPathDetailDao(IPathDetailDao pathDetailDao) {
		this.pathDetailDao = pathDetailDao;
	}

	/**
	 * 获取 路径改变dao
	 * 
	 * @return
	 */
	public IChangePathDao getChangePathDao() {
		return changePathDao;
	}

	/**
	 * 设置 路径改变dao
	 * 
	 * @param changePathDao
	 */
	public void setChangePathDao(IChangePathDao changePathDao) {
		this.changePathDao = changePathDao;
	}

	/**
	 * 获取 综合生成走货路径service
	 * 
	 * @return
	 */
	public IFreightRouteService getFreightRouteService() {
		return freightRouteService;
	}

	/**
	 * 设置 综合生成走货路径service
	 * 
	 * @param freightRouteService
	 */
	public void setFreightRouteService(IFreightRouteService freightRouteService) {
		this.freightRouteService = freightRouteService;
	}

	/**
	 * 获取 参数配置service
	 * 
	 * @return
	 */
	public IConfigurationParamsService getConfigurationParamsService() {
		return configurationParamsService;
	}

	/**
	 * 设置 参数配置service
	 * 
	 * @param configurationParamsService
	 */
	public void setConfigurationParamsService(IConfigurationParamsService configurationParamsService) {
		this.configurationParamsService = configurationParamsService;
	}

	/**
	 * 获取 装卸车工作效率service
	 * 
	 * @return
	 */
	public ILoadAndUnloadEfficiencyVehicleComplexService getLoadAndUnloadEfficiencyVehicleComplexService() {
		return loadAndUnloadEfficiencyVehicleComplexService;
	}

	/**
	 * 设置 装卸车工作效率service
	 * 
	 * @param loadAndUnloadEfficiencyVehicleComplexService
	 */
	public void setLoadAndUnloadEfficiencyVehicleComplexService(ILoadAndUnloadEfficiencyVehicleComplexService loadAndUnloadEfficiencyVehicleComplexService) {
		this.loadAndUnloadEfficiencyVehicleComplexService = loadAndUnloadEfficiencyVehicleComplexService;
	}

	/**
	 * 获取 线路service
	 * 
	 * @return
	 */
	public ILineService getLineService() {
		return lineService;
	}

	/**
	 * 设置 线路service
	 * 
	 * @param lineService
	 */
	public void setLineService(ILineService lineService) {
		this.lineService = lineService;
	}

	/**
	 * 获取 组织相关service
	 * 
	 * @return
	 */
	public IOrgAdministrativeInfoService getOrgAdministrativeInfoService() {
		return orgAdministrativeInfoService;
	}

	/**
	 * 设置 组织相关service
	 * 
	 * @param orgAdministrativeInfoService
	 */
	public void setOrgAdministrativeInfoService(IOrgAdministrativeInfoService orgAdministrativeInfoService) {
		this.orgAdministrativeInfoService = orgAdministrativeInfoService;
	}

	/**
	 * 获取 库区service
	 * 
	 * @return
	 */
	public IStockService getStockService() {
		return stockService;
	}

	/**
	 * 设置 库区service
	 * 
	 * @param stockService
	 */
	public void setStockService(IStockService stockService) {
		this.stockService = stockService;
	}

	/**
	 * 获取 公共组织service
	 * 
	 * @return
	 */
	public ICommonOrgService getCommonOrgService() {
		return commonOrgService;
	}

	/**
	 * 设置 公共组织service
	 * 
	 * @param commonOrgService
	 */
	public void setCommonOrgService(ICommonOrgService commonOrgService) {
		this.commonOrgService = commonOrgService;
	}
	
	private ISaleDepartmentService saleDepartmentService;

	/**
	 * saleDepartmentService
	 * 
	 * @return the saleDepartmentService
	 * @since CodingExample Ver(编码范例查看) 1.0
	 */

	public ISaleDepartmentService getSaleDepartmentService() {
		return saleDepartmentService;
	}

	/**
	 * @param saleDepartmentService the saleDepartmentService to set Date:2013-6-5下午8:50:07
	 */

	public void setSaleDepartmentService(ISaleDepartmentService saleDepartmentService) {
		this.saleDepartmentService = saleDepartmentService;
	}

	private IBillingGroupTransFerService billingGroupTransFerService;

	/**
	 * billingGroupTransFerService
	 * 
	 * @return the billingGroupTransFerService
	 * @since CodingExample Ver(编码范例查看) 1.0
	 */

	public IBillingGroupTransFerService getBillingGroupTransFerService() {
		return billingGroupTransFerService;
	}

	/**
	 * @param billingGroupTransFerService the billingGroupTransFerService to set Date:2013-6-5下午9:23:56
	 */

	public void setBillingGroupTransFerService(IBillingGroupTransFerService billingGroupTransFerService) {
		this.billingGroupTransFerService = billingGroupTransFerService;
	}

	private IHandOverBillService handOverBillService;
	
	/**   
	 * handOverBillService   
	 *   
	 * @return  the handOverBillService   
	 * @since   CodingExample Ver(编码范例查看) 1.0   
	 */
	
	public IHandOverBillService getHandOverBillService() {
		return handOverBillService;
	}

	/**   
	 * @param handOverBillService the handOverBillService to set
	 * Date:2013-6-17下午3:54:25
	 */
	
	public void setHandOverBillService(IHandOverBillService handOverBillService) {
		this.handOverBillService = handOverBillService;
	}

	/**
	 * 开单新增走货路径
	 * 
	 * @a uthor huyue
	 * @date 2012-10-19 下午1:31:03
	 */
	@Transactional
	public void createTransportPath(TransportPathEntity transportPathEntity) throws TfrBusinessException {
		/**
		 * 原内容无任何处理的封装为一个方法，方便其他类似内容调用
		 */
		//createTransportPathForComm(transportPathEntity,"noDeleteInsert");
		//pda开单和补录开单 开出了两套走货路由，以最后一个走货路由为主，先删除再创建
		createTransportPathForComm(transportPathEntity,null);	
	}
	
	
	/**
	* @description ocb修改目的时调用 先删除主表 然后调用 createTransportPath方法
	* @throws TfrBusinessException
	* @version 1.0
	* @author 14022-foss-songjie
	* @update 2016年4月13日 下午5:30:26
	*/
	@Override
	public void deleteTransportPath(String waybillNo)throws TfrBusinessException {
		//1 根据运单号删除主表信息
		if(waybillNo!=null ){
			// 查询走货路径
			TransportPathEntity entity = transportationPathDao.queryTransportPath(waybillNo);
			if(entity!=null){
				// 删除走货路径主表信息
				transportationPathDao.deleteTransportPath(entity);
			}
		}
	}

	/**
	 * 新增走货路径 公用方法
	 * @param transportPathEntity
	 */
	private void createTransportPathForComm(TransportPathEntity transportPathEntity,String insertPathType){
		
		// modify by liangfuxiang 2013-5-10上午9:34:20 begin
		// 判断走货路径是否已经存在
		verifyTransportPathExist(transportPathEntity);
		// modify by liangfuxiang 2013-5-10上午9:34:26 end;
		
		// 新建路径明细实体
		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();
		// set信息
		// 设置UUID
		transportPathEntity.setTransportPathId(UUIDUtils.getUUID());
		// 新建综合走货路径DTO
		List<FreightRouteLineDto> freightRouteLineDto = null;
		try {
			// 调用基础资料接口得到路径detail
			/*freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(transportPathEntity.getCurrentOrgCode(), transportPathEntity.getDestOrgCode(),
					transportPathEntity.getTransportModel(), new Date());*/
			freightRouteLineDto = freightRouteService.query4Billing(transportPathEntity.getCurrentOrgCode(), transportPathEntity.getDestOrgCode(),
					transportPathEntity.getTransportModel());
		}
		catch (Exception e) {
			
			// modify by liangfuxiang 2013-5-23下午7:53:01 begin 增加日志
			logger.error("CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget + ","
					+ origOrgCode + transportPathEntity.getCurrentOrgCode() + "," + destOrg + transportPathEntity.getDestOrgCode() + "," + TransportPathConstants.TRANS_MODEL
					+ transportPathEntity.getTransportModel()+ "," + e.getStackTrace() + "," + e.getMessage());
			// modify by liangfuxiang 2013-5-23下午7:53:05 end;
			
			// 抛异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME
					+ getNameByCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getCurrentOrgCode() + TransportPathConstants.RIGHTBRACKET
					+ TransportPathConstants.COMMA + getNameByCode(transportPathEntity.getDestOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode()
					+ TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getTransportModel()
					+ TransportPathConstants.RIGHTBRACKET });
		}
		// 如果得到的dto为空
		if (CollectionUtils.isEmpty(freightRouteLineDto)) {
			
			// modify by liangfuxiang 2013-5-23下午7:41:54 begin 抛出异常，如下代码回滚!故注释掉
			// 更新走货路径
			//transportationPathDao.addTransportPathSelect(transportPathEntity);
			// modify by liangfuxiang 2013-5-23下午7:43:18 begin 增加日志
			logger.error("CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget + origOrgCode
					+ ":" + transportPathEntity.getCurrentOrgCode() + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());
			// modify by liangfuxiang 2013-5-23下午7:44:14 end;
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME
					+ getNameByCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getCurrentOrgCode() + TransportPathConstants.RIGHTBRACKET
					+ TransportPathConstants.COMMA + getNameByCode(transportPathEntity.getDestOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode()
					+ TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getTransportModel()
					+ TransportPathConstants.RIGHTBRACKET });
		}
		else {
			// 赋值
			// 循环得到的路径段
			for (int i = 0; i < freightRouteLineDto.size(); i++) {
				// 新建
				pathDetailList.add(new PathDetailEntity());
				// 设置出发部门
				// 如果出发部门code为空
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
					// 抛异常
					// modify by liangfuxiang 2013-5-23下午7:41:54 begin 抛出异常，如下代码回滚!故注释掉
					logger.error("CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG + queryFreightRouteBySourceTarget+","+ origOrgCode + transportPathEntity.getCurrentOrgCode() + "," + destOrg + transportPathEntity.getDestOrgCode());
					// modify by liangfuxiang 2013-5-23下午7:44:14 end;
					// modify by liangfuxiang 2013-7-1上午11:49:39 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] {
							queryFreightRouteBySourceTarget,
							TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.DESTORGNAME
									+ getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
				}
				// 否则设置出发部门
				pathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
				// 设置到达部门
				// 如果到达部门code为空
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
					// modify by liangfuxiang 2013-5-23下午7:41:54 begin 抛出异常，如下代码回滚!故注释掉
					logger.error("CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG + queryFreightRouteBySourceTarget+","+ origOrgCode + transportPathEntity.getCurrentOrgCode() + "," + destOrg + transportPathEntity.getDestOrgCode());
					// modify by liangfuxiang 2013-5-23下午7:44:14 end;
					// 抛异常
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
							TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
				}
				pathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
				// 设置下一到达部门&时间
				// 如果还有下一段
				if ((i + 1) < freightRouteLineDto.size()) {
					// 设置下一到达部门
					pathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
					// 设置下一到达部门时间
					pathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
				}
				// 设置开单部门
				pathDetailList.get(i).setBillingOrgCode(transportPathEntity.getBillingOrgCode());
				// 设置线路段号
				pathDetailList.get(i).setRouteNo(String.valueOf(i + 1));

				// 设置计划出发时间,如果为空，
				if (null == freightRouteLineDto.get(i).getLeaveDate()) {
					// 且非汽运偏线\精准空运\整车
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-23下午7:41:54 begin 抛出异常，如下代码回滚!故注释掉
						String errorInfo ="CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME + queryFreightRouteBySourceTarget+","+ origOrgCode + transportPathEntity.getCurrentOrgCode() + "," + destOrg + transportPathEntity.getDestOrgCode();
						logger.error(errorInfo);
						// modify by liangfuxiang 2013-5-23下午7:44:14 end;
						// 则抛出异常
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
						freightRouteLineDto.get(i).setLeaveDate(new Date());
						//插入日志表
						createTransPathErrorlog(transportPathEntity.getWaybillNo(),
								TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME,errorInfo);
					}
					else {
						// 如果有出发时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 则设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
						}
						else {
							// 否则new date赋值
							freightRouteLineDto.get(i).setLeaveDate(new Date());
						}
					}
				}
				// 设置出发时间
				pathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置计划到达时间,如果为空，
				if (null == freightRouteLineDto.get(i).getArriveDate()) {
					// 且非汽运偏线\精准空运\整车
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) 
							&& StringUtils.equals(freightRouteLineDto.get(i).getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-23下午7:41:54 begin 抛出异常，如下代码回滚!故注释掉
						String info ="CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME + queryFreightRouteBySourceTarget+","+ origOrgCode + transportPathEntity.getCurrentOrgCode() + "," + destOrg + transportPathEntity.getDestOrgCode();
						logger.error(info);
						// modify by liangfuxiang 2013-5-23下午7:44:14 end;
						// 则抛出异常
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
						//插入日志表 2016-10-19
						createTransPathErrorlog(transportPathEntity.getWaybillNo(),
								TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME,info);
						// 设置new date为到达时间
						long beforeArrive1 = (new Date()).getTime();
						// 计算相差天数
						long min = freightRouteLineDto.get(i).getAging();
						// 计算最后到达的日期和时间
						Date arrive = new Date(sixtyThousand * min + beforeArrive1);
						// 设置该段路的到达时间
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
					else {
						// 设置new date为到达时间
						long beforeArrive = (new Date()).getTime();
						// 如果有到达时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 设置为到达时间
							beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
						}
						// 计算相差天数
						long min = freightRouteLineDto.get(i).getAging();
						// 计算最后到达的日期和时间
						Date arrive = new Date(sixtyThousand * min + beforeArrive);
						// 设置该段路的到达时间
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
				}
				// 设置到达时间
				pathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置是否调整时间
				pathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置调整出发时间
				pathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置调整到达时间
				pathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 更新状态
				pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
				// 设置上一段车牌号为空
				pathDetailList.get(i).setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);
			}
			
			// modify by liangfuxiang 2013-5-6上午11:12:15 begin BUG-8208 在处理BUG-8208时，发现此接口逻辑异常，故做修改
			if (pathDetailList.size() > 0) {

				StringBuffer path = new StringBuffer();
				// 设置第一段出发部门
				path.append(getNameByCode(pathDetailList.get(0).getOrigOrgCode()));
				// 循环明细信息 添加基本字段
				for (int i = 0; i < pathDetailList.size(); i++) {
					// UUID
					pathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
					// 运单号
					pathDetailList.get(i).setWaybillNo(transportPathEntity.getWaybillNo());
					// 拼接走货路径
					path.append("-");
					// 设置走货路径
					path.append(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
				}
				
				// modify by liangfuxiang 2013-7-30上午11:31:00 begin 加日志--级别：ERROR--为了能够在生产打印出来。 BUG-45448 
				logger.error("CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.WAYBILL_NO + transportPathEntity.getWaybillNo()
						+ TransportPathConstants.ORGINAL_TRANSPORTPATH + path.toString());
				// modify by liangfuxiang 2013-7-30上午11:31:44 end;
				
				//如果list大于0 
				if (pathDetailList.size() > 0) { 
					// 更新明细list 
					pathDetailDao.addListPathDetail(pathDetailList,insertPathType);
					
				}
				 
				// 设置 其他数据
				if (path.length() == 0) {
					// 设置为空
					transportPathEntity.setTransportPath(TransportPathConstants.SET_NULL_STRING);
				}
				else {
					// 设置路径
					transportPathEntity.setTransportPath(path.toString());
				}
				// 走货路径设置现部门
				transportPathEntity.setCurrentOrgCode(pathDetailList.get(0).getOrigOrgCode());
				// 设置下一部门
				transportPathEntity.setNextOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
				// 设置预计出发时间
				transportPathEntity.setPlanStartTime(pathDetailList.get(0).getModifyStartTime());
				// 设置预计到达时间
				transportPathEntity.setPlanArriveTime(pathDetailList.get(0).getModifyArriveTime());
				// 设置是否分批配载
				transportPathEntity.setIfPartialStowage(TransportPathConstants.NOTPARTIALSTOWAGE);
				// 设置状态
				transportPathEntity.setAction(TransportPathConstants.TRANSPORTPATH_STATUS_BILLING);
				// 更新走货路径
				transportationPathDao.addTransportPathSelect(transportPathEntity);
			}
			// modify by liangfuxiang 2013-5-6上午11:12:33 end; 
		}
	}

	/**
	 * 插入错误记录
	 * @author alfred
	 * @date 2016-10-19 16:26:34
	 * @param entity
	 * @return
	 * @see
	 */
	private void createTransPathErrorlog(String bussinessNo,String bussinessType,String errorInfo){
		CreateErrorLogEntity entity = new CreateErrorLogEntity();
		entity.setID(UUIDUtils.getUUID());
		entity.setBussinessNo(bussinessNo);
		entity.setBussinessType(bussinessType);
		entity.setErrorInfo(errorInfo);
		entity.setSortTable("TFR.T_OPT_TRANSPORT_PATH");
		entity.setCreateTime(new Date());
		tfrCommonService.createErrorLog(entity);
	}
	/**
	 * @Title: verifyTransportPathExist
	 * @Description: 判断走货路径是否已经存在
	 * @param transportPathEntity 设定文件
	 * @return void 返回类型
	 * @see verifyTransportPathExist
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-10 上午9:34:28
	 * @throws
	 */
	private void verifyTransportPathExist(TransportPathEntity transportPathEntity) {

		// 运单号
		String waybillNo = transportPathEntity.getWaybillNo();
		// 运单号为空抛出异常
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[verifyTransportPathExist()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		else {
			// 查询运单号对应的走货路径的数量
			Long count = transportationPathDao.getCountByWayBillNo(waybillNo);
			// 运单对应的走货路径已经存在，则抛出异常，告知用户
			if (count > 0) {
				logger.error("CalculateTransportPathService[verifyTransportPathExist()]:" + TransportPathConstants.TRANSPORT_PATH_EXIST + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORT_PATH_EXIST_GLOB, new Object[] { waybillNo });
			}
		}
	}

	/**
	 * 修改走货路径及其明细的运单号
	 * 
	 * 
	 * @author huyue
	 * @date 2013-3-18 下午4:07:07
	 */
	public void modifyWaybillNo(String oldNo, String newNo) throws TfrBusinessException {
		// 新建实体
		TransportPathEntity transportPathEntity = new TransportPathEntity();
		// 设置运单号为老运单号
		transportPathEntity.setWaybillNo(oldNo);
		// 根据老运单号查询走货路径
		TransportPathEntity nowTransportPath = transportationPathDao.queryTransportPath(transportPathEntity.getWaybillNo());
		// 若走货路径非空
		if (null != nowTransportPath) {
			// 设置新运单号
			nowTransportPath.setWaybillNo(newNo);
			// 更新走货路径信息
			transportationPathDao.updateTransportPathSelect(nowTransportPath);
			// 新建明细实体
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 设置运单号为老运单号
			pathDetailEntity.setWaybillNo(oldNo);
			// 查询所有明细信息
			List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
			for (int i = 0; i < pathDetailList.size(); i++) {
				// 设置所有明细运单号
				pathDetailList.get(i).setWaybillNo(newNo);
			}
			// 如果list不为空
			if (!CollectionUtils.isEmpty(pathDetailList)) {
				// 更新所有明细运单号
				pathDetailDao.updateListPathDetail(pathDetailList);
			}
		}
		else {
			// modify by liangfuxiang 2013-5-23下午7:59:36 begin 添加日志
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[modifyWaybillNo()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + oldNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { oldNo });
			// modify by liangfuxiang 2013-5-23下午7:59:47 end;
			// 抛异常 没有查询到相应运单走货路径
			
		}
	}

	/**
	 * 更改单修改开单信息 , 增加了现所在部门 从现所在部门开始修改走货路径, nowOrgCode为当前部门,即本批货所在部门,将会根据本部门和Entity中的新到达部门计算新的走货路径
	 * 
	 * 
	 * @author huyue
	 * @date 2012-10-23 下午4:47:02
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void modifyTransportPath(TransportPathEntity transportPathEntity, List<String> serialNo, String nowOrgCode, String operatorCode, String operatorName) throws TfrBusinessException {
		// 查询走货路径
		TransportPathEntity nowTransportPath = transportationPathDao.queryTransportPath(transportPathEntity.getWaybillNo());
		// 判断是否有该运单对应的走货路径,如果没有返回NODATA.需要进行新增
		if (null != nowTransportPath) {
			// 设置ID
			transportPathEntity.setTransportPathId(nowTransportPath.getTransportPathId());
			// 设置状态
			transportPathEntity.setAction(nowTransportPath.getAction());
			// // 判断是否目的地更改
			// if (StringUtils.isNotEmpty(transportPathEntity.getDestOrgCode()) && StringUtils.isNotEmpty(nowTransportPath.getDestOrgCode())
			// && !transportPathEntity.getDestOrgCode().equals(nowTransportPath.getDestOrgCode())) {
			// 判断是否分批配载
			if (StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, nowTransportPath.getIfPartialStowage())) {
				for (int i = 0; i < serialNo.size(); i++) {
					// modify by liangfuxiang 2013-3-19下午5:19:32 begin
					// 在卡航无法获取走货路径时，再一次选择汽运短途,
					// 若依然无走货路径，则选择精准城运
					// 更改单更改货物走货路径
					// alterDetail(transportPathEntity.getWaybillNo(),
					// serialNo.get(i), nowOrgCode,
					// transportPathEntity.getDestOrgCode(),
					// transportPathEntity.getBillingOrgCode(),
					// transportPathEntity.getTransportModel());
					alterDetailforModify(transportPathEntity.getWaybillNo(), serialNo.get(i), nowOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(),
							transportPathEntity.getTransportModel(),transportPathEntity);
					// modify by liangfuxiang 2013-3-19下午5:19:41 end;
				}
				
				// modify by liangfuxiang 2013-6-18上午10:54:16 begin
				transportPathEntity.setCurrentOrgCode(nowOrgCode);
				transportPathEntity.setCurrentOrgCodeName(getNameByCode(nowOrgCode));
				transportPathEntity.setTransportPathId(nowTransportPath.getTransportPathId());
				transportPathEntity.setId(nowTransportPath.getId());
				// modify by liangfuxiang 2013-6-18上午10:54:20 end;
				
				//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
				// 设置走货路径
				//transportPathEntity.setTransportPath(getChangedPath(transportPathEntity.getWaybillNo()));
			}
			else {
				// 没有分批
				// 更改单更改货物走货路径
				alterDetail(transportPathEntity.getWaybillNo(), null, nowOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(),
						transportPathEntity.getTransportModel());
				// 更新主表path
				PathDetailEntity pathDetailEntity = new PathDetailEntity();
				// 设置单号
				pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
				// 根据运单号找到走货路径list
				List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
				// 设置起始地
				StringBuffer path = new StringBuffer();
				// 设置目标地
				path.append(getNameByCode(pathDetailList.get(0).getOrigOrgCode()));
				// 遍历：拼接路径
				// modify by liangfuxiang 2013-6-18上午11:15:34 begin
				//存在这样的路段:A-B  B-A  A-C C-D D-E  
				//相同的出发部门A，要查找最大的路段号的路段 应该为A-C
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 拼接走货路径全路径信息
					path.append("-");
					// 走货路径:拼接名称
					path.append(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));

					// 如果明细表信息的出发部门等于现部门,则读区本条进行路径主表字段set
					// if (pathDetailList.get(i).getOrigOrgCode().equals(nowOrgCode)) {
					//
					//
					//
					// transportPathEntity.setId(nowTransportPath.getId());
					//
					// // 设置当期部门
					// transportPathEntity.setCurrentOrgCode(pathDetailList.get(i).getOrigOrgCode());
					// // 设置下一部门
					// transportPathEntity.setNextOrgCode(pathDetailList.get(i).getObjectiveOrgCode());
					// // 设置计划出发时间
					// transportPathEntity.setPlanStartTime(pathDetailList.get(i).getModifyStartTime());
					// // 设置计划到达时间
					// transportPathEntity.setPlanArriveTime(pathDetailList.get(i).getModifyArriveTime());
					//
					//
					// }
				}
				
				//重新初始化走货路径主表和详细表信息
				initTransportPathEntityAndPathDetailList(transportPathEntity,pathDetailList,nowOrgCode);
				//初始化ID
				transportPathEntity.setTransportPathId(nowTransportPath.getTransportPathId());
				transportPathEntity.setId(nowTransportPath.getId());
				// modify by liangfuxiang 2013-6-18上午11:15:38 end;
				// 路径长度为0
				//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
				/*if (path.length() == 0) {
					// 设置走货路径为空
					transportPathEntity.setTransportPath(TransportPathConstants.SET_NULL_STRING);
				}
				else {
					// 设置走货路径
					transportPathEntity.setTransportPath(path.toString());
				}*/
			}
			// 目的地更改则需要更改库存 调用接口更改库存
			for (int s = 0; s < serialNo.size(); s++) {
				// 新建入库实例
				InOutStockEntity inOutStockEntity = new InOutStockEntity();
				// 设置运载单号
				inOutStockEntity.setWaybillNO(transportPathEntity.getWaybillNo());
				// 设置序列号
				inOutStockEntity.setSerialNO(serialNo.get(s));
				// 设置当前部门
				inOutStockEntity.setOrgCode(nowOrgCode);
				// 设置操作部门
				inOutStockEntity.setOperatorCode(operatorCode);
				// 设置操作部门名称
				inOutStockEntity.setOperatorName(operatorName);
				// modify by liangfuxiang 2013-6-26下午2:53:19 begin BUG-37421
				// 设置更改单类型
				//inOutStockEntity.setInOutStockType(StockConstants.WAYBILL_RFC_IN_STOCK_TYPE);
				inOutStockEntity.setInOutStockType(StockConstants.MODIFY_TRANSPATH_IN_STOCK_TYPE);
				// modify by liangfuxiang 2013-6-26下午2:53:27 end;
				// 入库
				stockService.inStockPC(inOutStockEntity);
			}
			// }
			// 更新其他基本字段
			transportationPathDao.updateTransportPathSelect(transportPathEntity);
		}
		else {
			// 找不到走货路径，抛出异常
			// modify by liangfuxiang 2013-5-23下午7:59:36 begin 添加日志
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[modifyWaybillNo()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO
					+ transportPathEntity.getWaybillNo());
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { transportPathEntity.getWaybillNo() });
			// modify by liangfuxiang 2013-5-23下午7:59:47 end;
		}
	}
	
	/**
	 * @param nowOrgCode  
	* @Title: initTransportPathEntityAndPathDetailList 
	* @Description: 重新初始化走货路径主表和详细表信息
	* @param transportPathEntity
	* @param pathDetailList  设定文件 
	* @return void    返回类型 
	* @see initTransportPathEntityAndPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-18 上午11:23:26   
	* @throws 
	*/ 
	private void initTransportPathEntityAndPathDetailList(TransportPathEntity transportPathEntity, List<PathDetailEntity> pathDetailList, String nowOrgCode) {

		// 获取起始部门与当前相同的最大路段的走货路径
		PathDetailEntity maxRoutePathDetailEntity = getMaxRoutePathDetailEntity(pathDetailList, nowOrgCode);
		// 初始化transportPath
		// 设置当期部门
		transportPathEntity.setCurrentOrgCode(maxRoutePathDetailEntity.getOrigOrgCode());
		transportPathEntity.setCurrentOrgCodeName(getNameByCode(maxRoutePathDetailEntity.getOrigOrgCode()));
		// 设置下一部门
		transportPathEntity.setNextOrgCode(maxRoutePathDetailEntity.getObjectiveOrgCode());
		transportPathEntity.setNextOrgCodeName(getNameByCode(maxRoutePathDetailEntity.getObjectiveOrgCode()));
		// 设置计划出发时间
		transportPathEntity.setPlanStartTime(maxRoutePathDetailEntity.getModifyStartTime());
		// 设置计划到达时间
		transportPathEntity.setPlanArriveTime(maxRoutePathDetailEntity.getModifyArriveTime());
		// 设置状态--instore
		transportPathEntity.setAction(maxRoutePathDetailEntity.getArriveOrLeave());
	}

	/** 
	* @Title: getMaxRoutePathDetailEntity 
	* @Description: 获取起始部门与当前相同的最大路段的走货路径
	* @param pathDetailList
	* @param nowOrgCode
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see getMaxRoutePathDetailEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-18 上午11:26:18   
	* @throws 
	*/ 
	private PathDetailEntity getMaxRoutePathDetailEntity(List<PathDetailEntity> pathDetailList, String nowOrgCode) {

		// 获取相同其实部门的走货路径明细
		List<PathDetailEntity> sameOrginalOrgCodePathDetailList = getSameOrginalOrgCodePathDetailList(pathDetailList, nowOrgCode);

		// 按照路段号排序
		sameOrginalOrgCodePathDetailList = sortPathDetailListByGoodsNoAndRouteNo(sameOrginalOrgCodePathDetailList);
		// 获取最大路段的走货路径明细信息
		PathDetailEntity maxPathDetailEntity = sameOrginalOrgCodePathDetailList.get(sameOrginalOrgCodePathDetailList.size() - 1);
		// 更新状态为releave--已离开---最大走货路径状态为INSTORE
		for (int i = 0; i < sameOrginalOrgCodePathDetailList.size(); i++) {
			if (i == sameOrginalOrgCodePathDetailList.size() - 1) {
				sameOrginalOrgCodePathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
			}
			else {
				sameOrginalOrgCodePathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			}
		}

		// 更新状态
		pathDetailDao.updateListPathDetail(sameOrginalOrgCodePathDetailList);

		// 返回最大路段的走货路径明细信息
		return maxPathDetailEntity;
	}

	/** 
	* @Title: getSameOrginalOrgCodePathDetailList 
	* @Description: 获取相同其实部门的走货路径明细
	* @param pathDetailList
	* @param nowOrgCode
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see getSameOrginalOrgCodePathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-18 上午11:30:28   
	* @throws 
	*/ 
	private List<PathDetailEntity> getSameOrginalOrgCodePathDetailList(List<PathDetailEntity> pathDetailList, String nowOrgCode) {
		
		List<PathDetailEntity> sameOrginalOrgCodePathDetailList=new ArrayList<PathDetailEntity>();
		//遍历获取相同起始部门的走货路段信息
		for(int k=0;k<pathDetailList.size();k++){
			if(StringUtils.equalsIgnoreCase(pathDetailList.get(k).getOrigOrgCode(),nowOrgCode)){
				sameOrginalOrgCodePathDetailList.add(pathDetailList.get(k));
			}
		}
		//若为空，则
		if (CollectionUtils.isEmpty(sameOrginalOrgCodePathDetailList)) {
			// 调整走货路径失败,当前部门不在走货路径上。
			logger.error("CalculateTransportPathService[getSameOrginalOrgCodePathDetailList()]:" + TransportPathConstants.CURRENT_ORG_CODE_NOT_ON_PATH + TransportPathConstants.WAYBILL_NO
					+ pathDetailList.get(0).getWaybillNo() + TransportPathConstants.CURRENT_ORGCODE + nowOrgCode);
			throw new TfrBusinessException(TransportPathConstants.CURRENT_ORG_CODE_NOT_ON_PATH_GLOB, new Object[] { pathDetailList.get(0).getWaybillNo(),
					getNameByCode(nowOrgCode) + TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET });
		}
		return sameOrginalOrgCodePathDetailList;
	}

	/**
	 * 
	* @Title: modifyTransportPathForAmendmentBill 
	* @Description: 更改单----更改单专用接口
	* @param transportPathEntity
	* @param serialNo
	* @param nowOrgCode
	* @param operatorCode
	* @param operatorName  设定文件 
	* @return void    返回类型 
	* @see modifyTransportPathForAmendmentBill
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午3:42:06   
	* @throws
	 */
	public void modifyTransportPathForAmendmentBill(TransportPathEntity transportPathEntity, List<String> serialNo, String nowOrgCode, String operatorCode, String operatorName){
		//方法内容整体迁至modifyTransportPathAmendmentBillType  方法中
		modifyTransportPathAmendmentBillType(transportPathEntity,serialNo,nowOrgCode,operatorCode,operatorName,null);
	}
	
	/**
	* @description  更改单:调整走货路径. 和modifyTransportPathForAmendmentBill方法一样，增加了传入参数:入库类型(inStockType)
	* @param transportPathEntity
	* @param serialNo
	* @param nowOrgCode
	* @param operatorCode
	* @param operatorName
	* @param inStockType
	* @throws TfrBusinessException
	* @version 1.0
	* @author 14022-foss-songjie
	* @update 2014年2月12日 下午2:36:10
	*/
	@Override
	public void modifyTransportPathAmendmentBillType(
			TransportPathEntity transportPathEntity, List<String> serialNo,
			String nowOrgCode, String operatorCode, String operatorName,
			String inStockType) throws TfrBusinessException {
		//入库类型：默认：StockConstants.WAYBILL_RFC_IN_STOCK_TYPE
		if(StringUtils.isEmpty(inStockType)){
			inStockType = StockConstants.WAYBILL_RFC_IN_STOCK_TYPE;
		}
		
		// 查询走货路径
				TransportPathEntity nowTransportPath = transportationPathDao.queryTransportPath(transportPathEntity.getWaybillNo());
				// 判断是否有该运单对应的走货路径,如果没有返回NODATA.需要进行新增
				if (null != nowTransportPath) {
					// 设置ID
					transportPathEntity.setTransportPathId(nowTransportPath.getTransportPathId());
					// 设置状态
					transportPathEntity.setAction(nowTransportPath.getAction());

					// 分批配载，流水号为空
					if (CollectionUtils.isEmpty(serialNo)) {
						// 日志记录
						logger.error("CalculateTransportPathService[modifyTransportPathForAmendmentBill()]:" + TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY);
						// 抛出异常
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY, new Object[] { transportPathEntity.getWaybillNo() });
					}
					
					// 原走货路径未分批。。此时要强制分批
					if (StringUtils.equals(TransportPathConstants.NOTPARTIALSTOWAGE, nowTransportPath.getIfPartialStowage())) {
						forceSepratePathForAmendmentBillNoRemove(nowTransportPath.getWaybillNo(), serialNo);
						nowTransportPath.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
						// 更新分批配载
						transportationPathDao.updateTransportPathSelect(nowTransportPath);
					}
					
					// modify by liangfuxiang 2013-7-2下午8:17:46 begin 若当前部门与目的部门相同--走货路径则不作修改
					transportPathEntity.setCurrentOrgCode(nowOrgCode);
					transportPathEntity.setCurrentOrgCodeName(getNameByCode(nowOrgCode));
					transportPathEntity.setTransportPathId(nowTransportPath.getTransportPathId());
					transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
					transportPathEntity.setId(nowTransportPath.getId());
					
					// modify by liangfuxiang 2013-7-11下午5:25:35 begin BUG-42202
					// //若目的站未更改
					// if(StringUtils.equalsIgnoreCase(transportPathEntity.getDestOrgCode(), nowTransportPath.getDestOrgCode()) ){
					//
					// //将最终的走货路径明细的最大走货路径状态修改为INSTORE
					// for(int i=0;i<serialNo.size();i++){
					// updatePathDetailEntityMaxRouteNo(transportPathEntity.getWaybillNo(), serialNo.get(i), nowOrgCode);
					// }
					//
					// //下以部门为空
					// transportPathEntity.setNextOrgCode(null);
					// }
					// //否则调整走货路径
					// else{
					for (int i = 0; i < serialNo.size(); i++) {
						// 调整走货路径
						alterDetailforAmendmentBill(transportPathEntity.getWaybillNo(), serialNo.get(i), nowOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(),
								transportPathEntity.getTransportModel(), transportPathEntity);
					}
					//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
					// 设置走货路径
//					transportPathEntity.setTransportPath(getChangedPath(transportPathEntity.getWaybillNo()));
					// }

					// 目的地更改则需要更改库存 调用接口更改库存
					for (int s = 0; s < serialNo.size(); s++) {
						// 新建入库实例
						InOutStockEntity inOutStockEntity = new InOutStockEntity();
						// 设置运载单号
						inOutStockEntity.setWaybillNO(transportPathEntity.getWaybillNo());
						// 设置序列号
						inOutStockEntity.setSerialNO(serialNo.get(s));
						// 设置当前部门
						inOutStockEntity.setOrgCode(nowOrgCode);
						// 设置操作部门
						inOutStockEntity.setOperatorCode(operatorCode);
						// 设置操作部门名称
						inOutStockEntity.setOperatorName(operatorName);
						// 设置更改单类型
						inOutStockEntity.setInOutStockType(inStockType);
						// 入库
						stockService.inStockPC(inOutStockEntity);
					}
					
					//设置上一状态
					transportPathEntity.setBeforeAction(nowTransportPath.getAction());
					//状态为入库
					transportPathEntity.setAction(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
					// 更新其他基本字段
					transportationPathDao.updateTransportPathSelect(transportPathEntity);
				}
				else {
					logger.error("CalculateTransportPathService[modifyTransportPathForAmendmentBill()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO
							+ transportPathEntity.getWaybillNo());
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { transportPathEntity.getWaybillNo() });
				}
		
	}

	/**
	 * 删除开单信息
	 * @deprecated
	 * @author huyue
	 * @date 2012-10-23 下午8:10:32
	 */
	@Transactional
	public void deleteTransportPath(String waybillNo, String action) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-23下午8:17:41 begin 增加参数验证
		//走货路径为空
		if (StringUtils.isEmpty(action)) {
			logger.error("CalculateTransportPathService[deleteTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_DELETE_ACTION_NULL);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_DELETE_ACTION_NULL_GLOB);
		}
		// modify by liangfuxiang 2013-5-23下午8:17:48 end;
		
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 新建走货路径详情实例
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		
		// modify by liangfuxiang 2013-5-23下午8:19:28 begin 如下if条件存在异常，若transportPathEntity.getAction() 为空，则抛出的异常不够细化
		// 判断是否还在开单状态
		// if (null != transportPathEntity && StringUtils.isNotEmpty(transportPathEntity.getAction()) && transportPathEntity.getAction().equals(action)) {
		if (null != transportPathEntity) {
			// 若查询的走货路径状态为空
			if (StringUtils.isEmpty(transportPathEntity.getAction())) {
				logger.error("CalculateTransportPathService[deleteTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_ACTION_IS_NULL + TransportPathConstants.WAYBILL_NO + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_ACTION_IS_NULL_GLOB, new Object[] { waybillNo });
			}
			else if (transportPathEntity.getAction().equals(action)) {
				// 设置单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 查询走货路径详情信息列表
				List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
				// 批量删除明细信息
				pathDetailDao.deleteListPathDetail(pathDetailList);
				// 删除走货路径主表信息
				transportationPathDao.deleteTransportPath(transportPathEntity);
			}
			else {
				// 走货路径状态不一致
				logger.error("CalculateTransportPathService[deleteTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_ACTION_NOT_EQUAL + TransportPathConstants.WAYBILL_NO + waybillNo + ","
						+ TransportPathConstants.TRANSPORTPATH_ACTION + transportPathEntity.getAction() + "," + TransportPathConstants.TRANSPORTPATH_ACTION_INPUT + action);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_ACTION_NOT_EQUAL_GLOB, new Object[] { waybillNo, transportPathEntity.getAction(), action });
			}
			// modify by liangfuxiang 2013-5-23下午8:20:14 end;
		}
		else {
			// 找不到走货路径，抛出异常
			// modify by liangfuxiang 2013-5-23下午7:59:36 begin 添加日志,并细化异常原因
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTDELETE, "");
			logger.error("CalculateTransportPathService[deleteTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTDELETE + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTDELETE, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-23下午7:59:47 end;
		}
	}

	/**
	 * 货物包装
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:34:23
	 */
	@Transactional
	public void packing(String waybillNo, String packingOrgCode, List<String> origSerialNo, List<String> objectiveSerialNo) throws TfrBusinessException {
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 走货路径存在
		if (null != transportPathEntity) {
			// 包装部门编号
			transportPathEntity.setPackingOrgCode(packingOrgCode);
			// 获取包装后运单货件数
			List<String> listGoodsNo = pathDetailDao.listQueryGoodsNo(waybillNo);
			// 设置包装后件数.
			transportPathEntity.setPackedNum(listGoodsNo.size());
			// 运单总货件数量.
			transportPathEntity.setGoodsQtyTotal(listGoodsNo.size());
			// 更新走货路径
			transportationPathDao.updateTransportPath(transportPathEntity);
			// 判断是否分批.如果分批则需要根据合并后的流水号生成新的路径
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 唯一流水号
				if (origSerialNo.size() == 1 && objectiveSerialNo.size() > 1) {
					// 一拆多情况
					PathDetailEntity pathDetailEntity = new PathDetailEntity();
					// 设置单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 获取流水号
					pathDetailEntity.setGoodsNo(origSerialNo.get(0));
					// 获取走货路径详情信息列表
					List<PathDetailEntity> origList = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 将原来的条目赋值并更新
					for (int i = 0; i < origList.size(); i++) {
						// 设置流水号
						origList.get(i).setGoodsNo(objectiveSerialNo.get(0));
						// 更新走货路径详情
						pathDetailDao.updateListPathDetail(origList);
					}
					// 创建新条目
					for (int j = 0; j < origList.size(); j++) {
						// 新建走货路径详情信息列表
						List<PathDetailEntity> newList = new ArrayList<PathDetailEntity>(objectiveSerialNo.size() - 1);
						// 遍历列表
						for (int i = 0; i < (objectiveSerialNo.size() - 1); i++) {
							// 新建走货路径详情对象
							PathDetailEntity newEntity = new PathDetailEntity();
							// 将现对象值拷贝到对应的新对象
							BeanUtils.copyProperties(origList.get(j), newEntity);
							// 设置ID
							newEntity.setPathDetailId(UUIDUtils.getUUID());
							// 设置流水号
							newEntity.setGoodsNo(objectiveSerialNo.get(i + 1));
							// 向列表中增加新对象
							newList.add(newEntity);
						}
						// 若新列表不为空
						if (newList.size() > 0) {
							// 保存走货路径详情列表信息
							pathDetailDao.addListPathDetail(newList);
						}
					}
					// 多个流水号
				}
				else if (origSerialNo.size() > 1 && objectiveSerialNo.size() == 1) {
					// 多合一情况
					// 一拆多情况
					PathDetailEntity pathDetailEntity = new PathDetailEntity();
					// 设置单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(origSerialNo.get(0));
					// c查询走货路径详情列表
					List<PathDetailEntity> origList = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 将原来的条目赋值并更新
					for (int i = 0; i < origList.size(); i++) {
						// 设置流水号
						origList.get(i).setGoodsNo(objectiveSerialNo.get(0));
						// 更新走货路径详情列表
						pathDetailDao.updateListPathDetail(origList);
					}
					// 逐个找到需要删除的货件号对应的走货路径 批量删除
					List<PathDetailEntity> deleteList = new ArrayList<PathDetailEntity>();
					// 遍历
					for (int i = 0; (i < origSerialNo.size() - 1); i++) {
						// 新对戏那个
						pathDetailEntity = new PathDetailEntity();
						// 设置单号
						pathDetailEntity.setWaybillNo(waybillNo);
						// 设置流水号
						pathDetailEntity.setGoodsNo(origSerialNo.get(i + 1));
						// 设置走货路径详细信息列表
						List<PathDetailEntity> needDeleteList = pathDetailDao.queryPathDetailList(pathDetailEntity);
						// 添加要批量删除的列表
						deleteList.addAll(needDeleteList);
					}
					// 删除列表不为空
					if (deleteList.size() > 0) {
						// 鼻梁删除
						pathDetailDao.deleteListPathDetail(deleteList);
					}
				}
				else {
					// 抛出异常：
					// modify by liangfuxiang 2013-5-23下午8:30:16 begin 添加日志!
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_SERIALNOERROR, "");
					logger.error("CalculateTransportPathService[packing()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_SERIALNOERROR + TransportPathConstants.WAYBILL_NO + waybillNo);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_SERIALNOERROR, new Object[] { waybillNo });
					// modify by liangfuxiang 2013-5-23下午8:30:34 end;
				}
			}
		}
		else {
			// modify by liangfuxiang 2013-5-23下午8:30:16 begin 添加日志!
			// 抛出异常：未找到走货路径
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[packing()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-23下午8:30:34 end;
		}
	}

	/**
	 * 装车/交接单 人工合车的调整也会在本步进行回调并且修改路径明细
	 * 
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:38:20
	 */
	@Transactional
	public void loadVehicle(String waybillNo, List<String> serialNoList, String action, int loadQTY, int ifJoinCar, String nowOrgCode, String nextOrgCode, String vehicleNo)
			throws TfrBusinessException {
		// 建立走货路径详情对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		
		// modify by liangfuxiang 2013-5-18下午2:16:12 begin 非空判断 BUG-8782
		if(null==transportPathEntity){
			logger.error("CalculateTransportPathService[loadVehicle()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA,new Object[] { waybillNo });
		}
		// modify by liangfuxiang 2013-5-18下午2:16:28 end BUG-8782;
		
		// 判断是否分批配载
		if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
			// 如果没有分批.判断是否需要进行分批
			if ((null != transportPathEntity.getGoodsQtyTotal()) && transportPathEntity.getGoodsQtyTotal() != loadQTY) {
				// 设置分批字段为1
				transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
				// 拆分明细表
				seperatePathDetail(waybillNo);
				// 更新主表
				transportationPathDao.updateTransportPath(transportPathEntity);
				// 更新状态
				for (int g = 0; g < serialNoList.size(); g++) {
					// 建立走货路径详情对象
					pathDetailEntity = new PathDetailEntity();
					// 设置单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(serialNoList.get(g));
					// 当前部门编码
					pathDetailEntity.setOrigOrgCode(nowOrgCode);
					// 找到应走条目 更新数据为正确的合车后目的地
					List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					// 走货路径详情信息不为空
					if (list.size() == 0) {
						// 新建走货路径详情信息列表
						List<PathDetailEntity> list2 = new ArrayList<PathDetailEntity>();
						// 查询走货路径详情信息
						list2 = pathDetailDao.queryPathDetailList(pathDetailEntity);
						// 若唯一
						if (list2.size() == 1) {
							// 返回
							return;
						}
						// modify by liangfuxiang 2013-5-23下午8:45:22 begin 细化异常原因，并记录日志
						// else {
						// // 得到的明细对应数据大于一条或者没有得到数据.数据有错误
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
						// }
						else if (list2.size() > 1) {
							// 得到多条数据
							String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
							logger.error("CalculateTransportPathService[loadVehicle()]:" + exps[0] + waybillNo + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
							throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB,new Object[]{waybillNo,pathDetailEntity.getOrigOrgCode()});
						}
						else {
							// 未查询到走货路径明细信息
							String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
							logger.error("CalculateTransportPathService[loadVehicle()]:" + exps[0] + waybillNo + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
							throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
						}
						// modify by liangfuxiang 2013-5-23下午8:45:37 end;
						// 若不唯一
					}
					else if (list.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午8:50:33 begin
						// 异常
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						logger.error("CalculateTransportPathService[loadVehicle()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
								+ TransportPathConstants.DEST_ORGCODE + nowOrgCode + TransportPathConstants.SERIAL_NO + serialNoList.get(g));
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_NEW, new Object[] { waybillNo, nowOrgCode, serialNoList.get(g) });
						// modify by liangfuxiang 2013-5-23下午8:50:42 end;
					}
					else {
						// 复制对象值
						BeanUtils.copyProperties(list.get(0), pathDetailEntity);
					}
					// 设置车牌号
					pathDetailEntity.setVehicleNo(vehicleNo);
					// 已交接
					pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
					// 更新走货路径详情
					pathDetailDao.updatePathDetail(pathDetailEntity);
				}
			}
			else {// 不需要分批
				// 新建走货路径详情对象
				pathDetailEntity = new PathDetailEntity();
				// 设置单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置当前部门编号
				pathDetailEntity.setOrigOrgCode(nowOrgCode);
				// 找到应走条目 更新数据为正确的合车后目的地
				List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 未查询到走货路径详细信息
				if (list.size() == 0) {
					// 新建走货路径详细信息列表
					List<PathDetailEntity> list2 = new ArrayList<PathDetailEntity>();
					// 查询走货路径详细信息
					list2 = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 唯一行
					if (list2.size() == 1) {
						// 返回
						return;
					}
					// modify by liangfuxiang 2013-5-23下午8:45:22 begin 细化异常原因，并记录日志
					// else {
					// // 得到的明细对应数据大于一条或者没有得到数据.数据有错误
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
					// }
					else if (list2.size() > 1) {
						// 得到多条数据
						String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
						logger.error("CalculateTransportPathService[loadVehicle()]:" + exps[0] + waybillNo + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
					}
					else {
						// 未查询到走货路径明细信息
						String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
						logger.error("CalculateTransportPathService[loadVehicle()]:" + exps[0] + waybillNo + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
					}
					// modify by liangfuxiang 2013-5-23下午8:45:37 end;
				}
				else if (list.size() > 1) {
					// 不止一行
					// modify by liangfuxiang 2013-5-23下午8:50:33 begin
					// 异常
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					logger.error("CalculateTransportPathService[loadVehicle()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
							+ TransportPathConstants.DEST_ORGCODE + nowOrgCode);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_NEW, new Object[] { waybillNo, nowOrgCode, TransportPathConstants.BLANK_SPACE_STRING });
					// modify by liangfuxiang 2013-5-23下午8:50:42 end;
				}
				else {
					// 复制属性值
					BeanUtils.copyProperties(list.get(0), pathDetailEntity);
				}
				// 设置车牌号
				pathDetailEntity.setVehicleNo(vehicleNo);
				// 已交接
				pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
				// 更新走货路径详细信息
				pathDetailDao.updatePathDetail(pathDetailEntity);
			}
		}
		else {// 已经进行分批配载
				// 更新状态
			for (int g = 0; g < serialNoList.size(); g++) {
				// 新建对象
				pathDetailEntity = new PathDetailEntity();
				// 设置单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置流水号
				pathDetailEntity.setGoodsNo(serialNoList.get(g));
				// 设置当前部门编号
				pathDetailEntity.setOrigOrgCode(nowOrgCode);
				// 找到应走条目 更新数据为正确的合车后目的地
				List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 若为空
				if (list.size() == 0) {
					// 新建走货路径详细信息列表
					List<PathDetailEntity> list2 = new ArrayList<PathDetailEntity>();
					// 查询走货路径详细信息列表
					list2 = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 唯一
					if (list2.size() == 1) {
						// 返回
						return;
					}
					// modify by liangfuxiang 2013-5-23下午8:45:22 begin 细化异常原因，并记录日志
					// else {
					// // 得到的明细对应数据大于一条或者没有得到数据.数据有错误
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
					// }
					else if (list2.size() > 1) {
						// 得到多条数据
						String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
						logger.error("CalculateTransportPathService[loadVehicle()]:" + exps[0] + waybillNo + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
					}
					else {
						// 未查询到走货路径明细信息
						String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
						logger.error("CalculateTransportPathService[loadVehicle()]:" + exps[0] + waybillNo + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
					}
					// modify by liangfuxiang 2013-5-23下午8:45:37 end;
					// 若不止一条数据
				}
				else if (list.size() > 1) {
					// 异常
					// 不止一行
					// modify by liangfuxiang 2013-5-23下午8:50:33 begin
					// 异常
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					logger.error("CalculateTransportPathService[loadVehicle()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
							+ TransportPathConstants.DEST_ORGCODE + nowOrgCode);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_NEW, new Object[] { waybillNo, nowOrgCode, TransportPathConstants.BLANK_SPACE_STRING });
					// modify by liangfuxiang 2013-5-23下午8:50:42 end;
				}
				else {
					// 复制属性值
					BeanUtils.copyProperties(list.get(0), pathDetailEntity);
				}
				// 设置车牌号
				pathDetailEntity.setVehicleNo(vehicleNo);
				// 已交接
				pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
				// 更新走货路径详细信息
				pathDetailDao.updatePathDetail(pathDetailEntity);
			}
		}
		// 如果进行合车调整,则更新明细信息
		if (ifJoinCar == TransportPathConstants.JOINCAR) {
			// 再判断是否批量,进行后序路径修改
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 遍历
				for (int g = 0; g < serialNoList.size(); g++) {
					// 新建走货路径详细信息对象
					pathDetailEntity = new PathDetailEntity();
					// 先更新下一段为合车修改线路
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水好
					pathDetailEntity.setGoodsNo(serialNoList.get(g));
					// 设置出发部门
					pathDetailEntity.setOrigOrgCode(nowOrgCode);
					// 找到应走条目 更新数据为正确的合车后目的地
					List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					// 未查询到
					if (list.size() == 0) {
						// 走货路径详细信息对象为空
						pathDetailEntity = null;
						// 若查询到多条
					}
					else if (list.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午8:57:45 begin 添加日志
						// 异常
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						logger.error("CalculateTransportPathService[loadVehicle()]" + TransportPathConstants.TRANSPORTPATH_MULT_DETAILMORETHANONE_JOINCAR + TransportPathConstants.WAYBILL_NO
								+ waybillNo + TransportPathConstants.DEST_ORGCODE + nowOrgCode);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_MULT_DETAILMORETHANONE_JOINCAR_GLOB, new Object[] { waybillNo, nowOrgCode });
						// modify by liangfuxiang 2013-5-23下午8:57:51 end;
					}
					else {
						// 复制属性值
						BeanUtils.copyProperties(list.get(0), pathDetailEntity);
					}
					// 走货路径详细信息对象为空
					if (null == pathDetailEntity) {
						// modify by liangfuxiang 2013-5-23下午8:57:45 begin 添加日志
						// 异常：找不到数据
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_JOINCAR, "");
						logger.error("CalculateTransportPathService[loadVehicle()]" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_JOINCAR + TransportPathConstants.WAYBILL_NO
								+ waybillNo + TransportPathConstants.DEST_ORGCODE + nowOrgCode);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_JOINCAR_GLOB, new Object[] { waybillNo, nowOrgCode });
						// modify by liangfuxiang 2013-5-23下午8:57:51 end;
					}
					// 设置目标部门
					pathDetailEntity.setObjectiveOrgCode(nextOrgCode);
					// 设置实际到达时间为空
					pathDetailEntity.setActualArriveTime(null);
					// 设置实际出发时间为空
					pathDetailEntity.setActualStartTime(null);
					// 设置计划到达时间为空
					pathDetailEntity.setPlanArriveTime(null);
					// 设置计划出发按时间为空
					pathDetailEntity.setPlanStartTime(null);
					// 设置修改到达时间为空
					pathDetailEntity.setModifyArriveTime(null);
					// 设置修改开始时间为空
					pathDetailEntity.setModifyStartTime(null);
					// 更新走货路径详细信息
					pathDetailDao.updatePathDetail(pathDetailEntity);
					// 不为空,提供货件号,修改后序走货路径
					alterDetail(waybillNo, serialNoList.get(g), nextOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(), transportPathEntity.getTransportModel());
				}
			}
			else {
				// 先更新下一段为合车修改线路
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置出发部门
				pathDetailEntity.setOrigOrgCode(nowOrgCode);
				// 找到应走条目 更新数据为正确的合车后目的地
				List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 未查询到路径详细信息列表
				if (list.size() == 0) {
					// 路径对象为空
					pathDetailEntity = null;
					// 查到多条信息
				}
				else if (list.size() > 1) {
					// 路径不唯一
					// modify by liangfuxiang 2013-5-23下午8:57:45 begin 添加日志
					// 异常
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					logger.error("CalculateTransportPathService[loadVehicle()]" + TransportPathConstants.TRANSPORTPATH_NO_MULT_DETAILMORETHANONE_JOINCAR + TransportPathConstants.WAYBILL_NO
							+ waybillNo + TransportPathConstants.DEST_ORGCODE + nowOrgCode);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_NO_MULT_DETAILMORETHANONE_JOINCAR_GLOB, new Object[] { waybillNo, nowOrgCode });
					// modify by liangfuxiang 2013-5-23下午8:57:51 end;
				}
				else {
					// 复制属性值
					BeanUtils.copyProperties(list.get(0), pathDetailEntity);
				}
				// 路径详细信息为空
				if (null == pathDetailEntity) {
					// 异常：未查找到路径
					// modify by liangfuxiang 2013-5-23下午8:57:45 begin 添加日志
					// 异常：找不到数据
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_JOINCAR, "");
					logger.error("CalculateTransportPathService[loadVehicle()]" + TransportPathConstants.TRANSPORTPATH_NO_CALCULATE_DETAILMORETHANONE_JOINCAR + TransportPathConstants.WAYBILL_NO
							+ waybillNo + TransportPathConstants.DEST_ORGCODE + nowOrgCode);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_NO_CALCULATE_DETAILMORETHANONE_JOINCAR_GLOB, new Object[] { waybillNo, nowOrgCode });
					// modify by liangfuxiang 2013-5-23下午8:57:51 end;
				}
				// 设置目标部门
				pathDetailEntity.setObjectiveOrgCode(nextOrgCode);
				// 设置实际到达时间为空
				pathDetailEntity.setActualArriveTime(null);
				// 设置实际出发时间为空
				pathDetailEntity.setActualStartTime(null);
				// 设置计划到达时间为空
				pathDetailEntity.setPlanArriveTime(null);
				// 设置计划出发时间为空
				pathDetailEntity.setPlanStartTime(null);
				// 设置修改到达时间为空
				pathDetailEntity.setModifyArriveTime(null);
				// 设置修改出发时间为空
				pathDetailEntity.setModifyStartTime(null);
				// 更新走货路径详细信息
				pathDetailDao.updatePathDetail(pathDetailEntity);
				// 否则不提供货件号,修改后序走货路径
				alterDetail(waybillNo, null, nextOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(), transportPathEntity.getTransportModel());
			}
			// 如果合车.则需要修改主表的下一部门字段
			transportPathEntity.setNextOrgCode(nextOrgCode);
			
			//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
			// 分批配载更新主表path
			//transportPathEntity.setTransportPath(getChangedPath(transportPathEntity.getWaybillNo()));
		}
		transportPathEntity.setVehicleNo(vehicleNo);
		// 更新本状态为上一状态
		transportPathEntity.setBeforeAction(transportPathEntity.getAction());
		// 设置 现所处状态.
		transportPathEntity.setAction(action);
		// 更新主表
		transportationPathDao.updateTransportPath(transportPathEntity);
	}

	/**
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#loadVehicleRequiresNewTransactional(java.lang.String, java.util.List, java.lang.String, int,
	 *      int, java.lang.String, java.lang.String, java.lang.String)
	 * @author foss-wuyingjie
	 * @date 2013-2-2 下午1:50:41
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void loadVehicleRequiresNewTransactional(String waybillNo, List<String> serialNoList, String action, int loadQTY, int ifJoinCar, String nowOrgCode, String nextOrgCode, String vehicleNo)
			throws TfrBusinessException {
		// 装车/交接单 人工合车的调整也会在本步进行回调并且修改路径明细
		loadVehicle(waybillNo, serialNoList, action, loadQTY, ifJoinCar, nowOrgCode, nextOrgCode, vehicleNo);
	}

	/**
	 * 出发
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:39:57
	 * @see
	 */
	@Transactional
	public void depart(String waybillNo, List<String> serialNoList, String origOrgCode, Date startTime, String vehicleNo, String action, String truckDetailId) throws TfrBusinessException {
		innerDepart(waybillNo, serialNoList, origOrgCode, startTime, vehicleNo, action, truckDetailId);
	}

	/**
	 * 
	* @Title: departForAirHandover 
	* @Description: 出发
	* @param waybillNo
	* @param serialNoList
	* @param origOrgCode
	* @param startTime
	* @param vehicleNo
	* @param action
	* @param truckDetailId
	* @throws TfrBusinessException  设定文件 
	* @return void    返回类型 
	* @see departForAirHandover
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午3:04:46   
	* @throws
	 */
	public void departForAirHandover(String waybillNo, List<String> serialNoList, String origOrgCode, Date startTime, String vehicleNo, String action, String truckDetailId) throws TfrBusinessException {
		innerDepart(waybillNo, serialNoList, origOrgCode, startTime, vehicleNo, action, truckDetailId);
	}
	
	/**
	 * 
	* @Title: innerDepart 
	* @Description: 出发
	* @param waybillNo
	* @param serialNoList
	* @param origOrgCode
	* @param startTime
	* @param vehicleNo
	* @param action
	* @param truckDetailId  设定文件 
	* @return void    返回类型 
	* @see innerDepart
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午3:04:02   
	* @throws
	 */
	private void innerDepart(String waybillNo, List<String> serialNoList, String origOrgCode, Date startTime, String vehicleNo, String action, String truckDetailId) {
		// 查询走货路径信息
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 判断是否有路径.没有则throw
		if (null != transportPathEntity) {
			// 新建走货路径详细信息对象
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// set出发信息
			transportPathEntity.setBeforeAction(transportPathEntity.getAction());
			// 设置当前状态
			transportPathEntity.setAction(action);
			// 设置当前部门为空
			transportPathEntity.setCurrentOrgCode("");
			// 设置车牌号
			transportPathEntity.setVehicleNo(vehicleNo);
			// 判断是否分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 设置单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置出发部门
				pathDetailEntity.setOrigOrgCode(origOrgCode);
				// 获取当前路段明细信息
				List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 根据返回值是否唯一判断信息是否正确
				if (pathDetailList.size() == 1) {
					// modify by liangfuxiang 2013-3-19下午4:45:28
					// begin:解决job更新是否离开状态与修改走货路径状态的冲突问题
					// 走货路径也许已经入库，单job的状态可能还在离开装填。导致路径详细信息无法及时更新
					// 入库
					/*
					 * if (StringUtils.equals(pathDetailList.get(0).getArriveOrLeave (), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) { //返回 return; } else { // set路径明细状态
					 * pathDetailList.get(0).setArriveOrLeave (TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
					 */
					// 非入库
					if (!StringUtils.equals(pathDetailList.get(0).getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) {
						// set路径明细状态
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
					}
					//已做交接的
					if(StringUtils.equals(pathDetailList.get(0).getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_HANDOVER)){
						// set路径明细状态
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
					}
					// modify by liangfuxiang 2013-3-19下午4:47:35 end;

					// 添加出发时间
					pathDetailList.get(0).setActualStartTime(startTime);
					// 更新车牌号
					pathDetailList.get(0).setVehicleNo(vehicleNo);
					// 更新车辆出发ID
					pathDetailList.get(0).setTruckDetailId(truckDetailId);
					// 更新该条路径明细
					pathDetailDao.updateListPathDetail(pathDetailList);
					// 更新上一条信息中的状态
					PathDetailEntity beforePathDetailEntity = new PathDetailEntity();
					// 设置单号
					beforePathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
					// 流水号非空
					if (StringUtils.isNotEmpty(pathDetailList.get(0).getGoodsNo())) {
						// 设置流水号
						beforePathDetailEntity.setGoodsNo(pathDetailList.get(0).getGoodsNo());
					}
					// 要找到上一段,需要把本段出发部门当作到达部门查询
					beforePathDetailEntity.setObjectiveOrgCode(pathDetailList.get(0).getOrigOrgCode());
					// 获取上一路段明细信息
					List<PathDetailEntity> beforePathDetailList = pathDetailDao.pathDetailNotReleave(beforePathDetailEntity);
					// 走货路径详细信息列表唯一的数据
					if (beforePathDetailList.size() == 1) {
						// 设置路径明细状态 再离开
						beforePathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
						// 更新走货路径详细信息
						pathDetailDao.updateListPathDetail(beforePathDetailList);
						// 不唯一
					}
					else if (beforePathDetailList.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志
						// 得到的明细对应数据大于一条.数据有错误
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_BEFOREDETAILMORETHANONE
								+ TransportPathConstants.WAYBILL_NO
								+ beforePathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING
								+ TransportPathConstants.DEST_ORGCODE
								+ beforePathDetailEntity.getObjectiveOrgCode()
								+ TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(beforePathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + beforePathDetailEntity
										.getGoodsNo()));
						logger.error("CalculateTransportPathService[depart()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { beforePathDetailEntity.getWaybillNo(),
								beforePathDetailEntity.getObjectiveOrgCode(), beforePathDetailEntity.getGoodsNo() });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					// 更新下一条信息中的上一段车牌号
					PathDetailEntity nextPathDetailEntity = new PathDetailEntity();
					// 设置单号
					nextPathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
					// 流水号非空
					if (StringUtils.isNotEmpty(pathDetailList.get(0).getGoodsNo())) {
						// 设置流水号
						nextPathDetailEntity.setGoodsNo(pathDetailList.get(0).getGoodsNo());
					}
					// 要找到下一段,需要把本段到达部门作为开始部门进行查询
					nextPathDetailEntity.setOrigOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
					// 获取下一路段明细信息
					List<PathDetailEntity> nextPathDetailList = pathDetailDao.pathDetailNotReleave(nextPathDetailEntity);
					// 下一路段明细信息唯一
					if (nextPathDetailList.size() == 1) {
						// 设置车牌号
						nextPathDetailList.get(0).setBeforeVehicleNo(vehicleNo);
						// 更新下一路段明细信息
						pathDetailDao.updateListPathDetail(nextPathDetailList);
					}
					else if (nextPathDetailList.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志,细化异常
						// 得到的明细对应数据大于一条.数据有错误
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW
								+ TransportPathConstants.WAYBILL_NO
								+ nextPathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING
								+ TransportPathConstants.CURRENT_ORGCODE
								+ nextPathDetailEntity.getOrigOrgCode()
								+ TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(nextPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + nextPathDetailEntity
										.getGoodsNo()));
						logger.error("CalculateTransportPathService[depart()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW_GLOB, new Object[] { nextPathDetailEntity.getWaybillNo(),
								nextPathDetailEntity.getOrigOrgCode(), nextPathDetailEntity.getGoodsNo() });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					// 更新走货路径
					transportationPathDao.updateTransportPathSelect(transportPathEntity);
					// }
					// 路径详细信息不唯一
				}
				else if (pathDetailList.size() > 1) {
					// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志，细化异常信息
					// 得到的明细对应数据大于一条.数据有错误
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
							+ TransportPathConstants.BLANK_SPACE_STRING +TransportPathConstants.CURRENT_ORGCODE+ pathDetailEntity.getOrigOrgCode();
					logger.error("CalculateTransportPathService[depart()]:" + exps);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_NEW ,new Object[] { pathDetailEntity.getWaybillNo(), pathDetailEntity.getOrigOrgCode(), TransportPathConstants.BLANK_SPACE_STRING });
					// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					// 路径信息为空
				}
				else if (pathDetailList.size() == 0) {
					// 新建走货路径详细信息列表
					List<PathDetailEntity> list = new ArrayList<PathDetailEntity>();
					// 查询走货路径详细信息列表
					list = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 路径唯一
					if (list.size() == 1) {
						// 更新走货路径
						transportationPathDao.updateTransportPathSelect(transportPathEntity);
						// 返回
						return;
					}
					// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志，细化异常信息
					// else {
					// // 得到的明细对应数据大于一条或者没有得到数据.数据有错误
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
					// }
					// 得到多条数据
					else if (list.size() > 1) {
						// 得到多条数据
						String[] exps = TransportPathConstants.PATHDETAIL_ORG_MORE_THAN_ONE.split(":");
						logger.error("CalculateTransportPathService[depart()]:" + exps[0] + pathDetailEntity.getWaybillNo() + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_ORG_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
					}
					else {
						// 未查询到走货路径明细信息
						String[] exps = TransportPathConstants.PATHDETAIL_ORG_IS_NULL.split(":");
						logger.error("CalculateTransportPathService[depart()]:" + exps[0] + pathDetailEntity.getWaybillNo() + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_ORG_IS_NULL_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
					}
					// modify by liangfuxiang 2013-5-23下午10:30:11 end;
				}
				else {
					// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志，细化异常信息
					// 得到的明细为空
					//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
					logger.error("CalculateTransportPathService[depart()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA );
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_GLOB, new Object[] { waybillNo, origOrgCode });
					// modify by liangfuxiang 2013-5-23下午10:30:11 end;
				}
			}
			else {
				// 遍历流水号
				for (int s = 0; s < serialNoList.size(); s++) {
					// 设置单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(serialNoList.get(s));
					// 设置目标部门编号
					pathDetailEntity.setOrigOrgCode(origOrgCode);
					// 获取当前路段明细信息
					List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					// 根据返回值是否唯一判断信息是否正确
					if (pathDetailList.size() == 1) {
						// modify by liangfuxiang 2013-3-19下午4:45:28
						// begin:解决job更新是否离开状态与修改走货路径状态的冲突问题
						// 走货路径也许已经入库，单job的状态可能还在离开装填。导致路径详细信息无法及时更新
						// 入库
						/*
						 * if (StringUtils.equals(pathDetailList.get(0). getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) { //返回 return; } else { // set路径明细状态 pathDetailList.get(
						 * 0).setArriveOrLeave(TransportPathConstants .PATHDETAIL_STATUS_LEAVE);
						 */
						// 非入库
						if (!StringUtils.equals(pathDetailList.get(0).getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) {
							// set路径明细状态
							pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
						}
						//已做交接的
						if(StringUtils.equals(pathDetailList.get(0).getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_HANDOVER)){
							// set路径明细状态
							pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
						}
						// modify by liangfuxiang 2013-3-19下午4:47:35 end;
						// 添加出发时间
						pathDetailList.get(0).setActualStartTime(startTime);
						// 更新车牌号
						pathDetailList.get(0).setVehicleNo(vehicleNo);
						// 更新车辆出发ID
						pathDetailList.get(0).setTruckDetailId(truckDetailId);
						// 更新该条路径明细
						pathDetailDao.updateListPathDetail(pathDetailList);
						// 更新上一条信息中的状态
						PathDetailEntity beforePathDetailEntity = new PathDetailEntity();
						// 设置单号
						beforePathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
						// 流水号非空空
						if (StringUtils.isNotEmpty(pathDetailList.get(0).getGoodsNo())) {
							// 设置流水号
							beforePathDetailEntity.setGoodsNo(pathDetailList.get(0).getGoodsNo());
						}
						// 要找到上一段,需要把本段出发部门当作到达部门查询
						beforePathDetailEntity.setObjectiveOrgCode(pathDetailList.get(0).getOrigOrgCode());
						// 获取上一路段明细信息
						List<PathDetailEntity> beforePathDetailList = pathDetailDao.pathDetailNotReleave(beforePathDetailEntity);
						// 上一路段唯一
						if (beforePathDetailList.size() == 1) {
							// 设置径明细状态 再离开
							beforePathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
							// 更新上一路段明细信息
							pathDetailDao.updateListPathDetail(beforePathDetailList);
							// 上段路径不唯一
						}
						else if (beforePathDetailList.size() > 1) {
							// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志
							// 得到的明细对应数据大于一条.数据有错误
							//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE, "");
							String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW
									+ TransportPathConstants.WAYBILL_NO
									+ beforePathDetailEntity.getWaybillNo()
									+ TransportPathConstants.BLANK_SPACE_STRING
									+ TransportPathConstants.DEST_ORGCODE
									+ beforePathDetailEntity.getObjectiveOrgCode()
									+ TransportPathConstants.BLANK_SPACE_STRING
									+ (StringUtils.isEmpty(beforePathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING
											: (TransportPathConstants.SERIAL_NO + beforePathDetailEntity.getGoodsNo()));
							logger.error("CalculateTransportPathService[depart()]:" + exps);
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_BEFOREDETAILMORETHANONE_NEW_GLOB, new Object[] { beforePathDetailEntity.getWaybillNo(),
									 beforePathDetailEntity.getObjectiveOrgCode(), beforePathDetailEntity.getGoodsNo() });
							// modify by liangfuxiang 2013-5-23下午10:30:11 end;
						}
						// 更新下一条信息中的上一段车牌号
						PathDetailEntity nextPathDetailEntity = new PathDetailEntity();
						// 设置单号
						nextPathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
						// 流水号非空
						if (StringUtils.isNotEmpty(pathDetailList.get(0).getGoodsNo())) {
							// 设置流水号
							nextPathDetailEntity.setGoodsNo(pathDetailList.get(0).getGoodsNo());
						}
						// 要找到下一段,需要把本段到达部门作为开始部门进行查询
						nextPathDetailEntity.setOrigOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
						// 获取下一路段明细信息
						List<PathDetailEntity> nextPathDetailList = pathDetailDao.pathDetailNotReleave(nextPathDetailEntity);
						// 下一路段明细信息唯一
						if (nextPathDetailList.size() == 1) {
							// 设置车牌号
							nextPathDetailList.get(0).setBeforeVehicleNo(vehicleNo);
							// 更新下一路段明细信息
							pathDetailDao.updateListPathDetail(nextPathDetailList);
							// 下一路段明细信息不唯一
						}
						else if (nextPathDetailList.size() > 1) {
							// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志,细化异常
							// 得到的明细对应数据大于一条.数据有错误
							// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE, "");
							String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW
									+ TransportPathConstants.WAYBILL_NO
									+ nextPathDetailEntity.getWaybillNo()
									+ TransportPathConstants.BLANK_SPACE_STRING
									+ TransportPathConstants.CURRENT_ORGCODE
									+ nextPathDetailEntity.getOrigOrgCode()
									+ TransportPathConstants.BLANK_SPACE_STRING
									+ (StringUtils.isEmpty(nextPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + nextPathDetailEntity
											.getGoodsNo()));
							logger.error("CalculateTransportPathService[depart()]:" + exps);
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW_GLOB, new Object[] { nextPathDetailEntity.getWaybillNo(),
									nextPathDetailEntity.getOrigOrgCode(), nextPathDetailEntity.getGoodsNo() });
							// modify by liangfuxiang 2013-5-23下午10:30:11 end;
						}
						// }
						// 路段明细信息 不唯一
					}
					else if (pathDetailList.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志，细化异常信息
						// 得到的明细对应数据大于一条.数据有错误
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING +TransportPathConstants.CURRENT_ORGCODE+ pathDetailEntity.getOrigOrgCode();
						logger.error("CalculateTransportPathService[depart()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
								pathDetailEntity.getOrigOrgCode(), TransportPathConstants.BLANK_SPACE_STRING });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
						
						// 路段明细信息为空
					}
					else if (pathDetailList.size() == 0) {
						// 新建路径详细信息列表
						List<PathDetailEntity> list = new ArrayList<PathDetailEntity>();
						// 查询路径详细信息
						list = pathDetailDao.queryPathDetailList(pathDetailEntity);
						// 路径详细信息唯一
						if (list.size() == 1) {
							// 更新走货路径
							transportationPathDao.updateTransportPathSelect(transportPathEntity);
							// 返回
							return;
						}
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志，细化异常信息
						// else {
						// // 得到的明细对应数据大于一条或者没有得到数据.数据有错误
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
						// }
						// 得到多条数据
						else if (list.size() > 1) {
							// 得到多条数据
							String[] exps = TransportPathConstants.PATHDETAIL_ORG_MORE_THAN_ONE.split(":");
							logger.error("CalculateTransportPathService[depart()]:" + exps[0] + pathDetailEntity.getWaybillNo() + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
							throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_ORG_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
						}
						else {
							// 未查询到走货路径明细信息
							String[] exps = TransportPathConstants.PATHDETAIL_ORG_IS_NULL.split(":");
							logger.error("CalculateTransportPathService[depart()]:" + exps[0] + pathDetailEntity.getWaybillNo() + exps[1] + pathDetailEntity.getOrigOrgCode() + exps[2]);
							throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_ORG_IS_NULL_GLOB , new Object[] { waybillNo, pathDetailEntity.getOrigOrgCode() });
						}
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					else {
						// modify by liangfuxiang 2013-5-24上午10:20:38 begin 增加日志
						logger.error("CalculateTransportPathService[depart()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA);
						// modify by liangfuxiang 2013-5-24上午10:20:43 end;
						// 得到的明细为空
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_SER_GLOB, new Object[] { waybillNo, origOrgCode, serialNoList.get(s) });

					}
				}
				// 更新走货路径
				transportationPathDao.updateTransportPathSelect(transportPathEntity);
			}
		}
		else {
			// modify by liangfuxiang 2013-5-24上午10:20:38 begin 增加日志，修改异常信息
			// 异常：未查找到走货路径信息
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[depart()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午10:32:22 end;
		}
	}

	/**
	 * 到达
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:47:14
	 */
	@Transactional
	public void arrive(String waybillNo, List<String> serialNoList, String arriveOrgCode, Date arriveTime, String action, String vehicleNo) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-18下午6:02:03 begin BUG-12102
		// 验证入参有效性
		verifyParametersForArrive(waybillNo, arriveOrgCode, arriveTime, action, vehicleNo);
		// modify by liangfuxiang 2013-5-18下午6:02:15 end BUG-12102;
		
		// 查找到走货路径信息
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 如果数据不为空
		if (null != transportPathEntity) {
			// 获取目标部门编码
			String destOrgCode = transportPathEntity.getDestOrgCode();
			// 新建走货路径详细信息
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 设置上一状态
			transportPathEntity.setBeforeAction(transportPathEntity.getAction());
			// 设置下一状态
			transportPathEntity.setAction(action);
			// 设置车牌号为空
			transportPathEntity.setVehicleNo("");
			// 设置当前部门编码
			transportPathEntity.setCurrentOrgCode(arriveOrgCode);
			// 设置下一部门编码
			transportPathEntity.setNextOrgCode("");
			// 设置计划出发时间为空
			transportPathEntity.setPlanStartTime(null);
			// 设置计划到达时间为空
			transportPathEntity.setPlanArriveTime(null);
			// 如果不是分批配载,则不需要货件号
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 设置单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置目标
				pathDetailEntity.setObjectiveOrgCode(arriveOrgCode);
				
				// modify by liangfuxiang 2013-7-18上午10:16:29 begin PDA-1320 ：A-B(notleave) B-C C-B(notleave) B-F 这样的情形，
				// 走货路径就会返回多条，故现在作状态无关的，目标部门为arriveOrgCode的走货路径查询，获取最大路段好的即可。
				// 并将比此路段号小的路段的状态全部置为RELEAVE
				// 查询明细条目
				//List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				//获取相同目标部门的最大路段信息
				List<PathDetailEntity> pathDetailList = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
				
				
				// 如果只有唯一一条
				if (pathDetailList.size() == 1) {
					
					//将比此路段号小的路段状态全部置为RELEAVE
					releaveBeforePathDetails(pathDetailList.get(0));
					//将比此路段大的路段状态全部置为NOTLEAVE
					updateBehindPathDetailForNotLeave(pathDetailList.get(0));
					
					// modify by liangfuxiang 2013-7-18上午10:16:29 end PDA-1320 
					
					// modify by liangfuxiang 2013-3-19下午4:45:28
					// begin:解决job更新是否离开状态与修改走货路径状态的冲突问题
					// 走货路径也许已经入库，单job的状态可能还在离开装填。导致路径详细信息无法及时更新
					// 入库
					/*
					 * if (StringUtils.equals(pathDetailList.get(0).getArriveOrLeave (), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) { //返回 return; } else { // set路径明细状态
					 * pathDetailList.get(0).setArriveOrLeave (TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
					 */
					// 非入库
					if (!StringUtils.equals(pathDetailList.get(0).getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) {
						// set路径明细状态
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
					}
					// modify by liangfuxiang 2013-3-19下午4:47:35 end;
					// 添加到达时间
					pathDetailList.get(0).setActualArriveTime(arriveTime);
					
					// modify by liangfuxiang 2013-6-18下午2:09:05 begin BUG-32791 注释掉
					// modify by liangfuxiang 2013-6-14下午2:09:37 begin BUG-30429
					//若实际出发时间为空，则将实际到达时间赋值给实际出发时间
					// if(null==pathDetailList.get(0).getActualStartTime()){
					// pathDetailList.get(0).setActualStartTime(arriveTime);
					// }
					// modify by liangfuxiang 2013-6-14下午2:12:06 end BUG-30429;
					// modify by liangfuxiang 2013-6-18下午2:09:05 end BUG-32791 注释掉
					// 更新明细表
					pathDetailDao.updateListPathDetail(pathDetailList);
					// //更新下一条的调整出发时间和是否调整状态
					PathDetailEntity nextPathDetailEntity = new PathDetailEntity();
					// 设置单号
					nextPathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
					// 流水号非空
					if (StringUtils.isNotEmpty(pathDetailList.get(0).getGoodsNo())) {
						// 设置流水号
						nextPathDetailEntity.setGoodsNo(pathDetailList.get(0).getGoodsNo());
					}
					// 要找到下一段,需要把本段到达部门作为开始部门进行查询
					nextPathDetailEntity.setOrigOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
					// 获取下一路段明细信息
					List<PathDetailEntity> nextPathDetailList = pathDetailDao.pathDetailNotReleave(nextPathDetailEntity);
					// 下一段路径唯一
					if (nextPathDetailList.size() == 1) {
						// 计划开始时间
						Date planStartTime = nextPathDetailList.get(0).getModifyStartTime();
						// 根据方法计算调整后的出发时间
						// 根据车辆牌号和外场,得到需要多少时间进行装卸
						LoadAndUnloadEfficiencyVehicleDto loadAndUnloadEfficiencyVehicleDto = loadAndUnloadEfficiencyVehicleComplexService.gainLoadAndUnloadEfficiencyVehicleUp(vehicleNo,
								arriveOrgCode);
						// 把当前时间+上需要时间得到预计时间
						Long time;
						// 据车辆的车牌号，部门编码，查询装卸车标准
						if (null == loadAndUnloadEfficiencyVehicleDto) {
							// 设置到达时间
							time = arriveTime.getTime();
						}
						else {
							
							// modify by liangfuxiang 2013-6-3下午2:58:10 begin  BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
							//卸车小时数为空
							if(StringUtils.isEmpty(loadAndUnloadEfficiencyVehicleDto.getUnloadHour())){
								logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADHOUR_NULL + TransportPathConstants.VECHLE_NO
										+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
								// 给字符长常量0
								loadAndUnloadEfficiencyVehicleDto.setUnloadHour(TransportPathConstants.CONSTANT_ZERO);
							}
							else{
								//判断是否为整数
								if(!loadAndUnloadEfficiencyVehicleDto.getUnloadHour().matches(TransportPathConstants.CONSTANT_REG_INTEGER)){
									logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADHOUR_NOTINEGER + TransportPathConstants.VECHLE_NO
											+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
									//给字符常量为0
									loadAndUnloadEfficiencyVehicleDto.setUnloadHour(TransportPathConstants.CONSTANT_ZERO);
								}
							}
							
							//卸车分钟数为空
							if(StringUtils.isEmpty(loadAndUnloadEfficiencyVehicleDto.getUnloadMinute())){
								logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADMINUTE_NULL + TransportPathConstants.VECHLE_NO
										+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
								// 给字符长常量0
								loadAndUnloadEfficiencyVehicleDto.setUnloadMinute(TransportPathConstants.CONSTANT_ZERO);
							}
							else{
								//判断是否为整数
								if(!loadAndUnloadEfficiencyVehicleDto.getUnloadMinute().matches(TransportPathConstants.CONSTANT_REG_INTEGER)){
									logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADMINUTE_NOTINEGER + TransportPathConstants.VECHLE_NO
											+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
									//给字符常量为0
									loadAndUnloadEfficiencyVehicleDto.setUnloadMinute(TransportPathConstants.CONSTANT_ZERO);
								}
							}
							// modify by liangfuxiang 2013-6-3下午2:58:29 end;
							
							
							
							// 获取卸车小时数,分钟数 转成LONG类型后和到达时间相加
							int hour = Integer.parseInt(loadAndUnloadEfficiencyVehicleDto.getUnloadHour());
							// 分钟
							int minute = Integer.parseInt(loadAndUnloadEfficiencyVehicleDto.getUnloadMinute());
							// 设置到达时间
							time = (long) (arriveTime.getTime() + hour * threeMillionSixHundredThousand + minute * sixtyThousand);
						}
						// 到达时间
						Date nextStartTime = arriveTime;
						// 到达时间
						nextStartTime = new Date(time);
						
						// modify by liangfuxiang 2013-6-3下午4:09:56 begin BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
						// 如果计算后的出发时间大于现在的预计时间 则修改
						// if ((nextStartTime.compareTo(planStartTime) > 0)) {
						if (null != planStartTime && (nextStartTime.compareTo(planStartTime) > 0)) {
						// modify by liangfuxiang 2013-6-3下午4:10:01 end;
							// 设置下一段的调整出发时间
							nextPathDetailList.get(0).setModifyStartTime(nextStartTime);
						}
						
						// 设置修改时间
						nextPathDetailList.get(0).setIfChangeTime(TransportPathConstants.CHANGETIME);
						// 更新走货路径详情
						pathDetailDao.updateListPathDetail(nextPathDetailList);
						// 判断如果下一段为最后一段.则更新本段和下一段的预计提货时间
						if (StringUtils.equals(destOrgCode, nextPathDetailList.get(0).getObjectiveOrgCode())) {
							// 调综合接口获取到达最终目的地的时间和天数
							DepartureStandardDto departureStandardDto = lineService.queryEarliestDepartureStandard(nextPathDetailList.get(0).getOrigOrgCode(), nextPathDetailList.get(0)
									.getObjectiveOrgCode());
							// 如果综合返回的小时分钟不为空 则表示可以计算预计提货时间
							if (null != departureStandardDto) {
								// 天
								int day = 0;
								// 时间格式
								String hhmm = null;
								// modify by liangfuxiang 2013-6-3下午4:26:11 begin 若到达时间为空  BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
								// 获取天
								//day = departureStandardDto.getArriveDay();
								//非空判断
								if(null!=departureStandardDto.getArriveDay()){
									day = departureStandardDto.getArriveDay();
								}
								
								// 获取时间
								hhmm = departureStandardDto.getArriveTime();
								
								
								if(StringUtils.isEmpty(hhmm)){
									logger.warn("CalculateTransportPathService[arrive()]:"+TransportPathConstants.HHMM_ARRIVETIME_IS_NULL+TransportPathConstants.ORIGORGNAME+nextPathDetailList.get(0).getOrigOrgCode()+TransportPathConstants.COMMA+TransportPathConstants.DESTORGNAME+nextPathDetailList.get(0)
											.getObjectiveOrgCode());
									//给默认值0000
									hhmm=TransportPathConstants.DEFAULT_ARRIVE_TIME;
								}
								//判断是否全部为数字字符
								else if(!hhmm.matches(TransportPathConstants.CONSTANT_REG_INTEGER)){
									logger.warn("CalculateTransportPathService[arrive()]:"+TransportPathConstants.HHMM_ARRIVETIME_NOT_INTEGER+TransportPathConstants.ORIGORGNAME+nextPathDetailList.get(0).getOrigOrgCode()+TransportPathConstants.COMMA+TransportPathConstants.DESTORGNAME+nextPathDetailList.get(0)
											.getObjectiveOrgCode());
									//给默认值0000
									hhmm=TransportPathConstants.DEFAULT_ARRIVE_TIME;
								}
								// modify by liangfuxiang 2013-6-3下午4:26:24 end;
								
								// 获取配置的时间点,如果小于该时间则当天到达派送部门,否则延后一天
								String pickupThresholdTime = "0600";
								// 查询系统配置参数
								ConfigurationParamsEntity pickupThreshold = null;
								try {
									pickupThreshold = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR,
											ConfigurationParamsConstants.TFR_PARM__PICKUP_THRESHOLD, nextPathDetailList.get(0).getOrigOrgCode());
								}
								catch (BusinessException e) {
									// 记录日志
									logger.error("调用 configurationParamsService.queryConfigurationParamsByOrgCode报错 : " + DictionaryConstants.SYSTEM_CONFIG_PARM__TFR
											+ ConfigurationParamsConstants.TFR_PARM__PICKUP_THRESHOLD + nextPathDetailList.get(0).getOrigOrgCode());
								}
								// 系统配置参数非空
								if (pickupThreshold != null && StringUtils.isNotEmpty(pickupThreshold.getConfValue())) {
									// 获取系统时间
									
									// modify by liangfuxiang 2013-6-3下午4:35:09 begin 判断pickupThresholdTime的有效性 BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
									// 系统配置项的值非数字
									if (!pickupThreshold.getConfValue().matches(TransportPathConstants.CONSTANT_REG_INTEGER)) {
										logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.CONFIGURATIONPARAMSENTITY_CONFIG_VALUE_NOT_INTEGER
												+ TransportPathConstants.CONFIGURATIONPARAMSENTITY_PARAM + DictionaryConstants.SYSTEM_CONFIG_PARM__TFR + TransportPathConstants.COMMA
												+ TransportPathConstants.TFR_PARM_PICKUP_THRESHOLD + ConfigurationParamsConstants.TFR_PARM__PICKUP_THRESHOLD + TransportPathConstants.COMMA
												+ TransportPathConstants.DEPT_ORG_CODE + nextPathDetailList.get(0).getOrigOrgCode());
									}
									else {
										// 赋值
										pickupThresholdTime = pickupThreshold.getConfValue();
									}
									// modify by liangfuxiang 2013-6-3下午4:35:43 end;
								}
								// 把到达时间拆分为天和小时分钟
								Date arriveTimeDate = DateUtils.convert(DateUtils.convert(arriveTime, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
								// 设置格式
								SimpleDateFormat sdf2 = new SimpleDateFormat("HHmm");
								// 格式化时间格式
								String arriveTimeHHMM = sdf2.format(arriveTime);
								// 如果到达的时间大于设置时间
								if (Integer.parseInt(pickupThresholdTime) < Integer.parseInt(arriveTimeHHMM)) {
									// 设置天
									day = day + 1;
								}
								// 根据到达日期,预计到达派送部门小时分钟,预计天数计算预计到达时间
								Date planPickupTime = TimeUtils.convertStringToDate(arriveTimeDate, hhmm, day);
								// 更新本段记录
								pathDetailList.get(0).setPlanPickupTime(planPickupTime);
								// 更新走货详细信息
								pathDetailDao.updateListPathDetail(pathDetailList);
								// 更新最后一段记录
								nextPathDetailList.get(0).setPlanPickupTime(planPickupTime);
								// 更新走货路径详细信息列表
								pathDetailDao.updateListPathDetail(nextPathDetailList);
							}
						}
						// 下一路径不唯一
					}
					else if (nextPathDetailList.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志,细化异常
						// 得到的明细对应数据大于一条.数据有错误
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW
								+ TransportPathConstants.WAYBILL_NO
								+ nextPathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING
								+ TransportPathConstants.CURRENT_ORGCODE
								+ nextPathDetailEntity.getOrigOrgCode()
								+ TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(nextPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + nextPathDetailEntity
										.getGoodsNo()));
						logger.error("CalculateTransportPathService[arrive()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW_GLOB, new Object[] { nextPathDetailEntity.getWaybillNo(),
								nextPathDetailEntity.getOrigOrgCode(), nextPathDetailEntity.getGoodsNo() });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					// 查询明细表得到下一路段信息
					pathDetailEntity.setOrigOrgCode(arriveOrgCode);
					// 设置目标部门编码为空
					pathDetailEntity.setObjectiveOrgCode("");
					// 更新路径详细信息
					pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					// 路径详细信息唯一
					if (pathDetailList.size() == 1) {
						// 设置下一部门 再更新主表
						transportPathEntity.setNextOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
						// 设置出发到达时间
						transportPathEntity.setPlanStartTime(pathDetailList.get(0).getModifyStartTime());
						// 设置几乎到达时间
						transportPathEntity.setPlanArriveTime(pathDetailList.get(0).getModifyArriveTime());
						// 更新走货路径
						transportationPathDao.updateTransportPath(transportPathEntity);
						// 路径详细信息不唯一
					}
					else if (pathDetailList.size() > 1) {
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志
						// 得到的明细对应数据大于一条.数据有错误
						//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_BEFOREDETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.CURRENT_ORGCODE + pathDetailEntity.getOrigOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
						logger.error("CalculateTransportPathService[arrive()]:" + exps);
						throw new TfrBusinessException();
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					// }
					// 路径详细信息不唯一
				}
				else if (pathDetailList.size() > 1) {
					// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常信息
					// 得到的明细对应数据大于一条.数据有错误
					//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_BEFOREDETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
							+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + pathDetailEntity.getOrigOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
							+ (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
					logger.error("CalculateTransportPathService[arrive()]:" + exps);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
							pathDetailEntity.getOrigOrgCode(), TransportPathConstants.BLANK_SPACE_STRING });
					// modify by liangfuxiang 2013-5-23下午10:30:11 end;
				}
				else {
					// modify by liangfuxiang 2013-5-24上午10:42:08 begin 增加日志，细化异常信息
					// 没有得到数据
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
					logger.error("CalculateTransportPathService[arrive()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO
							+ pathDetailEntity.getWaybillNo() + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORG_CODE_IS_NULL + pathDetailEntity.getObjectiveOrgCode());
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB,new Object[] { pathDetailEntity.getWaybillNo(),
							pathDetailEntity.getObjectiveOrgCode(), TransportPathConstants.BLANK_SPACE_STRING });
					// modify by liangfuxiang 2013-5-24上午10:42:12 end;
				}
			}
			else {
				
				// modify by liangfuxiang 2013-5-18下午6:06:13 begin BUG-12102;
				// 分批配载时，流水号非空
				if (CollectionUtils.isEmpty(serialNoList)) {
					logger.error("CalculateTransportPathService[arrive()]:" + TransportPathConstants.ARRIVE_SERIALNO_NULL);
					throw new TfrBusinessException(TransportPathConstants.ARRIVE_SERIALNO_NULL_GLOB);
				}
				// modify by liangfuxiang 2013-5-18下午6:06:27 end;
				
				// 遍历
				for (int s = 0; s < serialNoList.size(); s++) {
					// 设置单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(serialNoList.get(s));
					// 设置出发部门
					pathDetailEntity.setOrigOrgCode(null);
					// 设置目标部门编码
					pathDetailEntity.setObjectiveOrgCode(arriveOrgCode);
					
					// modify by liangfuxiang 2013-7-18上午10:16:29 begin PDA-1320 ：A-B(notleave) B-C C-B(notleave) B-F 这样的情形，
					// 走货路径就会返回多条，故现在作状态无关的，目标部门为arriveOrgCode的走货路径查询，获取最大路段好的即可。
					// 并将比此路段号小的路段的状态全部置为RELEAVE
					// 查询明细条目
					//List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					//获取相同目标部门的最大路段信息
					List<PathDetailEntity> pathDetailList = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
					
					// 如果只有唯一一条
					if (pathDetailList.size() == 1) {
						
						//将比此路段号小的路段状态全部置为RELEAVE
						releaveBeforePathDetails(pathDetailList.get(0));
						//将比此路段大的路段状态全部置为NOTLEAVE
						updateBehindPathDetailForNotLeave(pathDetailList.get(0));
						
						// modify by liangfuxiang 2013-7-18上午10:16:29 end PDA-1320 
						
						// modify by liangfuxiang 2013-3-19下午4:45:28
						// begin:解决job更新是否离开状态与修改走货路径状态的冲突问题
						// 走货路径也许已经入库，单job的状态可能还在到达装填。导致路径详细信息无法及时更新
						// 入库
						/*
						 * if (StringUtils.equals(pathDetailList.get(0). getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) { //返回 return; } else { // set路径明细状态 pathDetailList.get(
						 * 0).setArriveOrLeave(TransportPathConstants .PATHDETAIL_STATUS_ARRIVE);
						 */
						// 非入库状态
						if (!StringUtils.equals(pathDetailList.get(0).getArriveOrLeave(), TransportPathConstants.PATHDETAIL_STATUS_INSTORE)) {
							// set路径明细状态
							pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
						}
						// modify by liangfuxiang 2013-3-19下午4:47:35 end;
						// 添加到达时间
						pathDetailList.get(0).setActualArriveTime(arriveTime);
						
						// modify by liangfuxiang 2013-6-18下午2:09:05 begin BUG-32791 注释掉
						// modify by liangfuxiang 2013-6-14下午2:09:37 begin BUG-30429
						//若实际出发时间为空，则将实际到达时间赋值给实际出发时间
						// if(null==pathDetailList.get(0).getActualStartTime()){
						// pathDetailList.get(0).setActualStartTime(arriveTime);
						// }
						// modify by liangfuxiang 2013-6-14下午2:12:06 end BUG-30429;
						// modify by liangfuxiang 2013-6-18下午2:10:15 end; BUG-32791
						// 更新明细表
						pathDetailDao.updateListPathDetail(pathDetailList);
						// //更新下一条的调整出发时间和是否调整状态
						PathDetailEntity nextPathDetailEntity = new PathDetailEntity();
						// 设置单号
						nextPathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
						// 流水号非空
						if (StringUtils.isNotEmpty(pathDetailList.get(0).getGoodsNo())) {
							// 设置流水号
							nextPathDetailEntity.setGoodsNo(pathDetailList.get(0).getGoodsNo());
						}
						// 要找到下一段,需要把本段到达部门作为开始部门进行查询
						nextPathDetailEntity.setOrigOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
						// 获取下一路段明细信息
						List<PathDetailEntity> nextPathDetailList = pathDetailDao.pathDetailNotReleave(nextPathDetailEntity);
						// 下一路段明细信息唯一
						if (nextPathDetailList.size() == 1) {
							// 设置计划出发时间
							Date planStartTime = nextPathDetailList.get(0).getModifyStartTime();
							// 根据方法计算调整后的出发时间
							// 根据车辆牌号和外场,
							// 得到需要多少时间进行装卸
							LoadAndUnloadEfficiencyVehicleDto loadAndUnloadEfficiencyVehicleDto = loadAndUnloadEfficiencyVehicleComplexService.gainLoadAndUnloadEfficiencyVehicle(vehicleNo,
									arriveOrgCode);
							// 把当前时间+上需要时间得到预计时间
							Long time;
							// 根据车辆的车牌号，部门编码，查询装卸车标准（卸一车需要多长时间）为空
							if (null == loadAndUnloadEfficiencyVehicleDto) {
								// 到达时间
								time = arriveTime.getTime();
							}
							else {
								
								// modify by liangfuxiang 2013-6-3下午2:58:10 begin  BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
								//卸车小时数为空
								if(StringUtils.isEmpty(loadAndUnloadEfficiencyVehicleDto.getUnloadHour())){
									logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADHOUR_NULL + TransportPathConstants.VECHLE_NO
											+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
									// 给字符长常量0
									loadAndUnloadEfficiencyVehicleDto.setUnloadHour(TransportPathConstants.CONSTANT_ZERO);
								}
								else{
									//判断是否为整数
									if(!loadAndUnloadEfficiencyVehicleDto.getUnloadHour().matches(TransportPathConstants.CONSTANT_REG_INTEGER)){
										logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADHOUR_NOTINEGER + TransportPathConstants.VECHLE_NO
												+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
										//给字符常量为0
										loadAndUnloadEfficiencyVehicleDto.setUnloadHour(TransportPathConstants.CONSTANT_ZERO);
									}
								}
								
								//卸车分钟数为空
								if(StringUtils.isEmpty(loadAndUnloadEfficiencyVehicleDto.getUnloadMinute())){
									logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADMINUTE_NULL + TransportPathConstants.VECHLE_NO
											+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
									// 给字符长常量0
									loadAndUnloadEfficiencyVehicleDto.setUnloadMinute(TransportPathConstants.CONSTANT_ZERO);
								}
								else{
									//判断是否为整数
									if(!loadAndUnloadEfficiencyVehicleDto.getUnloadMinute().matches(TransportPathConstants.CONSTANT_REG_INTEGER)){
										logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.LOADANDUNLOADEFFICIENCYVEHICLE_UNLOADMINUTE_NOTINEGER + TransportPathConstants.VECHLE_NO
												+ vehicleNo + TransportPathConstants.COMMA + TransportPathConstants.OUTORGNO + arriveOrgCode);
										//给字符常量为0
										loadAndUnloadEfficiencyVehicleDto.setUnloadMinute(TransportPathConstants.CONSTANT_ZERO);
									}
								}
								// modify by liangfuxiang 2013-6-3下午2:58:29 end;
								
								
								// 获取卸车小时数,
								// 分钟数 转成LONG类型后和到达时间相加
								int hour = Integer.parseInt(loadAndUnloadEfficiencyVehicleDto.getUnloadHour());
								// 分
								int minute = Integer.parseInt(loadAndUnloadEfficiencyVehicleDto.getUnloadMinute());
								// 时间
								time = arriveTime.getTime() + hour * threeMillionSixHundredThousand + minute * sixtyThousand;
							}
							// 开始时间
							Date nextStartTime = arriveTime;
							// 开始时间
							nextStartTime = new Date(time);
							// modify by liangfuxiang 2013-6-3下午4:09:56 begin BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
							// 如果计算后的出发时间大于现在的预计时间 则修改
							// if ((nextStartTime.compareTo(planStartTime) > 0)) {
							if (null != planStartTime && (nextStartTime.compareTo(planStartTime) > 0)) {
							// modify by liangfuxiang 2013-6-3下午4:10:01 end;
								// 设置下一段的调整出发时间
								nextPathDetailList.get(0).setModifyStartTime(nextStartTime);
							}
							// 设置修改时间
							nextPathDetailList.get(0).setIfChangeTime(TransportPathConstants.CHANGETIME);
							// 更新走货路径详细信息
							pathDetailDao.updateListPathDetail(nextPathDetailList);
							// 判断如果下一段为最后一段.
							// 则更新本段和下一段的预计提货时间
							if (StringUtils.equals(destOrgCode, nextPathDetailList.get(0).getObjectiveOrgCode())) {
								// 调综合接口获取到达最终目的地的时间和天数
								DepartureStandardDto departureStandardDto = lineService.queryEarliestDepartureStandard(nextPathDetailList.get(0).getOrigOrgCode(), nextPathDetailList.get(0)
										.getObjectiveOrgCode());
								// 如果综合返回的小时分钟不为空 则表示可以计算预计提货时间
								if (null != departureStandardDto) {
									// 天
									int day = 0;
									// 时间格式
									String hhmm = null;
									// modify by liangfuxiang 2013-6-3下午4:26:11 begin 若到达时间为空  BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
									// 天
									//day = departureStandardDto.getArriveDay();
									//非空时，赋值
									if (null != departureStandardDto.getArriveDay()) {
										day = departureStandardDto.getArriveDay();
									}

									// 时间
									hhmm = departureStandardDto.getArriveTime();
									//为空
									if(StringUtils.isEmpty(hhmm)){
										logger.warn("CalculateTransportPathService[arrive()]:"+TransportPathConstants.HHMM_ARRIVETIME_IS_NULL+TransportPathConstants.ORIGORGNAME+nextPathDetailList.get(0).getOrigOrgCode()+TransportPathConstants.COMMA+TransportPathConstants.DESTORGNAME+nextPathDetailList.get(0)
												.getObjectiveOrgCode());
										//给默认值0000
										hhmm=TransportPathConstants.DEFAULT_ARRIVE_TIME;
									}
									//判断是否全部为数字字符
									else if(!hhmm.matches(TransportPathConstants.CONSTANT_REG_INTEGER)){
										logger.warn("CalculateTransportPathService[arrive()]:"+TransportPathConstants.HHMM_ARRIVETIME_NOT_INTEGER+TransportPathConstants.ORIGORGNAME+nextPathDetailList.get(0).getOrigOrgCode()+TransportPathConstants.COMMA+TransportPathConstants.DESTORGNAME+nextPathDetailList.get(0)
												.getObjectiveOrgCode());
										//给默认值0000
										hhmm=TransportPathConstants.DEFAULT_ARRIVE_TIME;
									}
									// modify by liangfuxiang 2013-6-3下午4:26:24 end;
									
									// 获取配置的时间点,如果小于该时间则当天到达派送部门,
									// 否则延后一天
									// 时间格式
									String pickupThresholdTime = "0600";
									// 获取系统参数
									ConfigurationParamsEntity pickupThreshold = null;
									// 系统参数非空
									try {
										pickupThreshold = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR,
												ConfigurationParamsConstants.TFR_PARM__PICKUP_THRESHOLD, nextPathDetailList.get(0).getOrigOrgCode());
									}
									catch (BusinessException e) {
										// 记录日志
										logger.error("调用 configurationParamsService.queryConfigurationParamsByOrgCode报错 : " + DictionaryConstants.SYSTEM_CONFIG_PARM__TFR
												+ ConfigurationParamsConstants.TFR_PARM__PICKUP_THRESHOLD + nextPathDetailList.get(0).getOrigOrgCode());
									}
									// 系统配置参数非空
									if (pickupThreshold != null && StringUtils.isNotEmpty(pickupThreshold.getConfValue())) {
										// modify by liangfuxiang 2013-6-3下午4:35:09 begin 判断pickupThresholdTime的有效性 BUG-21501 中转JOB更新走货路径状态异常 原因：时间戳为空异常
										// 获取系统参数时间
										//pickupThresholdTime = pickupThreshold.getConfValue();
										// 系统配置项的值非数字
										if (!pickupThreshold.getConfValue().matches(TransportPathConstants.CONSTANT_REG_INTEGER)) {
											logger.warn("CalculateTransportPathService[arrive()]:" + TransportPathConstants.CONFIGURATIONPARAMSENTITY_CONFIG_VALUE_NOT_INTEGER
													+ TransportPathConstants.CONFIGURATIONPARAMSENTITY_PARAM + DictionaryConstants.SYSTEM_CONFIG_PARM__TFR + TransportPathConstants.COMMA
													+ TransportPathConstants.TFR_PARM_PICKUP_THRESHOLD + ConfigurationParamsConstants.TFR_PARM__PICKUP_THRESHOLD + TransportPathConstants.COMMA
													+ TransportPathConstants.DEPT_ORG_CODE + nextPathDetailList.get(0).getOrigOrgCode());
										}
										else {
											// 赋值
											pickupThresholdTime = pickupThreshold.getConfValue();
										}
										// modify by liangfuxiang 2013-6-3下午4:35:43 end;
									}
									// 把到达时间拆分为天和小时分钟
									Date arriveTimeDate = DateUtils.convert(DateUtils.convert(arriveTime, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
									// 时间格式
									SimpleDateFormat sdf2 = new SimpleDateFormat("HHmm");
									// 格式化到达时间格式
									String arriveTimeHHMM = sdf2.format(arriveTime);
									// 如果到达的时间大于设置时间
									if (Integer.parseInt(pickupThresholdTime) < Integer.parseInt(arriveTimeHHMM)) {
										// 天
										day = day + 1;
									}
									// 根据到达日期,预计到达派送部门小时分钟,
									// 预计天数计算预计到达时间
									Date planPickupTime = TimeUtils.convertStringToDate(arriveTimeDate, hhmm, day);
									// 更新本段记录
									pathDetailList.get(0).setPlanPickupTime(planPickupTime);
									// 更新领
									pathDetailDao.updateListPathDetail(pathDetailList);
									// 更新最后一段记录
									nextPathDetailList.get(0).setPlanPickupTime(planPickupTime);
									// 更新领
									pathDetailDao.updateListPathDetail(nextPathDetailList);
								}
							}
							// 若下一路段信息不唯一
						}
						else if (nextPathDetailList.size() > 1) {
							// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志,细化异常
							// 得到的明细对应数据大于一条.数据有错误
							// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE, "");
							String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW
									+ TransportPathConstants.WAYBILL_NO
									+ nextPathDetailEntity.getWaybillNo()
									+ TransportPathConstants.BLANK_SPACE_STRING
									+ TransportPathConstants.CURRENT_ORGCODE
									+ nextPathDetailEntity.getOrigOrgCode()
									+ TransportPathConstants.BLANK_SPACE_STRING
									+ (StringUtils.isEmpty(nextPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + nextPathDetailEntity
											.getGoodsNo()));
							logger.error("CalculateTransportPathService[arrive()]:" + exps);
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_NEXTDETAILMORETHANONE_NEW_GLOB, new Object[] { nextPathDetailEntity.getWaybillNo(),
									nextPathDetailEntity.getOrigOrgCode(), nextPathDetailEntity.getGoodsNo() });
							// modify by liangfuxiang 2013-5-23下午10:30:11 end;
							
						}
						// }
						// 走货路径详细信息不唯一
					}
					else if (pathDetailList.size() > 1) {
						// 得到的明细对应数据大于一条.
						// 数据有错误
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常
						// 得到的明细对应数据大于一条.数据有错误
						//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + pathDetailEntity.getObjectiveOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
						logger.error("CalculateTransportPathService[arrive()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB,new Object[] { pathDetailEntity.getWaybillNo(),
								pathDetailEntity.getObjectiveOrgCode(), pathDetailEntity.getGoodsNo() });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					else {
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常
						// 没有得到数据
						//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + pathDetailEntity.getObjectiveOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
						logger.error("CalculateTransportPathService[arrive()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_DES_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
								pathDetailEntity.getObjectiveOrgCode(), pathDetailEntity.getGoodsNo() });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
					// 查询明细表得到下一路段信息
					pathDetailEntity.setOrigOrgCode(arriveOrgCode);
					// 设置目标部门编码
					pathDetailEntity.setObjectiveOrgCode(null);
					// 更新走货路径详细信息
					pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					// 信息唯一
					if (pathDetailList.size() == 1) {
						// 设置下一部门 再更新主表
						transportPathEntity.setNextOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
						// 设置出发到达时间
						transportPathEntity.setPlanStartTime(pathDetailList.get(0).getModifyStartTime());
						// 设置计划到达时间
						transportPathEntity.setPlanArriveTime(pathDetailList.get(0).getModifyArriveTime());
						// 更新走货路径
						transportationPathDao.updateTransportPath(transportPathEntity);
						// 走货路径不唯一
					}
					else if (pathDetailList.size() > 1) {
						// 查询下一路段得到的明细对应数据大于一条.
						// 数据有错误
						// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常
						// 得到的明细对应数据大于一条.数据有错误
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
								+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.CURRENT_ORGCODE + pathDetailEntity.getOrigOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
								+ (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
						logger.error("CalculateTransportPathService[arrive()]:" + exps);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_CURR_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
								pathDetailEntity.getOrigOrgCode(), pathDetailEntity.getGoodsNo() });
						// modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
				}
			}
		}
		else {
			// modify by liangfuxiang 2013-5-24上午10:20:38 begin 增加日志，修改异常信息
			// 异常：未查找到走货路径信息
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[arrive()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午10:32:22 end;
		}
	}

	/** 
	* @Title: queryMaxRouteNoPathDetailEntityWithObjOrgCode 
	* @Description: 获取相同目标部门的最大路段信息
	* @param pathDetailEntity
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see queryMaxRouteNoPathDetailEntityWithObjOrgCode
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-18 上午10:54:53   
	* @throws 
	*/ 
	private List<PathDetailEntity> queryMaxRouteNoPathDetailEntityWithObjOrgCode(PathDetailEntity pathDetailEntity) {
		
		return pathDetailDao.queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);

	}

	/**
	 * @Title: verifyParametersForArrive
	 * @Description: 验证入参有效性
	 * @param waybillNo
	 * @param arriveOrgCode
	 * @param arriveTime
	 * @param action
	 * @param vehicleNo 设定文件
	 * @return void 返回类型
	 * @see verifyParametersForArrive
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-18 下午6:06:40
	 * @throws
	 */
	private void verifyParametersForArrive(String waybillNo, String arriveOrgCode, Date arriveTime, String action, String vehicleNo) {

		// 运单号为空
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[verifyParametersForArrive()]:" + TransportPathConstants.ARRIVE_WAYBILLNO_NULL);
			throw new TfrBusinessException(TransportPathConstants.ARRIVE_WAYBILLNO_NULL_GLOB);
		}

		// 到达部门为空
		if (StringUtils.isEmpty(arriveOrgCode)) {
			logger.error("CalculateTransportPathService[verifyParametersForArrive()]:" + TransportPathConstants.ARRIVE_ARRIVEORGCODE_NULL);
			throw new TfrBusinessException(TransportPathConstants.ARRIVE_ARRIVEORGCODE_NULL_GLOB);
		}

		// 到达时间为空
		if (null == arriveTime) {
			logger.error("CalculateTransportPathService[verifyParametersForArrive()]:" + TransportPathConstants.ARRIVE_ARRIVETIME_NULL);
			throw new TfrBusinessException(TransportPathConstants.ARRIVE_ARRIVETIME_NULL_GLOB);
		}
		// 到达走货路径状态为空
		if (StringUtils.isEmpty(action)) {
			logger.error("CalculateTransportPathService[verifyParametersForArrive()]:" + TransportPathConstants.ARRIVE_ACTION_NULL);
			throw new TfrBusinessException(TransportPathConstants.ARRIVE_ACTION_NULL_GLOB);
		}

		// 车牌号为空
		if (StringUtils.isEmpty(vehicleNo)) {
			logger.error("CalculateTransportPathService[verifyParametersForArrive()]:" + TransportPathConstants.ARRIVE_VEHICLENO_NULL);
			throw new TfrBusinessException(TransportPathConstants.ARRIVE_VEHICLENO_NULL_GLOB);
		}

	}

	/**
	 * 卸车/入库 以票为单位
	 * 
	 * 
	 * @author huyue
	 * @date 2013-1-23 上午9:28:04
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#inStorage(java.lang.String, java.util.List, java.lang.String, java.lang.String)
	 */
	@Transactional
	public void inStorageList(String waybillNo, List<String> goodsNoList, String orgCode, String action) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-20下午4:21:14 begin 加强入参检验
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[inStorageList()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		// 目标部门非空判断
		if (StringUtils.isEmpty(orgCode)) {
			logger.error("CalculateTransportPathService[inStorage()]:" + TransportPathConstants.INSTORAGE_INPUT_ORGCODE_NULL);
			throw new TfrBusinessException(TransportPathConstants.INSTORAGE_INPUT_ORGCODE_NULL_GLOB);
		}
		// modify by liangfuxiang 2013-5-20下午4:21:24 end;
		
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 如果查询条目不为空
		if (null != transportPathEntity) {
			// 走货路径详细信息对象
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 走货路径详细信息列表
			List<PathDetailEntity> pathDetailList;
			// 如果本状态不是入库 则更新状态 否则不更新
			if (!StringUtils.equals(transportPathEntity.getAction(), TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE)) {
				
				// modify by liangfuxiang 2013-5-20下午4:15:10 begin
				if (StringUtils.isEmpty(action)) {
					logger.error("CalculateTransportPathService[inStorageList()]:" + TransportPathConstants.PATH_DETAIL_ACTION_NULL);
					throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_ACTION_NULL_GLOB);
				}
				// modify by liangfuxiang 2013-5-20下午4:15:14 end;
				
				// 更新本状态为上一状态
				transportPathEntity.setBeforeAction(transportPathEntity.getAction());
				// 设置当前状态
				transportPathEntity.setAction(action);
				// 更新走货路径
				transportationPathDao.updateTransportPath(transportPathEntity);
			}
			// 如果不是分批配载,则不需要货件号
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置目标部门编码
				pathDetailEntity.setObjectiveOrgCode(orgCode);
				
				// modify by liangfuxiang 2013-7-18上午10:16:29 begin PDA-1320 ：A-B(notleave) B-C C-B(notleave) B-F 这样的情形，
				// 走货路径就会返回多条，故现在作状态无关的，目标部门为arriveOrgCode的走货路径查询，获取最大路段好的即可。
				// 并将比此路段号小的路段的状态全部置为RELEAVE
				// 查询走货路径详细信息列表
				//pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				//获取相同目标部门的最大路段信息
				pathDetailList = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
				
				// 如果查询条目唯一
				if (pathDetailList.size() == 1) {
					
					//将比此路段号小的路段状态全部置为RELEAVE
					releaveBeforePathDetails(pathDetailList.get(0));
					//将比此路段大的路段状态全部置为NOTLEAVE
					updateBehindPathDetailForNotLeave(pathDetailList.get(0));
					
					// modify by liangfuxiang 2013-7-18上午10:16:29 end PDA-1320 
					
					// 更新状态
					pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
					// 更新明细数据
					pathDetailDao.updateListPathDetail(pathDetailList);
					// 设置本部门
					transportPathEntity.setCurrentOrgCode(orgCode);
					// 设置下一部门
					transportPathEntity.setNextOrgCode(pathDetailList.get(0).getNextDestOrgCode());
					// 更新主表
					transportationPathDao.updateTransportPath(transportPathEntity);
					// 未查询到走货路径详细信息
				}
				else if (pathDetailList.size() == 0) {
					// 查询走货路径详细信息
					List<PathDetailEntity> list = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 走货路径详细信息唯一
					if (list.size() == 1) {
						// 返回
						return;
					}
					// modify by liangfuxiang 2013-5-20下午4:27:53 begin
					/*
					 * else { // 得到的明细对应数据大于一条或者没有得到数据.数据有错误 throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, ""); }
					 */
					else if (pathDetailList.size() > 1) {
						String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
						logger.error("CalculateTransportPathService[inStorageList()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, orgCode });
					}
					// 未查询到走货路径
					else {
						String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
						logger.error("CalculateTransportPathService[inStorageList()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_GLOB,new Object[]{waybillNo,orgCode});
					}
					// modify by liangfuxiang 2013-5-20下午4:27:58 end;
				}
				else {
					// modify by liangfuxiang 2013-5-20下午4:30:59 begin
					// 得到的明细对应数据大于一条或者没有得到数据.数据有错误
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
					String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
					logger.error("CalculateTransportPathService[inStorageList()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
					throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB,new Object[]{waybillNo,orgCode});
					// modify by liangfuxiang 2013-5-20下午4:31:04 end;
				}
			}
			else {
				
				// modify by liangfuxiang 2013-5-20下午4:25:15 begin
				if (CollectionUtils.isEmpty(goodsNoList)) {
					logger.error("CalculateTransportPathService[inStorageList()]:" + TransportPathConstants.SERIALNO_IS_NULL);
					throw new TfrBusinessException(TransportPathConstants.SERIALNO_IS_NULL_GLOB);
				}
				// modify by liangfuxiang 2013-5-20下午4:25:21 end;
				// 遍历流水号
				for (int g = 0; g < goodsNoList.size(); g++) {
					// 设置单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(goodsNoList.get(g));
					// 设置目的地编码
					pathDetailEntity.setObjectiveOrgCode(orgCode);
					// modify by liangfuxiang 2013-7-18上午10:16:29 begin PDA-1320 ：A-B(notleave) B-C C-B(notleave) B-F 这样的情形，
					// 走货路径就会返回多条，故现在作状态无关的，目标部门为arriveOrgCode的走货路径查询，获取最大路段好的即可。
					// 并将比此路段号小的路段的状态全部置为RELEAVE
					// 查询走货路径详细信息列表
					//pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					//获取相同目标部门的最大路段信息
					pathDetailList = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
					
					// 如果查询条目唯一
					if (pathDetailList.size() == 1) {
						
						//将比此路段号小的路段状态全部置为RELEAVE
						releaveBeforePathDetails(pathDetailList.get(0));
						//将比此路段大的路段状态全部置为NOTLEAVE
						updateBehindPathDetailForNotLeave(pathDetailList.get(0));
						
						// modify by liangfuxiang 2013-7-18上午10:16:29 end PDA-1320 
						
						// 更新状态
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
						// 更新明细数据
						pathDetailDao.updateListPathDetail(pathDetailList);
						// 设置本部门
						transportPathEntity.setCurrentOrgCode(orgCode);
						// 设置下一部门
						transportPathEntity.setNextOrgCode(pathDetailList.get(0).getNextDestOrgCode());
						// 更新主表
						transportationPathDao.updateTransportPath(transportPathEntity);
						// 走货路径详细信息为空
					}
					else if (pathDetailList.size() == 0) {
						// 查询走货路径详细信息
						List<PathDetailEntity> list = pathDetailDao.queryPathDetailList(pathDetailEntity);
						// 走货路径详细信息唯一
						if (list.size() == 1) {
							// 返回
							return;
						}
						// modify by liangfuxiang 2013-5-20下午4:27:53 begin
						/*
						 * else { // 得到的明细对应数据大于一条或者没有得到数据.数据有错误 throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, ""); }
						 */
						else if (pathDetailList.size() > 1) {
							String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
							logger.error("CalculateTransportPathService[inStorageList()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
							throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, orgCode });
						}
						// 未查询到走货路径
						else {
							String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
							logger.error("CalculateTransportPathService[inStorageList()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
							throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_CURR_GLOB,new Object[] { waybillNo, orgCode });
						}
						// modify by liangfuxiang 2013-5-20下午4:27:58 end;
						
					}
					else {
						// modify by liangfuxiang 2013-5-20下午4:30:59 begin 
						// 得到的明细对应数据大于一条或者没有得到数据.数据有错误
						//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, "");
						String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
						logger.error("CalculateTransportPathService[inStorageList()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
						throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, orgCode });
						// modify by liangfuxiang 2013-5-20下午4:31:04 end;
					}
				}
			}
		}
		else {
			// modify by liangfuxiang 2013-5-24上午10:20:38 begin 增加日志，修改异常信息
			// 异常：
			// 未查找到走货路径信息
			//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[inStorageList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午10:32:22 end;
		}
	}

	/**
	 * 卸车/入库
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:41:05
	 */
	public void inStorage(String waybillNo, String goodsNo, String orgCode, String action) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-20下午3:50:20 begin 加强验证
		//非空判断
		if(StringUtils.isEmpty(waybillNo)){
			logger.error("CalculateTransportPathService[inStorage()]:"+TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		//目标部门非空判断
		if(StringUtils.isEmpty(orgCode)){
			logger.error("CalculateTransportPathService[inStorage()]:"+TransportPathConstants.INSTORAGE_INPUT_ORGCODE_NULL);
			throw new TfrBusinessException(TransportPathConstants.INSTORAGE_INPUT_ORGCODE_NULL_GLOB);
		}		
		// modify by liangfuxiang 2013-5-20下午3:50:24 end;
		
		// 查询走货路径信息
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 如果查询条目不为空
		if (null != transportPathEntity) {
			// 新建走货路径详细信息对象
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 新建走货路径详细信息列表
			List<PathDetailEntity> pathDetailList;
			// 如果本状态不是卸车 则更新状态 否则不更新
			if (!StringUtils.equals(transportPathEntity.getAction(), TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE)) {
				
				// modify by liangfuxiang 2013-5-20下午4:15:10 begin
				if(StringUtils.isEmpty(action)){
					logger.error("CalculateTransportPathService[inStorage()]:"+TransportPathConstants.PATH_DETAIL_ACTION_NULL);
					throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_ACTION_NULL_GLOB);
				}
				// modify by liangfuxiang 2013-5-20下午4:15:14 end;
				
				// 更新本状态为上一状态
				transportPathEntity.setBeforeAction(transportPathEntity.getAction());
				// 设置状态
				transportPathEntity.setAction(action);
				// 更新走货路径
				transportationPathDao.updateTransportPath(transportPathEntity);
			}
			// 如果不是分批配载,则不需要货件号
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置目的地编码
				pathDetailEntity.setObjectiveOrgCode(orgCode);
				// 查询走货路径详细信息列表
				// modify by liangfuxiang 2013-7-18上午10:16:29 begin PDA-1320 ：A-B(notleave) B-C C-B(notleave) B-F 这样的情形，
				// 走货路径就会返回多条，故现在作状态无关的，目标部门为arriveOrgCode的走货路径查询，获取最大路段好的即可。
				// 并将比此路段号小的路段的状态全部置为RELEAVE
				// 查询走货路径详细信息列表
				//pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				//获取相同目标部门的最大路段信息
				pathDetailList = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
				// 若是分批配载
			}
			else {
				
				// modify by liangfuxiang 2013-5-20下午3:55:19 begin
				if (StringUtils.isEmpty(goodsNo)) {
					logger.error("CalculateTransportPathService[inStorage()]:" + TransportPathConstants.SERIALNO_IS_NULL);
					throw new TfrBusinessException(TransportPathConstants.SERIALNO_IS_NULL);
				}
				// modify by liangfuxiang 2013-5-20下午3:55:30 end;
				
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置流水号
				pathDetailEntity.setGoodsNo(goodsNo);
				// 设置目的地编码
				pathDetailEntity.setObjectiveOrgCode(orgCode);
				// modify by liangfuxiang 2013-7-18上午10:16:29 begin PDA-1320 ：A-B(notleave) B-C C-B(notleave) B-F 这样的情形，
				// 走货路径就会返回多条，故现在作状态无关的，目标部门为arriveOrgCode的走货路径查询，获取最大路段好的即可。
				// 并将比此路段号小的路段的状态全部置为RELEAVE
				// 查询走货路径详细信息列表
				//pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				//获取相同目标部门的最大路段信息
				pathDetailList = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
			}
			// 如果查询条目唯一
			if (pathDetailList.size() == 1) {
				
				//将比此路段号小的路段状态全部置为RELEAVE
				releaveBeforePathDetails(pathDetailList.get(0));
				//将比此路段大的路段状态全部置为NOTLEAVE
				updateBehindPathDetailForNotLeave(pathDetailList.get(0));
				
				// modify by liangfuxiang 2013-7-18上午10:16:29 end PDA-1320 
				
				// 更新状态
				pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
				// 更新明细数据
				pathDetailDao.updateListPathDetail(pathDetailList);
				// 设置本部门
				transportPathEntity.setCurrentOrgCode(orgCode);
				// 设置下一部门
				transportPathEntity.setNextOrgCode(pathDetailList.get(0).getNextDestOrgCode());
				// 更新主表
				transportationPathDao.updateTransportPath(transportPathEntity);
			}
			// modify by liangfuxiang 2013-5-20下午3:56:36 begin
			/*
			 * else { // 得到的明细对应数据大于一条或者没有得到数据. // 数据有错误 throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILDATAERROR, ""); }
			 */
			// 查询到多条数据
			else if (pathDetailList.size() > 1) {
				
				// modify by liangfuxiang 2013-6-14下午7:19:09 begin 当有多条时，将要入库之前的无效的走货路径状态置为RELEAVE,保证目前可以入库。
				// String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
				// logger.error("CalculateTransportPathService[inStorage()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
				// throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB,new Object[]{waybillNo,orgCode});
				dealWithNonUniquenessPathDetailList(pathDetailList,transportPathEntity,orgCode);
				// modify by liangfuxiang 2013-6-14下午7:19:23 end;
			}
			// 未查询到走货路径
			else {
				
				// modify by liangfuxiang 2013-6-8下午5:17:59 begin 解决无法入库，提示找不到目标部门的问题。。
				// 。就是pathDetailNotReleave方法，将上一部门的状态releave时，无法查询到走货路径
				// String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
				// logger.error("CalculateTransportPathService[inStorage()]:" + exps[0] + waybillNo + exps[1] + orgCode + exps[2]);
				// throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_DES_GLOB,new Object[]{waybillNo,orgCode});
				 changeTransportPathWithReleave(transportPathEntity, goodsNo, orgCode);
				// modify by liangfuxiang 2013-6-8下午5:19:13 end;
			}
			// modify by liangfuxiang 2013-5-20下午3:56:41 end;
		}
		else {
			// modify by liangfuxiang 2013-5-24上午10:20:38 begin 增加日志，修改异常信息
			// 异常：
			// 未查找到走货路径信息
			//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[inStorage()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA , new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午10:32:22 end;
		}
	}

	/**
	 * @param orgCode  
	* @Title: dealWithNonUniquenessPathDetailList 
	* @Description: 当有多条时，将要入库之前的无效的走货路径状态置为RELEAVE,保证目前可以入库。
	* @param pathDetailList
	* @param transportPathEntity  设定文件 
	* @return void    返回类型 
	* @see dealWithNonUniquenessPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-14 下午7:28:18   
	* @throws 
	*/ 
	private void dealWithNonUniquenessPathDetailList(List<PathDetailEntity> pathDetailList, TransportPathEntity transportPathEntity, String orgCode) {

		// 走货路径明细信息排序,以路段号排序
		pathDetailList = sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);

		// 调整完以后的走货路径明细信息列表
		List<PathDetailEntity> newPathDetailEntityList = new ArrayList<PathDetailEntity>();

		// 获取最大路段的信息
		PathDetailEntity maxRouteNoPathDetailEntity = new ArrayList<PathDetailEntity>(pathDetailList.subList(pathDetailList.size() - 1, pathDetailList.size())).get(0);
		// 入库
		maxRouteNoPathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
		newPathDetailEntityList.add(maxRouteNoPathDetailEntity);

		// 获取应当置为已离开的走货路径明细信息
		List<PathDetailEntity> releavePathDetailList = new ArrayList<PathDetailEntity>(pathDetailList.subList(0, pathDetailList.size() - 1));
		PathDetailEntity releavePathDetailEntity = null;
		for (int i = 0; i < releavePathDetailList.size(); i++) {
			releavePathDetailEntity = releavePathDetailList.get(i);
			// 已离开
			releavePathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			newPathDetailEntityList.add(releavePathDetailEntity);
		}

		// modify by liangfuxiang 2013-6-27上午10:13:02 begin ---将比最大路段大的后面的走货路径，统一置为NOTLEAVE 
		//处理原因:1.入库，可在任意的地方，导致后面可能已经走过了，如：F-A A-B B-C C-A A-D D-E ...此时货已经走过D了。。
		//此时在B处做清仓,少货等入库,这时候，此件货的后续路径需要变更为NOTLEAVE
		//2.出现1所描述的现象，往往是因为状态不准确导致。
		updateBehindPathDetailForNotLeave(maxRouteNoPathDetailEntity);
		// modify by liangfuxiang 2013-6-27上午10:13:06 end;
		
		// 更新走货路径明细信息
		pathDetailDao.updateListPathDetail(newPathDetailEntityList);

		// 更新走货路径主表信息
		// 设置本部门
		transportPathEntity.setCurrentOrgCode(orgCode);
		// 设置下一部门
		transportPathEntity.setNextOrgCode(maxRouteNoPathDetailEntity.getNextDestOrgCode());
		// 更新主表
		transportationPathDao.updateTransportPath(transportPathEntity);
	}

	/** 
	* @Title: dealLeftPathDetailNotLeave 
	* @Description: 将此走货路径路段后面的走货路径，置为NOTLEAVE
	* @param maxRouteNoPathDetailEntity  设定文件 
	* @return void    返回类型 
	* @see dealLeftPathDetailNotLeave
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-27 上午10:21:11   
	* @throws 
	*/ 
	private void updateBehindPathDetailForNotLeave(PathDetailEntity maxRouteNoPathDetailEntity) {

		PathDetailEntity notLeavePathDetailEntity = new PathDetailEntity();
		notLeavePathDetailEntity.setWaybillNo(maxRouteNoPathDetailEntity.getWaybillNo());
		notLeavePathDetailEntity.setRouteNo(maxRouteNoPathDetailEntity.getRouteNo());
		notLeavePathDetailEntity.setGoodsNo(maxRouteNoPathDetailEntity.getGoodsNo());
		// 将此路段之后的走货路径，全部置为NOTLEAVE
		notLeavePathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		pathDetailDao.updateBehindPathDetailForNotLeave(notLeavePathDetailEntity);
	}

	/**
	 * @deprecated
	 * @Title: sortPathDetailListByRouteNo
	 * @Description: 走货路径明细信息排序,以路段号排序
	 * @param pathDetailList
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see sortPathDetailListByRouteNo
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-14 下午8:56:58
	 * @throws
	 */
	
	private List<PathDetailEntity> sortPathDetailListByRouteNo(List<PathDetailEntity> pathDetailList) {
		// 走货路径明细信息排序,以路段号排序
		Collections.sort(pathDetailList, new Comparator<PathDetailEntity>() {
			public int compare(PathDetailEntity o1, PathDetailEntity o2) {
				return routeNoCompare(o1, o2);
			}

			private int routeNoCompare(PathDetailEntity o1, PathDetailEntity o2) {
				// 流水号相等，比较路段号
				int routNo1 = getIntRoutNo(o1.getRouteNo(), o1.getWaybillNo());
				int routNo2 = getIntRoutNo(o2.getRouteNo(), o2.getWaybillNo());
				if (routNo1 <= routNo2) {
					return -1;
				}
				else {
					return 1;
				}
			}
		});

		return pathDetailList;
	}

	/** 
	* @Title: changeTransportPathWithReleave 
	* @Description: 处理releave状态的走货路径
	* @param transportPathEntity
	* @param goodsNo
	* @param orgCode  设定文件 
	* @return void    返回类型 
	* @see changeTransportPathWithReleave
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-8 下午5:29:57   
	* @throws 
	*/ 
	private void changeTransportPathWithReleave(TransportPathEntity transportPathEntity, String goodsNo, String orgCode) {
		
		// 获取唯一的已离开的路段--作为要入库的路段
		PathDetailEntity pathDetailEntity = getReleavePathDetail(transportPathEntity, goodsNo, orgCode);
		// 查询走货路径详细信息
		List<PathDetailEntity> pathDetailEntityList = queryPathDetailEntityList(transportPathEntity);
		// 与当前流水号相同的，重新生成走货路径,并删除掉原走货路径详细信息,同时，更新主表信息
		createNewPathInfo(pathDetailEntity, pathDetailEntityList, goodsNo,transportPathEntity);
	}

	/** 
	* @Title: createNewPathInfo 
	* @Description: 与当前流水号相同的，重新生成走货路径,并删除掉原走货路径详细信息,同时，更新主表信息
	* @param pathDetailEntity
	* @param pathDetailEntityList  设定文件 
	* @return void    返回类型 
	* @see createNewPathInfo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午5:24:33   
	* @throws 
	*/ 
	@SuppressWarnings("unchecked")
	private void createNewPathInfo(PathDetailEntity pathDetailEntity, List<PathDetailEntity> pathDetailEntityList,String goodsNo,TransportPathEntity transportPathEntity) {

		//运单号
		String waybillNo=pathDetailEntity.getWaybillNo();
		
		PathDetailEntity oldPathDetailEntity=null;
		//要删除的走货路径
		List<PathDetailEntity> oldPathDetailEntityList=new ArrayList<PathDetailEntity>();
		
		List<PathDetailEntity> leftdPathDetailEntityList=new ArrayList<PathDetailEntity>();
		//获取当前的路段号
		int currentRouteNo=getIntRoutNo(pathDetailEntity.getRouteNo(),waybillNo);
		
		int oldRouteNo;
		for(int i=0;i<pathDetailEntityList.size();i++){
			oldPathDetailEntity=pathDetailEntityList.get(i);
			//找到了要重新生成走货路径段
			if(findSamePathEntity(pathDetailEntity,oldPathDetailEntity,goodsNo)){
				//则将与此路径段相同流水号但更大路段的数据全部查出
				oldRouteNo=getIntRoutNo(oldPathDetailEntity.getRouteNo(),waybillNo);
				//将大路段的保存
				if(currentRouteNo<=oldRouteNo){
					oldPathDetailEntityList.add(oldPathDetailEntity);
				}
				else{
					//路段号小于当前路段号的走货路径保留下来
					leftdPathDetailEntityList.add(oldPathDetailEntity);
				}
			}
		}

		//原走货路径没有现在要重新生成的对应流水号的路径
		if(!CollectionUtils.isEmpty(oldPathDetailEntityList)){
			pathDetailDao.deleteListPathDetail(oldPathDetailEntityList);
		}

		// 设置流水号
		if (StringUtils.isEmpty(pathDetailEntity.getGoodsNo())) {
			pathDetailEntity.setGoodsNo(goodsNo);
		}
		
		// modify by liangfuxiang 2013-6-14下午11:18:21 begin
		//将上一段要用的路径pathDetailEntity删除
		PathDetailEntity deletePathDetailEntity=new PathDetailEntity();
		BeanUtils.copyProperties(pathDetailEntity, deletePathDetailEntity);
		List<PathDetailEntity> deletePathDetailEntityList=new ArrayList<PathDetailEntity>();
		pathDetailDao.deleteListPathDetail(deletePathDetailEntityList);
		// modify by liangfuxiang 2013-6-14下午11:18:27 end;
		
		Map<String, Object> pathDetailMap = getNewPathDetailEntityList(pathDetailEntity.getObjectiveOrgCode(), transportPathEntity, pathDetailEntity, goodsNo);
		// 生成新的走货路径明细
		List<PathDetailEntity> newPathDetailEntityList = (List<PathDetailEntity>) pathDetailMap.get("pathDetailList");
		//合并走货路径明细信息
		List<PathDetailEntity> wholePathDetailEntityList=combineLeftAndNewPathDetailList(leftdPathDetailEntityList,newPathDetailEntityList);
		
		//更新主表信息
		transportPathEntity=updateTransportPathEntityInfo(wholePathDetailEntityList,transportPathEntity,(PathDetailEntity)pathDetailMap.get("first"));
		
		//保存主表信息
		transportationPathDao.updateTransportPath(transportPathEntity);
		
		//保存新生成的走货路径
		pathDetailDao.addListPathDetail(newPathDetailEntityList);
	}

	/** 
	* @Title: combineLeftAndNewPathDetailList 
	* @Description: 合并走货路径信息，并按照路段排序
	* @param leftdPathDetailEntityList
	* @param newPathDetailEntityList
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see combineLeftAndNewPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午10:42:36   
	* @throws 
	*/ 
	private List<PathDetailEntity> combineLeftAndNewPathDetailList(List<PathDetailEntity> leftdPathDetailEntityList, List<PathDetailEntity> newPathDetailEntityList) {

		if (!CollectionUtils.isEmpty(leftdPathDetailEntityList)) {
			
			// modify by liangfuxiang 2013-7-18下午8:32:38 begin BUG-45235 货区问题
			// 处理老路径的最后一段与新路径的第一段之间的拼接关系
			leftdPathDetailEntityList = dealOldLastAndNewFirstPathDetailEntity(newPathDetailEntityList, leftdPathDetailEntityList);
			// modify by liangfuxiang 2013-7-18下午8:32:38 end BUG-45235 货区问题
			
			// 合并
			for (PathDetailEntity pathDetailEntity : leftdPathDetailEntityList) {
				newPathDetailEntityList.add(pathDetailEntity);
			}
		}

		// 按照路段号排序
		Collections.sort(newPathDetailEntityList, new Comparator<PathDetailEntity>() {
			public int compare(PathDetailEntity o1, PathDetailEntity o2) {
				return routeNoCompare(o1, o2);
			}

			private int routeNoCompare(PathDetailEntity o1, PathDetailEntity o2) {
				// 流水号相等，比较路段号
				int routNo1 = getIntRoutNo(o1.getRouteNo(), o1.getWaybillNo());
				int routNo2 = getIntRoutNo(o2.getRouteNo(), o2.getWaybillNo());
				if (routNo1 <= routNo2) {
					return -1;
				}
				else {
					return 1;
				}
			}
		});

		return newPathDetailEntityList;
	}

	/**
	 * @param pathDetailEntity  
	* @Title: updateTransportPathEntityInfo 
	* @Description: 更新主表信息
	* @param newPathDetailEntityList
	* @param transportPathEntity
	* @return  设定文件 
	* @return TransportPathEntity    返回类型 
	* @see updateTransportPathEntityInfo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午9:46:29   
	* @throws 
	*/ 
	private TransportPathEntity updateTransportPathEntityInfo(List<PathDetailEntity> wholePathDetailEntityList, TransportPathEntity transportPathEntity, PathDetailEntity pathDetailEntity) {
		//走货路径标示为分批配载
		transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
		transportPathEntity.setCurrentOrgCodeName(getNameByCode(transportPathEntity.getCurrentOrgCode()));
		transportPathEntity.setBeforeAction(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
		transportPathEntity.setAction(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
		transportPathEntity.setNextOrgCode(pathDetailEntity.getOrigOrgCode());
		transportPathEntity.setNextOrgCodeName(getNameByCode(pathDetailEntity.getOrigOrgCode()));
		transportPathEntity.setModifyDate(new Date());
		
		//job时，找不到用户的异常。
		try {
			transportPathEntity.setModifyUser(FossUserContext.getCurrentInfo().getEmpCode());
		}
		catch (Exception e) {
			//352203-sonar
			logger.info("CalculateTransportPathService.updateTransportPathEntityInfo 报错:" + StringUtils.substring(e.toString(), 0, ConstantsNumberSonar.SONAR_NUMBER_100));
		}
		transportPathEntity.setPlanArriveTime(pathDetailEntity.getPlanArriveTime());
		transportPathEntity.setPlanStartTime(pathDetailEntity.getPlanStartTime());
		//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
		//设置走货路径
		//transportPathEntity.setTransportPath(splicePathString(wholePathDetailEntityList,transportPathEntity));
		return transportPathEntity;
	}

	/** 
	* @Title: splicePathString 
	* @Description: 拼接走货路径
	* @param wholePathDetailEntityList
	* @param transportPathEntity
	* @return  设定文件 
	* @return String    返回类型 
	* @see splicePathString
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午11:51:19   
	* @throws 
	*/ 
	private String splicePathString(List<PathDetailEntity> wholePathDetailEntityList, TransportPathEntity transportPathEntity) {

		StringBuffer path = new StringBuffer();
		int size = wholePathDetailEntityList.size();
		for (int i = 0; i < size; i++) {
			if (i == 0) {
				path.append(getNameByCode(wholePathDetailEntityList.get(i).getOrigOrgCode())).append(TransportPathConstants.HORIZONTAL_LINE)
						.append(getNameByCode(wholePathDetailEntityList.get(i).getObjectiveOrgCode())).append(TransportPathConstants.HORIZONTAL_LINE);
			}
			else {
				// 设置走货路径
				path.append(getNameByCode(wholePathDetailEntityList.get(i).getObjectiveOrgCode()));
				if (i != (size - 1)) {
					// 拼接走货路径
					path.append(TransportPathConstants.HORIZONTAL_LINE);
				}
			}
		}

		return spliceTransportPath(StringUtils.trim(transportPathEntity.getTransportPath()),path);
	}

	/**
	 * 
	 * @Title: getNewPathDetailEntityList
	 * @Description: 生成新的走货路径
	 * @param currentOrgCode
	 * @param transportPathEntity
	 * @param goodsNo
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see getNewPathDetailEntityList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-9 下午7:51:57
	 * @throws
	 */
	private Map<String,Object> getNewPathDetailEntityList(String currentOrgCode, TransportPathEntity transportPathEntity, PathDetailEntity pathDetailEntity, String goodsNo) {
		// 设置当前部门
		transportPathEntity.setCurrentOrgCode(currentOrgCode);
		// 从基础数据获取走货路径
		List<FreightRouteLineDto> freightRouteLineDtoList = getFrightRouteLineDtoList(transportPathEntity);
		// 拼接获取新的走货路径
		Map<String,Object> pathDetailMap = getPathDetailEntityList(freightRouteLineDtoList, transportPathEntity,pathDetailEntity, goodsNo);

		return pathDetailMap;
	}

	/** 
	* @Title: getPathDetailEntityList 
	* @Description: 拼接生成走货路径明细信息
	* @param freightRouteLineDtoList
	* @param transportPathEntity
	* @param goodsNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see getPathDetailEntityList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午7:54:49   
	* @throws 
	*/ 
	private Map<String,Object> getPathDetailEntityList(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity, PathDetailEntity beforePathDetailEntity,
			String goodsNo) {
		
		
		Map<String,Object> pathDetailMap=new HashMap<String,Object>();
		
		//上一路段路段号
		int beforeRouteNo=getIntRoutNo(beforePathDetailEntity.getRouteNo(), transportPathEntity.getWaybillNo());
		
		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();

		PathDetailEntity pathDetailEntity = null;
		// 走货路径线路
		FreightRouteLineDto freightRouteLineDto = null;
		// 遍历路段信息
		for (int i = 0; i < freightRouteLineDtoList.size(); i++) {
			freightRouteLineDto = freightRouteLineDtoList.get(i);
			pathDetailEntity = new PathDetailEntity();
			// 出发部门
			String sourceCode = getSourceCode(transportPathEntity, freightRouteLineDto);
			pathDetailEntity.setOrigOrgCode(sourceCode);
			pathDetailEntity.setOrigOrgName(getNameByCode(sourceCode));
			// 到达部门
			String targetCode = getTargetCode(transportPathEntity, freightRouteLineDto);
			pathDetailEntity.setObjectiveOrgCode(targetCode);
			pathDetailEntity.setObjectiveOrgName(getNameByCode(targetCode));
			// 计划出发时间
			setLeaveDate(freightRouteLineDtoList, transportPathEntity, freightRouteLineDto, i);
			pathDetailEntity.setPlanStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置计划到达时间
			setArriveDate(freightRouteLineDtoList, transportPathEntity, i);
			pathDetailEntity.setPlanArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// id
			pathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
			// 运单号
			pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
			// 设置上一段车牌号为空
			if(i==0){
				//上一段的车牌号
				pathDetailEntity.setBeforeVehicleNo(beforePathDetailEntity.getVehicleNo());
			}
			else{
				//为空
				pathDetailEntity.setBeforeVehicleNo(TransportPathConstants.BLANK_STRING_CONSTANT);
			}
			// 设置流水号
			pathDetailEntity.setGoodsNo(goodsNo);
			// 设置开单部门
			pathDetailEntity.setBillingOrgCode(transportPathEntity.getBillingOrgCode());
			// 设置线路段号
			pathDetailEntity.setRouteNo(String.valueOf(beforeRouteNo + i + 1));
			// 如果还有下一段,设置下一到达部门&时间
			if ((i + 1) < freightRouteLineDtoList.size()) {
				// 设置下一到达部门
				pathDetailEntity.setNextDestOrgCode(freightRouteLineDtoList.get(i + 1).getTargetCode());
				// 设置下一到达部门时间
				pathDetailEntity.setNextArriveTime(freightRouteLineDtoList.get(i + 1).getArriveDate());
			}
			pathDetailEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
			// 设置调整出发时间
			pathDetailEntity.setModifyStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置调整到达时间
			pathDetailEntity.setModifyArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			
			pathDetailList.add(pathDetailEntity);
			
			//设置上一路段相关信息
			if(i==0){
				beforePathDetailEntity.setNextDestOrgCode(pathDetailEntity.getObjectiveOrgCode());
				beforePathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
				pathDetailList.add(beforePathDetailEntity);
				
				pathDetailMap.put("first", pathDetailEntity);
			}
		}

		pathDetailMap.put("pathDetailList", pathDetailList);
		
		return pathDetailMap;
	}
	
	/**
	 * 
	 * @Title: setArriveDate
	 * @Description: 设置计划到达时间
	 * @param freightRouteLineDtoList
	 * @param transportPathEntity
	 * @param i 设定文件
	 * @return void 返回类型
	 * @see setArriveDate
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-9 下午9:09:24
	 * @throws
	 */
	private void setArriveDate(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity, int i) {
		// 设置计划到达时间,如果为空，
		if (null == freightRouteLineDtoList.get(i).getArriveDate()) {
			// 且非汽运偏线\精准空运\整车
			if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
					|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
					|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
							.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
				logger.error("CalculateTransportPathService[getTargetCode()]:" + TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_ARRIVEDATE_NULL + TransportPathConstants.ORIGORGNAME
						+ transportPathEntity.getCurrentOrgCode() + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + transportPathEntity.getDestOrgCode()
						+ TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME + transportPathEntity.getTransportModel());
				throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_ARRIVEDATE_NULL_GLOB, new Object[] { transportPathEntity.getCurrentOrgCode(),
						transportPathEntity.getDestOrgCode(), transportPathEntity.getTransportModel() });
			}
			else {
				// 设置new date为到达时间
				long beforeArrive = (new Date()).getTime();
				// 如果有到达时间
				if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
					// 设置为到达时间
					beforeArrive = freightRouteLineDtoList.get(i - 1).getArriveDate().getTime();
				}
				// 计算相差天数
				long min = freightRouteLineDtoList.get(i).getAging();
				// 计算最后到达的日期和时间
				Date arrive = new Date(sixtyThousand * min + beforeArrive);
				// 设置该段路的到达时间
				freightRouteLineDtoList.get(i).setArriveDate(arrive);
			}
		}
	}

	/**
	 * 
	 * @Title: getLeaveDate
	 * @Description: 设置计划出发时间
	 * @param freightRouteLineDtoList
	 * @param transportPathEntity
	 * @param freightRouteLineDto
	 * @param i 设定文件
	 * @return void 返回类型
	 * @see getLeaveDate
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-9 下午9:04:39
	 * @throws
	 */
	private void setLeaveDate(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity, FreightRouteLineDto freightRouteLineDto, int i) {
		// 设置出发时间
		if (null == freightRouteLineDto.getLeaveDate()) {
			// 且非汽运偏线\精准空运\整车
			if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
					|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
					|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
							.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
				logger.error("CalculateTransportPathService[getTargetCode()]:" + TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_LEAVEDATE_NULL + TransportPathConstants.ORIGORGNAME
						+ transportPathEntity.getCurrentOrgCode() + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + transportPathEntity.getDestOrgCode()
						+ TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME + transportPathEntity.getTransportModel());
				throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_LEAVEDATE_NULL_GLOB, new Object[] { transportPathEntity.getCurrentOrgCode(),
						transportPathEntity.getDestOrgCode(), transportPathEntity.getTransportModel() });
			}
			else {
				// 如果有出发时间
				if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
					// 则设置出发时间
					freightRouteLineDtoList.get(i).setLeaveDate(freightRouteLineDtoList.get(i - 1).getArriveDate());
				}
				else {
					// 否则new date赋值
					freightRouteLineDtoList.get(i).setLeaveDate(new Date());
				}
			}
		}
	}

	/**
	 * 
	 * @Title: getTargetCode
	 * @Description: 获取目标部门
	 * @param transportPathEntity
	 * @param freightRouteLineDto
	 * @return 设定文件
	 * @return String 返回类型
	 * @see getTargetCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-9 下午8:59:19
	 * @throws
	 */
	private String getTargetCode(TransportPathEntity transportPathEntity, FreightRouteLineDto freightRouteLineDto) {
		// 目标部门
		String targetCode = StringUtils.trim(freightRouteLineDto.getTargetCode());
		// 为空，则异常
		if (StringUtils.isEmpty(targetCode)) {
			logger.error("CalculateTransportPathService[getTargetCode()]:" + TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_TARGETCODE_NULL + TransportPathConstants.ORIGORGNAME
					+ transportPathEntity.getCurrentOrgCode() + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + transportPathEntity.getDestOrgCode() + TransportPathConstants.COMMA
					+ TransportPathConstants.TRANSPORTMODELNAME + transportPathEntity.getTransportModel());
			throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_TARGETCODE_NULL_GLOB, new Object[] { transportPathEntity.getCurrentOrgCode(),
					transportPathEntity.getDestOrgCode(), transportPathEntity.getTransportModel() });
		}
		return targetCode;
	}

	/**
	 * 
	* @Title: getSourceCode 
	* @Description: 获取出发部门
	* @param transportPathEntity
	* @param freightRouteLineDto
	* @return  设定文件 
	* @return String    返回类型 
	* @see getSourceCode
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午8:54:33   
	* @throws
	 */
	private String getSourceCode(TransportPathEntity transportPathEntity, FreightRouteLineDto freightRouteLineDto) {
		// 出发部门
		String sourceCode = StringUtils.trim(freightRouteLineDto.getSourceCode());
		// 出发部门为空
		if (StringUtils.isEmpty(sourceCode)) {
			logger.error("CalculateTransportPathService[getSourceCode()]:" + TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_SOURCECODE_NULL + TransportPathConstants.ORIGORGNAME
					+ transportPathEntity.getCurrentOrgCode() + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + transportPathEntity.getDestOrgCode() + TransportPathConstants.COMMA
					+ TransportPathConstants.TRANSPORTMODELNAME + transportPathEntity.getTransportModel());
			throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTEBYSOURCETARGET_SOURCECODE_NULL_GLOB, new Object[] { transportPathEntity.getCurrentOrgCode(),
					transportPathEntity.getDestOrgCode(), transportPathEntity.getTransportModel() });
		}
		return sourceCode;
	}

	/** 
	* @Title: getIntRoutNo 
	* @Description:获取路段好
	* @param routeNo
	* @return  设定文件 
	* @return int    返回类型 
	* @see getIntRoutNo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午7:09:20   
	* @throws 
	*/ 
	private int getIntRoutNo(String routeNo, String waybillNo) {

		// 判断路段非空 且为数字
		if (!StringUtils.isEmpty(StringUtils.trim(routeNo)) && routeNo.matches(TransportPathConstants.CONSTANT_REG_INTEGER)) {
			return Integer.parseInt(routeNo);
		}
		else {
			// 路段号无效，抛出异常
			logger.error("CalculateTransportPathService[getIntRoutNo()]:" + TransportPathConstants.INVALID_ROUTENO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.INVALID_ROUTENO_GLOB, new Object[] { waybillNo });
		}
	}

	/** 
	* @Title: findSamePathEntity 
	* @Description: 判断两个路段是否相同
	* @param pathDetailEntity
	* @param oldPathDetailEntity
	* @param goodsNo
	* @return  设定文件 
	* @return boolean    返回类型 
	* @see findSamePathEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午5:37:53   
	* @throws 
	*/ 
	private boolean findSamePathEntity(PathDetailEntity pathDetailEntity, PathDetailEntity oldPathDetailEntity, String goodsNo) {

		// 原未分批配载的数据，现在要给设置流水号
		if (StringUtils.isEmpty(StringUtils.trim(pathDetailEntity.getGoodsNo()))) {
			pathDetailEntity.setGoodsNo(goodsNo);
		}

		// 相同单号下的走货路径明细，根据流水号和路段号，可确认其唯一性
		if (pathDetailEntity.getGoodsNo().equalsIgnoreCase(oldPathDetailEntity.getGoodsNo())) {
			return true;
		}

		return false;
	}

	/** 
	* @Title: queryPathDetailEntityList 
	* @Description: 获取走货路径明细信息
	* @param transportPathEntity
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see queryPathDetailEntityList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午4:19:05   
	* @throws 
	*/ 
	private List<PathDetailEntity> queryPathDetailEntityList(TransportPathEntity transportPathEntity) {
		List<PathDetailEntity> pathDetailEntityList = null;
		// 获取运单号
		String waybillNo = transportPathEntity.getWaybillNo();
		if (!transportPathEntity.getIfPartialStowage().equals(TransportPathConstants.PARTIALSTOWAGE)) {
			//强制分批，并返回分批后的最新走货路径详细信息
			pathDetailEntityList = forceSepratePath(waybillNo);
		}
		// 已经分批
		else {
			// 返回走货路径详细信息
			pathDetailEntityList = getOriginalPathDetailList(waybillNo);
		}
		return pathDetailEntityList;
	}

	/**
	 * @Title: forceSepratePath
	 * @Description: 强制分批配载
	 * @param transportPathEntity
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see forceSepratePath
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-9 下午3:54:17
	 * @throws
	 */
	private List<PathDetailEntity> forceSepratePath(String waybillNo) {
		// 获取原走货路径明细
		List<PathDetailEntity> originalPathDetailList = getOriginalPathDetailList(waybillNo);
		// 查询全部货件号
		List<String> goodsNoList = getGoodNoList(waybillNo);
		// 加了流水后以后的新的走货路径详细信息列表
		List<PathDetailEntity> newPathDetailEntityList = new ArrayList<PathDetailEntity>();
		
		PathDetailEntity tempPathDetailEntity = null;
		// 将原走货路径加入流水号
		for (int i = 0; i < goodsNoList.size(); i++) {
			for (PathDetailEntity pathDetailEntity : originalPathDetailList) {
				tempPathDetailEntity = new PathDetailEntity();
				BeanUtils.copyProperties(pathDetailEntity, tempPathDetailEntity);
				tempPathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
				tempPathDetailEntity.setGoodsNo(goodsNoList.get(i));
				newPathDetailEntityList.add(tempPathDetailEntity);
			}
		}

		// 删除原始走货路径详细信息
		pathDetailDao.deleteListPathDetail(originalPathDetailList);
		// 保存新的走货路径相信信息
		pathDetailDao.addListPathDetail(newPathDetailEntityList);

		return newPathDetailEntityList;
	}

	/** 
	* @Title: getGoodNoList 
	* @Description: 根据运单号查询全部货件号信息
	* @param waybillNo
	* @return  设定文件 
	* @return List<String>    返回类型 
	* @see getGoodNoList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午4:17:17   
	* @throws 
	*/ 
	private List<String> getGoodNoList(String waybillNo) {
		// 查询全部货件号
		List<String> goodsNoList = pathDetailDao.listQueryGoodsNo(waybillNo);
		// 流水号为空
		if (goodsNoList.size() == 0) {
			logger.error("CalculateTransportPathService[getGoodNoList()]:" + TransportPathConstants.TRANSPORTPATH_RECREATE_CANTFINDSERIALNOBYWAYBILLNO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_RECREATE_CANTFINDSERIALNOBYWAYBILLNO, new Object[] { waybillNo });
		}
		else{
			return goodsNoList;
		}
	}

	/** 
	* @Title: getOriginalPathDetailList 
	* @Description: 获取原始的走货路径详细信息
	* @param waybillNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see getOriginalPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午4:14:12   
	* @throws 
	*/ 
	private List<PathDetailEntity> getOriginalPathDetailList(String waybillNo) {
		
		PathDetailEntity pathDetailEntity=new PathDetailEntity();
		pathDetailEntity.setWaybillNo(waybillNo);
		//查询原走货路径明细
		List<PathDetailEntity> originalPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		//未查询到走货路径
		if(CollectionUtils.isEmpty(originalPathDetailList)){
			logger.error("CalculateTransportPathService[getOriginalPathDetailList()]:"+TransportPathConstants.NO_PATH_DETAIL_FOUND+waybillNo);
			throw new TfrBusinessException(TransportPathConstants.NO_PATH_DETAIL_FOUND_GLOB,new Object[]{waybillNo});
		}
		else{
			return originalPathDetailList;
		}
		
	}

	/**
	 * 
	* @Title: getReleavePathDetail 
	* @Description: 获取唯一的已离开的路段--作为要入库的路段
	* @param transportPathEntity
	* @param goodsNo
	* @param orgCode
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see getReleavePathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-9 下午3:39:17   
	* @throws
	 */
	private PathDetailEntity getReleavePathDetail(TransportPathEntity transportPathEntity, String goodsNo, String orgCode) {
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
		pathDetailEntity.setObjectiveOrgCode(orgCode);
		// 如果是分批配载
		if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
			pathDetailEntity.setGoodsNo(goodsNo);
		}
		
		// 查询状态为releave状态的目标部门，为防止这样的路径出现
		// A-B-C-D-B-E-F-G....实际走货路径已经走到了F,在B入库。虽然现实中两个B是同一个地方，但在走货路径中，
		// 要取最大路段号的B，为第二个。
		List<PathDetailEntity> pathDetailEntityList = pathDetailDao.queryPathDetailReleave(pathDetailEntity);
		// 上一部门是否为空
		if (CollectionUtils.isEmpty(pathDetailEntityList)) {
			logger.error("CalculateTransportPathService[getReleavePathDetail()]:" + TransportPathConstants.DEPT_RELEAVE_NOT_EXSIT + transportPathEntity.getWaybillNo() + orgCode);
			throw new TfrBusinessException(TransportPathConstants.DEPT_RELEAVE_NOT_EXSIT_GLOB, new Object[] { transportPathEntity.getWaybillNo(),
					getNameByCode(orgCode) + TransportPathConstants.LEFTBRACKET + orgCode + TransportPathConstants.RIGHTBRACKET });
		}
		else if (pathDetailEntityList.size() > 1) {
			logger.error("CalculateTransportPathService[changeTransportPathWithReleave()]:" + TransportPathConstants.DEPT_RELEAVE_MULTI + transportPathEntity.getWaybillNo() + orgCode);
			throw new TfrBusinessException(TransportPathConstants.DEPT_RELEAVE_MULTI_GLOB, new Object[] { transportPathEntity.getWaybillNo(),
					getNameByCode(orgCode) + TransportPathConstants.LEFTBRACKET + orgCode + TransportPathConstants.RIGHTBRACKET });
		}
		//一条数据
		else{
			return pathDetailEntityList.get(0);
		}
	}

	/**
	 * 签收 ----将所有的路段全部置为RELEAVE状态
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:41:56
	 */
	@Transactional
	public void signIn(String waybillNo, String action) throws TfrBusinessException {
		// 查旬走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 如果查询条目不为空
		if (null != transportPathEntity) {
			// 更新本状态为上一状态
			transportPathEntity.setBeforeAction(transportPathEntity.getAction());
			// 设置状态
			transportPathEntity.setAction(action);
			// 更新走货路径信息
			transportationPathDao.updateTransportPath(transportPathEntity);
			// 新建走货路径详细信息对象
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 查询走货路径详细信息列表
			List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
			// 走货路径详细信息列表非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历走货路径详细信息列表
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 设置路径明细状态 再离开
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
				}
				// 更新走货路径详细信息列表
				pathDetailDao.updateListPathDetail(pathDetailList);
			}
		}
		else {
			// modify by liangfuxiang 2013-5-1下午3:24:23 begin:BUG-8209  签收调用修改走货路径状态，没有找到走货路径，不需要报错。
			// 异常：
			// 未查找到走货路径信息
			//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.warn("CalculateTransportPathService[signIn()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			// modify by liangfuxiang 2013-5-1下午3:24:51 end;
		}
	}

	/**
	 * 回退到上一状态 , action为现状态 by 流水号list
	 * 
	 * @author huyue
	 * @date 2013-2-20 上午10:11:21
	 */
	public void rollBackList(String waybillNo, List<String> goodsNoList, String vehicle, String action) throws TfrBusinessException {
		// 新建走货路径详细信息
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 查旬走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		
		// modify by liangfuxiang 2013-5-2上午9:17:02 begin BUG-8109 当查找不到走货路径在，不报错，需要重新生成走货路径
		// modify by liangfuxiang 2013-4-28上午10:18:18 begin BUG-8109 查询走货路径数据迁移表，查看是否已经被数据迁移。
		// if(null==transportPathEntity){
		// //查询数据迁移表
		// transportPathEntity=queryTransportPathMigration(waybillNo);
		// }
		// modify by liangfuxiang 2013-4-28上午10:19:52 end;
		// modify by liangfuxiang 2013-5-2上午9:17:02 end BUG-8109
		
		// 走货路径非空
		if (null != transportPathEntity) {
			// 判断是不是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 循环流水号进行操作
				for (int g = 0; g < goodsNoList.size(); g++) {
					// 设置流水号
					pathDetailEntity.setGoodsNo(goodsNoList.get(g));
					// 设置运载单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置目的地部门编码
					pathDetailEntity.setObjectiveOrgCode(transportPathEntity.getNextOrgCode());
					// 查询走货路径详细信息列表
					List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
					// modify by liangfuxiang 2013-5-2上午9:17:02 begin BUG-8109 当查找不到走货路径在，不报错，需要重新生成走货路径
					// modify by liangfuxiang 2013-5-1下午2:54:14 begin BUG-8109
					// 若从明细表中无法查询到走货路径信息，则从数据迁移表中查询
					// if (pathDetailList.size() == 0) {
					// // 从数据迁移表中查询
					// pathDetailList = pathDetailDao.pathDetailNotReleaveFromMigration(pathDetailEntity);
					// }
					// modify by liangfuxiang 2013-5-1下午2:54:27 end;
					// modify by liangfuxiang 2013-5-2上午9:17:02 end BUG-8109
					
					// 走货路径详细信息列表为空
					if (pathDetailList.size() == 0) {
						// 上一状态必须有值,表示不是连续回退.
						// 本改动所传递状态必须和实际状态一致.否则不能修改,因为分批配载,所以只影响到子表
						if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())) {
							// 更新上一状态为本状态
							transportPathEntity.setAction(transportPathEntity.getBeforeAction());
							// 设置上一状态为空
							transportPathEntity.setBeforeAction("");
							// 更新走货路径信息
							transportationPathDao.updateTransportPath(transportPathEntity);
						}
						// 走货路径详细信息唯一
					}
					else if (pathDetailList.size() == 1) {
						// 判断是不是出发
						if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_LEAVE, pathDetailList.get(0).getArriveOrLeave())) {
							// 如果是出发
							// 状态变成已交接,实际出发时间变为空
							pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
							// 实际出发时间为空
							pathDetailList.get(0).setActualStartTime(null);
							// 更新明细信息
							pathDetailDao.updateListPathDetail(pathDetailList);
							// 上一状态必须有值,表示不是连续回退.
							// 本改动所传递状态必须和实际状态一致.否则不能修改,如果主表状态不是出发,则不修改状态
							if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_DEPART, transportPathEntity.getAction())) {
								// 更新上一状态为本状态
								transportPathEntity.setAction(transportPathEntity.getBeforeAction());
								// 设置上一状态为空
								transportPathEntity.setBeforeAction("");
								// 设置当前部门编码
								transportPathEntity.setCurrentOrgCode(pathDetailList.get(0).getOrigOrgCode());
								// 设置车牌号为空
								transportPathEntity.setVehicleNo("");
								// 更新走货路径信息
								transportationPathDao.updateTransportPath(transportPathEntity);
							}

						}// 判断是不是到达
						else if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE, pathDetailList.get(0).getArriveOrLeave())) {
							// 状态变成离开,实际到达时间为空
							pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
							// 实际出发时间为空
							pathDetailList.get(0).setActualArriveTime(null);
							// 更新明细信息
							pathDetailDao.updateListPathDetail(pathDetailList);
							// 上一状态必须有值,表示不是连续回退.
							// 本改动所传递状态必须和实际状态一致.
							// 否则不能修改,如果主表状态不是出发,则不修改状态
							if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_ARRIVE, transportPathEntity.getAction())) {
								// 更新上一状态为本状态
								transportPathEntity.setAction(transportPathEntity.getBeforeAction());
								// 设置上一状态为空
								transportPathEntity.setBeforeAction("");
								// 设置当前部门编码
								transportPathEntity.setCurrentOrgCode("");
								// 设置车牌号为空
								transportPathEntity.setVehicleNo(vehicle);
								// 获取前一条路径明细的出发时间
								transportPathEntity.setPlanStartTime(pathDetailList.get(0).getModifyStartTime());
								// 获取前一条路径明细到达时间
								transportPathEntity.setPlanArriveTime(pathDetailList.get(0).getModifyArriveTime());
								// 更新走货路径信息
								transportationPathDao.updateTransportPath(transportPathEntity);
							}

						}// 判断是不是交接
						else if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER, pathDetailList.get(0).getArriveOrLeave())) {
							// 状态变成未离开,实际出发时间变为空
							pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
							// 更新明细信息
							pathDetailDao.updateListPathDetail(pathDetailList);
							// 上一状态必须有值,表示不是连续回退.
							// 本改动所传递状态必须和实际状态一致.否则不能修改,如果主表状态不是交接,则不修改状态
							if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())
									&& StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_HANDOVER, transportPathEntity.getAction())) {
								// 更新上一状态为本状态
								transportPathEntity.setAction(transportPathEntity.getBeforeAction());
								// 设置上一状态为空
								transportPathEntity.setBeforeAction("");
								// 更新走货路径信息
								transportationPathDao.updateTransportPath(transportPathEntity);
							}
						}
						else {
							// 上一状态必须有值,表示不是连续回退.
							// 本改动所传递状态必须和实际状态一致.否则不能修改,因为分批配载,所以只影响到子表
							if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())) {
								// 更新上一状态为本状态
								transportPathEntity.setAction(transportPathEntity.getBeforeAction());
								// 设置上一状态为空
								transportPathEntity.setBeforeAction("");
								// 更新走货路径信息
								transportationPathDao.updateTransportPath(transportPathEntity);
							}
						}
					}
					else {
						// // modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常
						// // 得到的明细对应数据大于一条.数据有错误
						// // throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
						// String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
						// + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + pathDetailEntity.getObjectiveOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
						// + (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
						// logger.error("CalculateTransportPathService[rollBackList()]:" + exps);
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
						// pathDetailEntity.getObjectiveOrgCode(), pathDetailEntity.getGoodsNo() });
						// // modify by liangfuxiang 2013-5-23下午10:30:11 end;
					}
				}
			}
			else {
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置目的地编码
				pathDetailEntity.setObjectiveOrgCode(transportPathEntity.getNextOrgCode());
				// //查询走货路径详细信息列表
				List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				
				// modify by liangfuxiang 2013-5-2上午9:17:02 begin BUG-8109 当查找不到走货路径在，不报错，需要重新生成走货路径
				// modify by liangfuxiang 2013-5-1下午2:54:14 begin BUG-8109
				// 若从明细表中无法查询到走货路径信息，则从数据迁移表中查询
				// if (pathDetailList.size() == 0) {
				// // 从数据迁移表中查询
				// pathDetailList = pathDetailDao.pathDetailNotReleaveFromMigration(pathDetailEntity);
				// }
				// modify by liangfuxiang 2013-5-1下午2:54:27 end;
				// modify by liangfuxiang 2013-5-2上午9:17:02 begin BUG-8109 当查找不到走货路径在，不报错，需要重新生成走货路径
				// 走货路径详细信息列表为空
				if (pathDetailList.size() == 0) {
					// 上一状态必须有值,表示不是连续回退.
					// 本改动所传递状态必须和实际状态一致.
					// 否则不能修改,因为分批配载,所以只影响到子表
					if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())) {
						// 更新上一状态为本状态
						transportPathEntity.setAction(transportPathEntity.getBeforeAction());
						// 设置上一状态为空
						transportPathEntity.setBeforeAction("");
						// 更新走货路径信息
						transportationPathDao.updateTransportPath(transportPathEntity);
					}
					// 走货路径详细信息唯一
				}
				else if (pathDetailList.size() == 1) {
					// 判断是不是出发
					if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_LEAVE, pathDetailList.get(0).getArriveOrLeave())) {
						// 如果是出发
						// 状态变成已交接,实际出发时间变为空
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
						// 实际出发时间变为空
						pathDetailList.get(0).setActualStartTime(null);
						// 更新明细信息
						pathDetailDao.updateListPathDetail(pathDetailList);
						// 上一状态必须有值,表示不是连续回退.
						// 本改动所传递状态必须和实际状态一致.
						// 否则不能修改,如果主表状态不是出发,则不修改状态
						if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_DEPART, transportPathEntity.getAction())) {
							// 更新上一状态为本状态
							transportPathEntity.setAction(transportPathEntity.getBeforeAction());
							// //设置上一状态为空
							transportPathEntity.setBeforeAction("");
							// 设置当前部门
							transportPathEntity.setCurrentOrgCode(pathDetailList.get(0).getOrigOrgCode());
							// 设置车牌号为空
							transportPathEntity.setVehicleNo("");
							// 更新走货路径
							transportationPathDao.updateTransportPath(transportPathEntity);
						}

					}// 判断是不是到达
					else if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE, pathDetailList.get(0).getArriveOrLeave())) {
						// 状态变成离开
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
						// 实际到达时间为空
						pathDetailList.get(0).setActualArriveTime(null);
						// 更新明细信息
						pathDetailDao.updateListPathDetail(pathDetailList);
						// 上一状态必须有值,表示不是连续回退.
						// 本改动所传递状态必须和实际状态一致.
						// 否则不能修改,如果主表状态不是出发,则不修改状态
						if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_ARRIVE, transportPathEntity.getAction())) {
							// 更新上一状态为本状态
							transportPathEntity.setAction(transportPathEntity.getBeforeAction());
							// 设置上一状态为空
							transportPathEntity.setBeforeAction("");
							// 设置当前部门为空
							transportPathEntity.setCurrentOrgCode("");
							// 设置车牌号
							transportPathEntity.setVehicleNo(vehicle);
							// 获取前一条路径明细的出发和到达时间
							transportPathEntity.setPlanStartTime(pathDetailList.get(0).getModifyStartTime());
							// 设置修改到达时间
							transportPathEntity.setPlanArriveTime(pathDetailList.get(0).getModifyArriveTime());
							// 更新走货路径
							transportationPathDao.updateTransportPath(transportPathEntity);
						}
					}// 判断是不是交接
					else if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER, pathDetailList.get(0).getArriveOrLeave())) {
						// 状态变成未离开,实际出发时间变为空
						pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
						// 更新明细信息
						pathDetailDao.updateListPathDetail(pathDetailList);
						// 上一状态必须有值,表示不是连续回退.
						// 本改动所传递状态必须和实际状态一致.
						// 否则不能修改,如果主表状态不是交接,则不修改状态
						if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_HANDOVER, transportPathEntity.getAction())) {
							// 更新上一状态为本状态
							transportPathEntity.setAction(transportPathEntity.getBeforeAction());
							// 设置上一状态为空
							transportPathEntity.setBeforeAction("");
							// 更新走货路径
							transportationPathDao.updateTransportPath(transportPathEntity);
						}
					}
					else {
						// 上一状态必须有值,表示不是连续回退.
						// 本改动所传递状态必须和实际状态一致.否则不能修改,因为分批配载,所以只影响到子表
						if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())) {
							// 更新上一状态为本状态
							transportPathEntity.setAction(transportPathEntity.getBeforeAction());
							// 设置上一状态为空
							transportPathEntity.setBeforeAction("");
							// 更新走货路径
							transportationPathDao.updateTransportPath(transportPathEntity);
						}
					}
				}
				else {
					// // modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常
					// // 得到的明细对应数据大于一条.数据有错误
					// // throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					// String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
					// + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + pathDetailEntity.getObjectiveOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
					// + (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
					// logger.error("CalculateTransportPathService[rollBackList()]:" + exps);
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
					// pathDetailEntity.getObjectiveOrgCode(), pathDetailEntity.getGoodsNo() });
					// // modify by liangfuxiang 2013-5-23下午10:30:11 end;
				}
			}
		}
		else {
			// modify by liangfuxiang 2013-5-2上午9:17:02 begin BUG-8109 当查找不到走货路径在，不报错，需要重新生成走货路径
			if (StringUtils.equalsIgnoreCase(action, TransportPathConstants.TRANSPORTPATH_STATUS_SIGNIN)) {
				logger.warn("CalculateTransportPathService[rollBackList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + waybillNo);
			}
			else {
				// 异常:
				// 未查找到走货路径信息
				logger.error("CalculateTransportPathService[rollBackList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			}
		}
	}

	/**
	 * 回退到上一状态 , action为现状态
	 * 
	 * @author huyue
	 * @date 2012-10-23 下午5:12:17
	 */
	public void rollBack(String waybillNo, String serialNo, String vehicle, String action) throws TfrBusinessException {
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		
		// modify by liangfuxiang 2013-7-23下午5:34:20 begin BUG-47042 不再从备份迁移表中获取数据。
		// modify by liangfuxiang 2013-4-28上午10:18:18 begin BUG-8109 查询走货路径数据迁移表，查看是否已经被数据迁移。
		// if(null==transportPathEntity){
		// //查询数据迁移表
		// transportPathEntity=queryTransportPathMigration(waybillNo);
		// }
		// modify by liangfuxiang 2013-7-23下午5:34:26 end;
		// modify by liangfuxiang 2013-4-28上午10:19:52 end BUG-47042;
		// 走货路径非空
		if (null != transportPathEntity) {
			// 判断是不是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 设置流水号
				pathDetailEntity.setGoodsNo(serialNo);
			}
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置目的地编码
			pathDetailEntity.setObjectiveOrgCode(transportPathEntity.getNextOrgCode());
			// 查询走货路径详细信息列表
			List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
			
			// modify by liangfuxiang 2013-7-23下午5:34:20 begin BUG-47042 不再从备份迁移表中获取数据。
			// modify by liangfuxiang 2013-5-1下午2:54:14 begin BUG-8109
			// 若从明细表中无法查询到走货路径信息，则从数据迁移表中查询
			// if (pathDetailList.size() == 0) {
			// // 从数据迁移表中查询
			// pathDetailList = pathDetailDao.pathDetailNotReleaveFromMigration(pathDetailEntity);
			// }
			// modify by liangfuxiang 2013-5-1下午2:54:27 end;
			// modify by liangfuxiang 2013-4-28上午10:19:52 end BUG-47042;
			
			// 走货路径详细信息为空
			if (pathDetailList.size() == 0) {
				// 上一状态必须有值,表示不是连续回退.
				// 本改动所传递状态必须和实际状态一致.
				// 否则不能修改,因为分批配载,所以只影响到子表
				if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())) {
					// 更新上一状态为本状态
					transportPathEntity.setAction(transportPathEntity.getBeforeAction());
					// 设置上一状态为空
					transportPathEntity.setBeforeAction("");
					// 更新走货路径
					transportationPathDao.updateTransportPath(transportPathEntity);
				}
				// 走货路径详细信息列表唯一
			}
			else if (pathDetailList.size() == 1) {
				// 判断是不是出发
				if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_LEAVE, pathDetailList.get(0).getArriveOrLeave())) {
					// 如果是出发
					// 状态变成已交接
					pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
					// 实际出发时间变为空
					pathDetailList.get(0).setActualStartTime(null);
					// 更新明细信息
					pathDetailDao.updateListPathDetail(pathDetailList);
					// 上一状态必须有值,表示不是连续回退.
					// 本改动所传递状态必须和实际状态一致.
					// 否则不能修改,如果主表状态不是出发,则不修改状态
					if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_DEPART, transportPathEntity.getAction())) {
						// 更新上一状态为本状态
						transportPathEntity.setAction(transportPathEntity.getBeforeAction());
						// 设置上一状态为空
						transportPathEntity.setBeforeAction("");
						// 设置当前部门编码
						transportPathEntity.setCurrentOrgCode(pathDetailList.get(0).getOrigOrgCode());
						// 设置车牌号为空
						transportPathEntity.setVehicleNo("");
						// 更新走货路径
						transportationPathDao.updateTransportPath(transportPathEntity);
					}

				}// 判断是不是到达
				else if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE, pathDetailList.get(0).getArriveOrLeave())) {
					// 状态变成离开
					pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
					// 实际到达时间为空
					pathDetailList.get(0).setActualArriveTime(null);
					// 更新明细信息
					pathDetailDao.updateListPathDetail(pathDetailList);
					// 上一状态必须有值,表示不是连续回退.
					// 本改动所传递状态必须和实际状态一致.
					// 否则不能修改,如果主表状态不是出发,则不修改状态
					if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_ARRIVE, transportPathEntity.getAction())) {
						// 更新上一状态为本状态
						transportPathEntity.setAction(transportPathEntity.getBeforeAction());
						// 设置上一状态为空
						transportPathEntity.setBeforeAction("");
						// 设置当前部门编码为空
						transportPathEntity.setCurrentOrgCode("");
						// 设置车牌号
						transportPathEntity.setVehicleNo(vehicle);
						// 获取前一条路径明细的出发时间
						transportPathEntity.setPlanStartTime(pathDetailList.get(0).getModifyStartTime());
						// 到达时间
						transportPathEntity.setPlanArriveTime(pathDetailList.get(0).getModifyArriveTime());
						// 更新走货路径
						transportationPathDao.updateTransportPath(transportPathEntity);
					}

				}// 判断是不是交接
				else if (StringUtil.equals(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER, pathDetailList.get(0).getArriveOrLeave())) {
					// 状态变成未离开,实际出发时间变为空
					pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
					// 更新明细信息
					pathDetailDao.updateListPathDetail(pathDetailList);
					// 上一状态必须有值,表示不是连续回退.
					// 本改动所传递状态必须和实际状态一致.
					// 否则不能修改,如果主表状态不是交接,则不修改状态
					if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction()) && StringUtil.equals(TransportPathConstants.TRANSPORTPATH_STATUS_HANDOVER, transportPathEntity.getAction())) {
						// 更新上一状态为本状态
						transportPathEntity.setAction(transportPathEntity.getBeforeAction());
						// 设置上一状态为空
						transportPathEntity.setBeforeAction("");
						// 更新走货路径
						transportationPathDao.updateTransportPath(transportPathEntity);
					}
				}
				else {
					// 上一状态必须有值,表示不是连续回退.
					// 本改动所传递状态必须和实际状态一致.否则不能修改,因为分批配载,所以只影响到子表
					if (StringUtils.isNotEmpty(transportPathEntity.getBeforeAction())) {
						// 更新上一状态为本状态
						transportPathEntity.setAction(transportPathEntity.getBeforeAction());
						// 设置上一状态为空
						transportPathEntity.setBeforeAction("");
						// 更新走货路径
						transportationPathDao.updateTransportPath(transportPathEntity);
					}
				}
			}
			else {
				// modify by liangfuxiang 2013-5-23下午10:29:53 begin 增加日志 细化异常
				// 路径明细数据不唯一
				// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");

				// String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + pathDetailEntity.getWaybillNo()
				// + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + pathDetailEntity.getObjectiveOrgCode() + TransportPathConstants.BLANK_SPACE_STRING
				// + (StringUtils.isEmpty(pathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + pathDetailEntity.getGoodsNo()));
				// logger.error("CalculateTransportPathService[rollBack()]:" + exps);
				// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { pathDetailEntity.getWaybillNo(),
				// pathDetailEntity.getObjectiveOrgCode(), pathDetailEntity.getGoodsNo() });
				// modify by liangfuxiang 2013-5-23下午10:30:11 end;
			}
		}
		else {
			// modify by liangfuxiang 2013-5-2上午9:17:02 begin BUG-8109 当查找不到走货路径在，不报错，需要重新生成走货路径
			if (StringUtils.equalsIgnoreCase(action, TransportPathConstants.TRANSPORTPATH_STATUS_SIGNIN)) {
				logger.warn("CalculateTransportPathService[rollBack()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + waybillNo);
			}
			else {
				// 异常:
				// 未查找到走货路径
				logger.error("CalculateTransportPathService[rollBack()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			}
			// modify by liangfuxiang 2013-5-2上午9:18:05 end;
		}
	}

	/**
	 * @Title: queryTransportPathMigration
	 * @Description: 查询走货路径数据迁移表，查看是否已经被数据迁移。
	 * @param waybillNo
	 * @return 设定文件
	 * @return TransportPathEntity 返回类型
	 * @see queryTransportPathMigration
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-4-28 上午10:21:01
	 * @throws
	 */
	public TransportPathEntity queryTransportPathMigration(String waybillNo) throws TfrBusinessException {
		// 查询数据迁移表
		List<TransportPathEntity> transportPathEntityList = transportationPathDao.queryTransportPathMigration(waybillNo);

		if (CollectionUtils.isEmpty(transportPathEntityList)) {
			// 未查询到走货路径
			logger.info("CalculateTransportPathService[queryTransportPathMigration()]:" + TransportPathConstants.QUERY_TRANSPORT_PATH_FROM_MIGRATION_NORESULT + waybillNo);
			return null;
		}
		// 查询到多条，异常
		else if (transportPathEntityList.size() > 1) {
			logger.info("CalculateTransportPathService[queryTransportPathMigration()]:" + TransportPathConstants.MULTY_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.MULTY_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION_GLOB, new Object[] { waybillNo });
		}
		else {
			try {
				// 从数据迁移表中恢复走货路径主表以及详细信息到走货路径信息
				logger.info("CalculateTransportPathService[queryTransportPathMigration()]:" + TransportPathConstants.RECOVER_TRANSPORT_PATH_FROM_MIGRATION + waybillNo);
				transportationPathDao.recoverTransportPathMigration(waybillNo);
				return transportPathEntityList.get(0);
			}
			catch (TfrBusinessException e) {	
				// 异常处理
				//logger.error("CalculateTransportPathService[queryTransportPathMigration()]:" + TransportPathConstants.RECOVER_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION + waybillNo + e.getMessage());
				//throw new TfrBusinessException(TransportPathConstants.RECOVER_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION + e.getMessage());
				//BUG-8109 新的要求:反签收，如果恢复失败，无需报错 
				logger.info("CalculateTransportPathService[queryTransportPathMigration()]:" + TransportPathConstants.RECOVER_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION + waybillNo + e.getMessage());
				return transportPathEntityList.get(0);
			}
		}

	}

	/**
	 * 根据运单号,货件号,查询下一部门及出发时间 如果不在路径上,则DTO的result为wrong,如果在,并且在最后部门,则为nodata,如果在并且有下一部门 ,则为right并且有下一段的实体.
	 * 存在增删改查的操作 -- 调用的时候，若存在事务，事务的处理，注意回滚
	 * 
	 * @author huyue
	 * @date 2012-10-24 下午2:41:24
	 */
	public FeedbackDto getNextOrgAndTime(String waybillNo, String goodsNo, String correntOrgCode) throws TfrBusinessException {
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建上一走货路径详细信息对象
		PathDetailEntity beforePathDetailEntity = new PathDetailEntity();
		// 先查是否分批配载
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// modify by liangfuxiang 2013-5-3下午5:07:13 begin 对于走货路径为空处理 主表为空，则返回wrong 走货路径详细信息为空，则返回wrong
		// 以本部门为出发部门查询
		FeedbackDto feedback = new FeedbackDto();
		// 如果条目不为空
		// 而且是分批配载
		if (null != transportPathEntity) {
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 使用货件号进行查询
				pathDetailEntity.setGoodsNo(goodsNo);
				// 设置上一走货路径详细信息货件号
				beforePathDetailEntity.setGoodsNo(goodsNo);
			}
			// 以本部门为出发部门查询
			// FeedbackDto feedback = new FeedbackDto();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);

			// 当只根据运单号查询走货路径信息,查看走货路径是否存在.
			List<PathDetailEntity> allPathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
			// 若返回值为空，则表示明细表中午走货路径详细信息
			if (CollectionUtils.isEmpty(allPathDetailList)) {
				// 不存在走货路径
				feedback.setResult(TransportPathConstants.STATUS_WRONG);
			}
			else {
				// 设置当前部门
				pathDetailEntity.setOrigOrgCode(correntOrgCode);
				// 查询明细条目
				List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 以本部门为到达部门查询
				beforePathDetailEntity.setWaybillNo(waybillNo);
				// 设置目标部门
				beforePathDetailEntity.setObjectiveOrgCode(correntOrgCode);
				// 查询明细条目
				List<PathDetailEntity> beforePathDetailList = pathDetailDao.pathDetailNotReleave(beforePathDetailEntity);
				// 如果没有条目则返回无条目 这时可能无条目,所以不抛错误
				if (pathDetailList.size() == 0 && beforePathDetailList.size() == 0) {
					// modify by liangfuxiang 2013-7-16下午4:17:03 begin BUG-42167 线路问题 对于当前部门(correntOrgCode)为最终目的地,走货路径状态为RELEAVE的，查询不到走货路径。
					// feedback.setResult(TransportPathConstants.STATUS_WRONG);
					feedback = getDestOrgCodePathDetailInfo(waybillNo, correntOrgCode, pathDetailEntity, transportPathEntity, feedback, TransportPathConstants.STATUS_WRONG);
					// modify by liangfuxiang 2013-7-16下午4:26:46 end;
				}
				else if (pathDetailList.size() == 0 && beforePathDetailList.size() != 0) {
					// 在走货路径没有下一段
					feedback.setResult(TransportPathConstants.STATUS_NODATA);
					// 返回
					// return feedback;
				}
				else if (pathDetailList.size() == 1) {
					// 在走货路径并且有下一段
					feedback.setResult(TransportPathConstants.STATUS_RIGHT);
					// 设置走货路径详细信息
					feedback.setPathDetailEntity(pathDetailList.get(0));
					// 返回
					// return feedback;
				}
				else {
					
					// modify by liangfuxiang 2013-6-16下午8:48:53 begin 解决返回多条数据的异常
					// logger.error("CalculateTransportPathService[getNextOrgAndTime()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO
					// + waybillNo + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + correntOrgCode);
					// // // 如果大于一条则返回错误
					// throw new
					// TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB,
					// new Object[] { waybillNo, correntOrgCode,
					// TransportPathConstants.BLANK_SPACE_STRING });
					feedback.setResult(TransportPathConstants.STATUS_RIGHT);
					// 设置走货路径详细信息
					feedback.setPathDetailEntity(dealMaxRouteNoPathDetail(pathDetailList, transportPathEntity, correntOrgCode));
					// modify by liangfuxiang 2013-6-16下午8:49:19 end;
				}
			}
		}
		else {
			logger.warn("CalculateTransportPathService[getNextOrgAndTime()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + TransportPathConstants.WAYBILL_NO + waybillNo);
			// 不存在在走货路径
			feedback.setResult(TransportPathConstants.STATUS_WRONG);
		}

		return feedback;
		// modify by liangfuxiang 2013-5-3下午4:46:16 end;
	}

	
	/**
	 * 
	 * @Title: getNextOrgAndTimeForRWSplitting
	 * @Description: 此接口功能与getNextOrgAndTime一致，只是为了实现读写分离，将getNextOrgAndTime需要更新数据库的部分全部转换为只读的。
	 * @param waybillNo
	 * @param goodsNo
	 * @param correntOrgCode
	 * @return
	 * @throws TfrBusinessException 设定文件
	 * @return FeedbackDto 返回类型
	 * @see getNextOrgAndTimeForRWSplitting
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-8-5 上午10:32:38
	 * @throws
	 */
	@Override
	public FeedbackDto getNextOrgAndTimeForRWSplitting(String waybillNo, String goodsNo, String correntOrgCode) throws TfrBusinessException {
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建上一走货路径详细信息对象
		PathDetailEntity beforePathDetailEntity = new PathDetailEntity();
		// 先查是否分批配载
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 以本部门为出发部门查询
		FeedbackDto feedback = new FeedbackDto();
		// 如果条目不为空
		// 而且是分批配载
		if (null != transportPathEntity) {
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 使用货件号进行查询
				pathDetailEntity.setGoodsNo(goodsNo);
				// 设置上一走货路径详细信息货件号
				beforePathDetailEntity.setGoodsNo(goodsNo);
			}
			// 以本部门为出发部门查询
			// FeedbackDto feedback = new FeedbackDto();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);

			// 当只根据运单号查询走货路径信息,查看走货路径是否存在.
			List<PathDetailEntity> allPathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
			// 若返回值为空，则表示明细表中午走货路径详细信息
			if (CollectionUtils.isEmpty(allPathDetailList)) {
				// 不存在走货路径
				feedback.setResult(TransportPathConstants.STATUS_WRONG);
			}
			else {
				// 设置当前部门
				pathDetailEntity.setOrigOrgCode(correntOrgCode);
				// 查询明细条目
				List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 以本部门为到达部门查询
				beforePathDetailEntity.setWaybillNo(waybillNo);
				// 设置目标部门
				beforePathDetailEntity.setObjectiveOrgCode(correntOrgCode);
				// 查询明细条目
				List<PathDetailEntity> beforePathDetailList = pathDetailDao.pathDetailNotReleave(beforePathDetailEntity);
				// 如果没有条目则返回无条目 这时可能无条目,所以不抛错误
				if (pathDetailList.size() == 0 && beforePathDetailList.size() == 0) {
					feedback = getDestOrgCodePathDetailInfo(waybillNo, correntOrgCode, pathDetailEntity, transportPathEntity, feedback, TransportPathConstants.STATUS_WRONG);
				}
				else if (pathDetailList.size() == 0 && beforePathDetailList.size() != 0) {
					// 在走货路径没有下一段
					feedback.setResult(TransportPathConstants.STATUS_NODATA);
				}
				else if (pathDetailList.size() == 1) {
					// 在走货路径并且有下一段
					feedback.setResult(TransportPathConstants.STATUS_RIGHT);
					// 设置走货路径详细信息
					feedback.setPathDetailEntity(pathDetailList.get(0));
					// 返回
					// return feedback;
				}
				else {
					feedback.setResult(TransportPathConstants.STATUS_RIGHT);
					// 设置走货路径详细信息
					feedback.setPathDetailEntity(queryMaxRouteNoPathDetail(pathDetailList, transportPathEntity, correntOrgCode));
				}
			}
		}
		else {
			logger.warn("CalculateTransportPathService[getNextOrgAndTime()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + TransportPathConstants.WAYBILL_NO + waybillNo);
			// 不存在在走货路径
			feedback.setResult(TransportPathConstants.STATUS_WRONG);
		}

		return feedback;
	}
	
	
	/** 
	* @Title: queryMaxRouteNoPathDetail 
	* @Description: 获取最大路段的走货路径信息
	* @param pathDetailList
	* @param transportPathEntity
	* @param correntOrgCode
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see queryMaxRouteNoPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-8-5 上午10:39:31   
	* @throws 
	*/ 
	private PathDetailEntity queryMaxRouteNoPathDetail(List<PathDetailEntity> pathDetailList, TransportPathEntity transportPathEntity, String correntOrgCode) {
		// 按照路段号排序
		pathDetailList = sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);

		// 获取最大路段的信息
		PathDetailEntity maxRouteNoPathDetailEntity = new ArrayList<PathDetailEntity>(pathDetailList.subList(pathDetailList.size() - 1, pathDetailList.size())).get(0);
		
		return maxRouteNoPathDetailEntity;
	}

	/**
	 * 多货修改走货路径, 带serialNO, 如果不是分批则进行分批
	 * --出入库专用接口
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:48:53
	 */
	public void arriveMistake(String waybillNo, String serialNo, String arriveOrgCode, String beforeOrgCode) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-18下午7:03:37 begin BUG-8782 有效性验证
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		// 到达部门为空
		if (StringUtils.isEmpty(arriveOrgCode)) {
			logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.ARRIVEORGCODE_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.ARRIVEORGCODE_IS_NULL_GLOB);
		}
		// modify by liangfuxiang 2013-5-18下午7:03:41 end;
		
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// //新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 判断是否存在条目
		if (null != transportPathEntity) {
			// 如果是不是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 出现多货修改走货路径则自动分批
				transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
				// 拆分明细表
				seperatePathDetail(waybillNo);
				// 更新主表
				transportationPathDao.updateTransportPath(transportPathEntity);
			}
			// modify by liangfuxiang 2013-5-18下午7:09:39 begin BUG-8782
			// 分批配载，流水号要求非空
			else {
				if (StringUtils.isEmpty(serialNo)) {
					logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.SERIALNO_IS_NULL);
					throw new TfrBusinessException(TransportPathConstants.SERIALNO_IS_NULL_GLOB);
				}
			}
			// modify by liangfuxiang 2013-5-18下午7:09:52 end;
			if (StringUtils.isNotEmpty(beforeOrgCode)) {
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置流水号
				pathDetailEntity.setGoodsNo(serialNo);
				// 设置出发部门
				pathDetailEntity.setOrigOrgCode(beforeOrgCode);
				
				// 找到应该走却没有走的一条 更新数据为正确的
				List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 走货路径详细信息为空
				if (list.size() == 0) {
					// 置空
					pathDetailEntity = null;
					// 走货路径详细信息不唯一
				}
				else if (list.size() > 1) {
					// modify by liangfuxiang 2013-5-24上午11:42:07 begin 增加日志，细化异常信息
					// 抛出异常
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
					logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
							+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.CURRENT_ORGCODE + beforeOrgCode);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_CURR_GLOB, new Object[] { waybillNo, beforeOrgCode,
							TransportPathConstants.BLANK_SPACE_STRING });
					// modify by liangfuxiang 2013-5-24上午11:42:46 end;
				}
				else {
					// 走货路径详细信息唯一
					// 赋值
					BeanUtils.copyProperties(list.get(0), pathDetailEntity);
				}
				// 走货路径为空
				if (null == pathDetailEntity) {
					// 查询有效的走货路径详细信息
					PathDetailEntity wrongPath = queryEffect(waybillNo, serialNo);

					// 走货路径详细信息为空
					if (null == wrongPath) {

						// modify by liangfuxiang 2013-7-4上午10:47:49 begin BUG-40029 将最大RELEAVE的路段返回。
						pathDetailEntity = new PathDetailEntity();
						// 设置运载单号
						pathDetailEntity.setWaybillNo(waybillNo);
						// 设置流水号
						pathDetailEntity.setGoodsNo(serialNo);

						wrongPath = getMaxReleavePathDetailEntity(pathDetailEntity);

						if (null == wrongPath) {
							// modify by liangfuxiang 2013-5-24上午11:42:07 begin 增加日志，细化异常信息
							// 异常：
							// 找不到走货路径
							// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
							logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO
									+ waybillNo + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.SERIAL_NO + serialNo);
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_ONLY_SER, new Object[] { waybillNo, serialNo });
							// modify by liangfuxiang 2013-5-24上午11:42:46 end;
						}
						else {
							pathDetailEntity = wrongPath;
						}

					}
					else {
						// 赋值
						pathDetailEntity = wrongPath;
					}
					// modify by liangfuxiang 2013-7-4上午10:47:54 end;
				}
			}
			else {
				// 查询有效的走货路径详细信息
				PathDetailEntity wrongPath = queryEffect(waybillNo, serialNo);
				// 走货路径详细信息为空
				if (null == wrongPath) {

					// modify by liangfuxiang 2013-7-4上午10:47:49 begin BUG-40029 将最大RELEAVE的路段返回。
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(serialNo);
					wrongPath = getMaxReleavePathDetailEntity(pathDetailEntity);

					if (null == wrongPath) {
						// modify by liangfuxiang 2013-5-24上午11:42:07 begin 增加日志，细化异常信息
						// 异常：
						// 找不到走货路径
						// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
						logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO
								+ waybillNo + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.SERIAL_NO + serialNo);
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_ONLY_SER, new Object[] { waybillNo, serialNo });
						// modify by liangfuxiang 2013-5-24上午11:42:46 end;
					}
					else {
						pathDetailEntity = wrongPath;
					}
				}
				else {
					// 赋值
					pathDetailEntity = wrongPath;
				}
				// modify by liangfuxiang 2013-7-4上午10:47:54 end;
			}
			
			// modify by liangfuxiang 2013-7-4上午10:47:49 begin BUG-40029 将最大RELEAVE的路段返回。
			// 将之前的路径全部置为RELEAVE状态
			releaveBeforePathDetails(pathDetailEntity);
			// modify by liangfuxiang 2013-7-4上午10:47:54 end;
			
			// set values
			pathDetailEntity.setObjectiveOrgCode(arriveOrgCode);
			// 不知道上一段的具体时间,设置为空标识多货异常
			pathDetailEntity.setActualArriveTime(null);
			// 设置时间出发时间为空
			pathDetailEntity.setActualStartTime(null);
			// 设置计划到达时间为空
			pathDetailEntity.setPlanArriveTime(null);
			// 设置计划出发时间为空
			pathDetailEntity.setPlanStartTime(null);
			// 设置修改到达时间为空
			pathDetailEntity.setModifyArriveTime(null);
			// 设置修改出发时间为空
			pathDetailEntity.setModifyStartTime(null);
			// 路径明细状态 抵达
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
			// 更新明细表
			pathDetailDao.updatePathDetail(pathDetailEntity);
			
			// modify by liangfuxiang 2013-5-28上午11:50:53 begin  BUG-12953 增加多个运输类型的查找
			// 进行路径明细修改
			//alterDetail(waybillNo, serialNo, arriveOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(), transportPathEntity.getTransportModel()); 
			alterDetailMultTrasportModel(waybillNo, serialNo, arriveOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getBillingOrgCode(), transportPathEntity.getTransportModel()); 
			// modify by liangfuxiang 2013-5-28上午11:50:59 end;
			
			//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
			// 分批配载更新主表path
			//transportPathEntity.setTransportPath(getChangedPath(transportPathEntity.getWaybillNo()));
			
			// modify by liangfuxiang 2013-6-25下午3:08:43 begin  需要更新主表相应的状态
			transportPathEntity.setAction(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
			// modify by liangfuxiang 2013-6-25下午3:08:47 end;
			
			// 更新主表
			transportationPathDao.updateTransportPath(transportPathEntity);
		}
		else {
			// modify by liangfuxiang 2013-5-24上午11:42:07 begin 增加日志，细化异常信息
			// 异常：
			// 找不到走货路径
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[arriveMistake()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午11:42:46 end;
		}
	}

	/**
	 * 修改违禁品后序走货路径
	 * 
	 * 
	 * @author huyue
	 * @date 2012-12-5 下午3:49:20
	 */
	@Transactional
	public void contraband(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode) throws TfrBusinessException {
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 判断是否存在条目
		if (null != transportPathEntity) {
			// 如果是不是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置出发部门
				pathDetailEntity.setOrigOrgCode(nowOrgCode);
				// 非分批配载
			}
			else {
				// 设置运载单号
				pathDetailEntity.setWaybillNo(waybillNo);
				// 设置流水号
				pathDetailEntity.setGoodsNo(serialNo);
				// 设置出发部门
				pathDetailEntity.setOrigOrgCode(nowOrgCode);
			}
			// 找到应该走却没有走的一条 更新数据为正确的
			List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
			// 走货路径详细信息为空
			if (list.size() == 0) {
				// 异常：
				// 找不到走货路径
				// modify by liangfuxiang 2013-5-24上午11:52:38 begin
				// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
				logger.error("CalculateTransportPathService[contraband()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA + TransportPathConstants.WAYBILL_NO + waybillNo
						+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.CURRENT_ORGCODE + nowOrgCode
						+ (StringUtils.isEmpty(serialNo) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + serialNo)));
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_SER_GLOB, new Object[] { waybillNo, nowOrgCode, serialNo });
				// modify by liangfuxiang 2013-5-24上午11:52:44 end;
				// 走货路径详细信息不唯一
			}
			else if (list.size() > 1) {
				// 异常：
				// 找不到走货路径
				// modify by liangfuxiang 2013-5-24上午11:52:38 begin
				// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
				logger.error("CalculateTransportPathService[contraband()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
						+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.CURRENT_ORGCODE + nowOrgCode
						+ (StringUtils.isEmpty(serialNo) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + serialNo)));
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_CURR_GLOB, new Object[] { waybillNo, nowOrgCode, serialNo });
				// modify by liangfuxiang 2013-5-24上午11:52:44 end;
			}
			else {
				// 赋值
				BeanUtils.copyProperties(list.get(0), pathDetailEntity);
				// 设置出发部门
				String origObjectiveOrgCode = pathDetailEntity.getObjectiveOrgCode();
				// set values
				pathDetailEntity.setObjectiveOrgCode(destOrgCode);
				// 不知道上一段的具体时间,设置为空标识多货异常
				pathDetailEntity.setActualArriveTime(null);
				// 设置时间出发时间为空
				pathDetailEntity.setActualStartTime(null);
				// 设置计划到达时间为空
				pathDetailEntity.setPlanArriveTime(null);
				// 设置计划出发时间为空
				pathDetailEntity.setPlanStartTime(null);
				// 设置修改到达时间为空
				pathDetailEntity.setModifyArriveTime(null);
				// 设置修改出发时间为空
				pathDetailEntity.setModifyStartTime(null);
				// 路径明细状态 入库
				pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
				// 更新明细表
				pathDetailDao.updatePathDetail(pathDetailEntity);
				// 删除后序条目
				pathDetailEntity = new PathDetailEntity();
				// 如果是不是分批
				if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
					// 设置运载单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置出发部门
					pathDetailEntity.setOrigOrgCode(origObjectiveOrgCode);
					// 非分批配载
				}
				else {
					// 设置运载单号
					pathDetailEntity.setWaybillNo(waybillNo);
					// 设置流水号
					pathDetailEntity.setGoodsNo(serialNo);
					// 设置出发部门
					pathDetailEntity.setOrigOrgCode(origObjectiveOrgCode);
				}
				// 查询走货路径详细信息列表
				List<PathDetailEntity> oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
				// 走货路径详细信息非空
				if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
					// 批量删除走货路径详细信息
					pathDetailDao.deleteListPathDetail(oldPathDetailList);
				}
			}

		}
	}

	// modify by liangfuxiang 2013-5-28上午11:39:15 begin BUG-12953
	/**
	 * 
	* @Title: alterDetailMultTransModel 
	* @Description: 内部实现逻辑与alterDetail()接口一致，唯一修改的地方是增加了多个运输类型的查找。
	* @param waybillNo
	* @param serialNo
	* @param nowOrgCode
	* @param destOrgCode
	* @param billingOrgCode
	* @param model
	* @throws TfrBusinessException  设定文件 
	* @return void    返回类型 
	* @see alterDetailMultTransModel
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-28 上午11:40:06   
	* @throws
	 */
	private void alterDetailMultTrasportModel(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String billingOrgCode, String model) throws TfrBusinessException {
		// 路段号
		int routeNo = 0;
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建走货路径详细信息列表
		List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
		// 新建走货路径详细信息列表-原信息
		List<PathDetailEntity> oldPathDetailList;
		// 设置运载单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 设置流水号
		pathDetailEntity.setGoodsNo(serialNo);
		// 找到目标部门为现部门的一条数据
		pathDetailEntity.setObjectiveOrgCode(nowOrgCode);
		// 查询走货路径详细信息列表
		List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
		
		// modify by liangfuxiang 2013-7-26下午2:15:46 begin BUG-47421
		
		//判断对象pathDetailEntity是否为查询获取到的。
		boolean pathEntityQueryed = false;
		
		if (CollectionUtils.isEmpty(list)) {
			//抛开状态的查找
			list = queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
		}
		// modify by liangfuxiang 2013-7-26下午2:15:50 end;
		
		// 走货路径详细信息为空
		if (list.size() == 0) {
			// 走货路径详细信息为空
			pathDetailEntity = null;
			// 走货路径详细信息不唯一
		}
		else if (list.size() > 1) {
			// 异常：
			// 找不到走货路径
			// modify by liangfuxiang 2013-5-24上午11:52:38 begin
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
			logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
					+ TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + nowOrgCode
					+ (StringUtils.isEmpty(serialNo) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + serialNo)));
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[]{waybillNo,nowOrgCode,serialNo});
			// modify by liangfuxiang 2013-5-24上午11:52:44 end;
		}
		else {
			
			pathEntityQueryed = true;
			
			// 赋值
			BeanUtils.copyProperties(list.get(0), pathDetailEntity);
		}
		// 走货路径详细信息非空
		if (null != pathDetailEntity) {
			// 设置路段号
			routeNo = Integer.parseInt(pathDetailEntity.getRouteNo());
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.listQueryNextStep(pathDetailEntity);
		}
		else {
			// 表示没有之前的条目,则需要把所有路径都进行删除
			pathDetailEntity = new PathDetailEntity();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置流水号
			pathDetailEntity.setGoodsNo(serialNo);
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		}
		// 走货路径线路列表
		List<FreightRouteLineDto> freightRouteLineDto = null;
		try {
			// 调用基础资料接口得到路径detail 从现部门之后
			freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, model, new Date());
		}
		catch (Exception e) {
			// 异常：
			// 找不到走货路径
			// modify by liangfuxiang 2013-5-24下午12:56:57 begin
			logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH+ queryFreightRouteBySourceTarget + ", " + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			// modify by liangfuxiang 2013-5-24下午12:57:08 end;
			/*throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { queryFreightRouteBySourceTarget,
					", " + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode });*/
			//多个运输类型查询
			freightRouteLineDto = queryFreightRouteLineDtoByMultTrasportModel(freightRouteLineDto, nowOrgCode,destOrgCode,model);
			
		}
		
		// 走货路径线路为空
		if (CollectionUtils.isEmpty(freightRouteLineDto)) {
			// modify by liangfuxiang 2013-5-24下午12:56:57 begin
			logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH+ queryFreightRouteBySourceTarget + ", " + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			// modify by liangfuxiang 2013-5-24下午12:57:08 end;
			// 异常：
			// 找不到走货路径
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
		}
		else {

			if(pathEntityQueryed){
				// modify by liangfuxiang 2013-4-24下午5:48:28 begin BUG-7600
				// 将老路径，最后一站未变更的路径的下一部门设置为目标部门
				if (StringUtils.isNotEmpty(pathDetailEntity.getObjectiveOrgCode())) {
					pathDetailEntity.setNextDestOrgCode(freightRouteLineDto.get(0).getTargetCode());
					pathDetailEntity.setNextArriveTime(freightRouteLineDto.get(0).getArriveDate());
					pathDetailDao.updatePathDetail(pathDetailEntity);
				}
				// modify by liangfuxiang 2013-4-24下午5:48:57 end;
			}

			// 赋值
			for (int i = 0; i < freightRouteLineDto.size(); i++) {
				// 新建
				newPathDetailList.add(new PathDetailEntity());
				// 设置出发部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+ queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode) });
				}
				// 设置出发部门
				newPathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
				// 设置到达部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+ queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径目的地
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
							TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode) });
				}
				newPathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
				// 设置下一到达部门
				if ((i + 1) < freightRouteLineDto.size()) {
					// 设置下一目的地
					newPathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
					// 设置到达时间
					newPathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
				}
				// 设置开单部门
				newPathDetailList.get(i).setBillingOrgCode(billingOrgCode);
				// 重新确定ourteNo
				newPathDetailList.get(i).setRouteNo(String.valueOf(routeNo + i + 1));
				// 设置计划出发时间
				if (null == freightRouteLineDto.get(i).getLeaveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-24下午12:56:57 begin
						logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+ queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24下午12:57:08 end;
						// 异常：
						// 找不到出发时间
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 根据条件设置出发时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
						}
						else {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(new Date());
						}
					}
				}
				// 设置计划出发时间
				newPathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置计划到达时间
				if (null == freightRouteLineDto.get(i).getArriveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-24下午12:56:57 begin
						logger.error("CalculateTransportPathService[alterDetailMultTrasportModel()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+ queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24下午12:57:08 end;
						// 异常：
						// 找不到到达时间
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 上一路段到达时间
						long beforeArrive = (new Date()).getTime();
						// 到达时间非空
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 上一路段到达时间
							beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
						}
						// 分钟
						long min = freightRouteLineDto.get(i).getAging();
						// 到达日期
						Date arrive = new Date(sixtyThousand * min + beforeArrive);
						// 设置到达日期
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
				}
				newPathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置调整出发时间
				newPathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置调整到达时间
				newPathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置是否调整时间
				newPathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置其他基本信息
				newPathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
				// 设置单号
				newPathDetailList.get(i).setWaybillNo(waybillNo);
				// 设置流水号
				newPathDetailList.get(i).setGoodsNo(serialNo);
				// 更新状态
				newPathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			}

			// 原路径信息非空
			if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
				// 批量删除
				pathDetailDao.deleteListPathDetail(oldPathDetailList);
			}
			
			// modify by liangfuxiang 2013-7-26下午2:29:22 begin BUG-47421
			// 未查询到老的路径
			if (!pathEntityQueryed && newPathDetailList.size() == 1) {
				// 需要拼接一段走货路径
				List<PathDetailEntity> splicePathDetailEntityList = null;
				// 拼接
				newPathDetailList = spliceFirstPathDetail(newPathDetailList, serialNo, splicePathDetailEntityList);
			}
			
			//若调整的走货路径的开始部门与目标部门一致
			//则新生成的走货路径为A-B B-A其中A为目的部门---要将A-B的状态更新为RELEAVE状态
			//因为这个接口唯一被arrvieMistake调用，故可将之前的所有状态均置为为RELEAVE
			if(StringUtils.equalsIgnoreCase(nowOrgCode, destOrgCode)){
				for(int j=0;j< newPathDetailList.size()-1;j++){
					// 置为RELEAVE
					newPathDetailList.get(j).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
					// 加一个标示
					newPathDetailList.get(j).setTruckDetailId(TransportPathConstants.HIDDEN_RECREATE_SAMEORGOBJ);
				}
			}
			// modify by liangfuxiang 2013-7-26下午2:29:42 end; 
			
			// 新路径非空
			if (newPathDetailList.size() > 0) {
				// 批量增加
				pathDetailDao.addListPathDetail(newPathDetailList);
			}
		}
	}
	
	/**
	 * @Title: queryFreightRouteLineDtoByMultTrasportModel
	 * @Description: 查询路线
	 * @param freightRouteLineDto
	 * @param nowOrgCode
	 * @param destOrgCode
	 * @param model
	 * @return 设定文件
	 * @return List<FreightRouteLineDto> 返回类型
	 * @see queryFreightRouteLineDtoByMultTrasportModel
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-28 上午11:46:24
	 * @throws
	 */
	private List<FreightRouteLineDto> queryFreightRouteLineDtoByMultTrasportModel(List<FreightRouteLineDto> freightRouteLineDto, String nowOrgCode, String destOrgCode, String model) {
		// 构建对象
		TransportPathEntity transportPathEntity = new TransportPathEntity();
		transportPathEntity.setCurrentOrgCode(nowOrgCode);
		transportPathEntity.setDestOrgCode(destOrgCode);
		transportPathEntity.setTransportModel(model);
		// 查询多种运输类型
		freightRouteLineDto = queryFreightRouteLineDtoByOtherTrasportModel(freightRouteLineDto, transportPathEntity);
		return freightRouteLineDto;
	}

	// modify by liangfuxiang 2013-5-28上午11:38:55 end;
	/**
	 * 调整路径明细路径
	 * 
	 * 
	 * @author huyue
	 * @date 2012-10-19 下午1:55:26
	 */
	public void alterDetail(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String billingOrgCode, String model) throws TfrBusinessException {
		// 路段号
		int routeNo = 0;
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建走货路径详细信息列表
		List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
		// 新建走货路径详细信息列表-原信息
		List<PathDetailEntity> oldPathDetailList;
		// 设置运载单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 设置流水号
		pathDetailEntity.setGoodsNo(serialNo);
		// 找到目标部门为现部门的一条数据
		pathDetailEntity.setObjectiveOrgCode(nowOrgCode);
		// 查询走货路径详细信息列表
		List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
		
		// modify by liangfuxiang 2013-7-26下午2:48:14 begin BUG-47421
		//判断对象pathDetailEntity是否为查询获取到的。
		boolean pathEntityQueryed = false;
		// modify by liangfuxiang 2013-7-26下午2:48:33 end;
		
		// 走货路径详细信息为空
		if (list.size() == 0) {
			// 走货路径详细信息为空
			pathDetailEntity = null;
			// 走货路径详细信息不唯一
		}
		else if (list.size() > 1) {

			// modify by liangfuxiang 2013-8-6下午3:36:42 begin BUG-49390 西安转运中心货区问题
			// 查询返回多条的时候，将最后一条返回

			// 异常：
			// 找不到走货路径
			// modify by liangfuxiang 2013-5-24上午11:52:38 begin
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
			// logger.error("CalculateTransportPathService[alterDetail()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo
			// + TransportPathConstants.BLANK_SPACE_STRING + TransportPathConstants.DEST_ORGCODE + nowOrgCode
			// + (StringUtils.isEmpty(serialNo) ? TransportPathConstants.BLANK_SPACE_STRING : (TransportPathConstants.SERIAL_NO + serialNo)));
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { waybillNo, nowOrgCode, serialNo });
			// // modify by liangfuxiang 2013-5-24上午11:52:44 end;
			pathDetailEntity = list.get(list.size() - 1);
			// modify by liangfuxiang 2013-8-6下午3:36:51 end BUG-49390 西安转运中心货区问题;
		}
		else {
			// 赋值
			BeanUtils.copyProperties(list.get(0), pathDetailEntity);
		}
		// 走货路径详细信息非空
		if (null != pathDetailEntity) {
			
			pathEntityQueryed = true;
			
			// 设置路段号
			routeNo = Integer.parseInt(pathDetailEntity.getRouteNo());
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.listQueryNextStep(pathDetailEntity);
		}
		else {
			// 表示没有之前的条目,则需要把所有路径都进行删除
			pathDetailEntity = new PathDetailEntity();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置流水号
			pathDetailEntity.setGoodsNo(serialNo);
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		}
		// 走货路径线路列表
		List<FreightRouteLineDto> freightRouteLineDto = null;
		try {
			// 调用基础资料接口得到路径detail 从现部门之后
			freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, model, new Date());
		}
		catch (Exception e) {
			// 异常：
			// 找不到走货路径
			// modify by liangfuxiang 2013-5-24下午12:56:57 begin
			logger.error("CalculateTransportPathService[alterDetail()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH+ queryFreightRouteBySourceTarget + ", " + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			// modify by liangfuxiang 2013-5-24下午12:57:08 end;
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
			
		}
		// 走货路径线路为空
		if (CollectionUtils.isEmpty(freightRouteLineDto)) {
			// modify by liangfuxiang 2013-5-24下午12:56:57 begin
			logger.error("CalculateTransportPathService[alterDetail()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH+ queryFreightRouteBySourceTarget + ", " + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			// modify by liangfuxiang 2013-5-24下午12:57:08 end;
			// 异常：
			// 找不到走货路径
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
		}
		else {
			// modify by liangfuxiang 2013-7-26下午2:48:14 begin BUG-47421
			if(pathEntityQueryed){
				// modify by liangfuxiang 2013-4-24下午5:48:28 begin BUG-7600
				// 将老路径，最后一站未变更的路径的下一部门设置为目标部门
				if (StringUtils.isNotEmpty(pathDetailEntity.getObjectiveOrgCode())) {
					pathDetailEntity.setNextDestOrgCode(freightRouteLineDto.get(0).getTargetCode());
					pathDetailEntity.setNextArriveTime(freightRouteLineDto.get(0).getArriveDate());
					pathDetailDao.updatePathDetail(pathDetailEntity);
				}
				// modify by liangfuxiang 2013-4-24下午5:48:57 end;
			}
			// modify by liangfuxiang 2013-7-26下午2:48:14 end BUG-47421


			// 赋值
			for (int i = 0; i < freightRouteLineDto.size(); i++) {
				// 新建
				newPathDetailList.add(new PathDetailEntity());
				// 设置出发部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetail()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+ queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode) });
				}
				// 设置出发部门
				newPathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
				// 设置到达部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetail()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+ queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径目的地
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
							TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode) });
				}
				newPathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
				// 设置下一到达部门
				if ((i + 1) < freightRouteLineDto.size()) {
					// 设置下一目的地
					newPathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
					// 设置到达时间
					newPathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
				}
				// 设置开单部门
				newPathDetailList.get(i).setBillingOrgCode(billingOrgCode);
				// 重新确定ourteNo
				newPathDetailList.get(i).setRouteNo(String.valueOf(routeNo + i + 1));
				// 设置计划出发时间
				if (null == freightRouteLineDto.get(i).getLeaveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-24下午12:56:57 begin
						logger.error("CalculateTransportPathService[alterDetail()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+ queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24下午12:57:08 end;
						// 异常：
						// 找不到出发时间
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 根据条件设置出发时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
						}
						else {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(new Date());
						}
					}
				}
				// 设置计划出发时间
				newPathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置计划到达时间
				if (null == freightRouteLineDto.get(i).getArriveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-24下午12:56:57 begin
						logger.error("CalculateTransportPathService[alterDetail()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+ queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24下午12:57:08 end;
						// 异常：
						// 找不到到达时间
						// modify by liangfuxiang 2013-7-1上午11:20:35 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget, freightRouteLineDto.get(i) });
					}
					else {
						// 上一路段到达时间
						long beforeArrive = (new Date()).getTime();
						// 到达时间非空
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 上一路段到达时间
							beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
						}
						// 分钟
						long min = freightRouteLineDto.get(i).getAging();
						// 到达日期
						Date arrive = new Date(sixtyThousand * min + beforeArrive);
						// 设置到达日期
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
				}
				newPathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置调整出发时间
				newPathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置调整到达时间
				newPathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置是否调整时间
				newPathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置其他基本信息
				newPathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
				// 设置单号
				newPathDetailList.get(i).setWaybillNo(waybillNo);
				// 设置流水号
				newPathDetailList.get(i).setGoodsNo(serialNo);
				// 更新状态
				newPathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			}
			
			// 原路径信息非空
			if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
				// 批量删除
				pathDetailDao.deleteListPathDetail(oldPathDetailList);
			}
			
			// modify by liangfuxiang 2013-7-26下午2:29:22 begin BUG-47421
			//未查询到老的路径
			if(!pathEntityQueryed && newPathDetailList.size() == 1){
				//需要拼接一段走货路径
				List<PathDetailEntity> splicePathDetailEntityList = null;
				// 拼接
				newPathDetailList = spliceFirstPathDetail(newPathDetailList, serialNo, splicePathDetailEntityList);
			}
			// modify by liangfuxiang 2013-7-26下午2:51:21 end; 
			
			// 新路径非空
			if (newPathDetailList.size() > 0) {
				// 批量增加
				pathDetailDao.addListPathDetail(newPathDetailList);
			}
		}
	}

	@Override
	public void alterDetailForRecreateTransportaionPath(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String billingOrgCode, String model) throws TfrBusinessException {
		// 路段号
		int routeNo = 0;
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
//		// 新建走货路径详细信息列表
		List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
//		// 新建走货路径详细信息列表-原信息
		List<PathDetailEntity> oldPathDetailList;
//		// 设置运载单号
//		pathDetailEntity.setWaybillNo(waybillNo);
//		// 设置流水号
//		pathDetailEntity.setGoodsNo(serialNo);
//		// 找到目标部门为现部门的一条数据
//		pathDetailEntity.setObjectiveOrgCode(nowOrgCode);
//		// 查询走货路径详细信息列表
//		List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
//		// 走货路径详细信息为空
//		if (list.size() == 0) {
//			// 走货路径详细信息为空
//			pathDetailEntity = null;
//			// 走货路径详细信息不唯一
//		}
//		else if (list.size() > 1) {
//			// modify by liangfuxiang 2013-5-24下午1:03:34 begin 增加日志 修改异常信息详情
//			// 异常：
//			// 找不到走货路径
//			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
//			String exps = TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE + TransportPathConstants.WAYBILL_NO + waybillNo + TransportPathConstants.BLANK_SPACE_STRING
//					+ TransportPathConstants.DEST_ORGCODE + nowOrgCode + TransportPathConstants.BLANK_SPACE_STRING
//					+ (StringUtils.isEmpty(serialNo) ? nowOrgCode + TransportPathConstants.BLANK_SPACE_STRING : (nowOrgCode + TransportPathConstants.BLANK_SPACE_STRING + serialNo));
//			logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" + exps);
//			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { waybillNo, nowOrgCode, serialNo });
//			// modify by liangfuxiang 2013-5-24下午1:04:02 end;
//		}
//		else {
//			// 赋值
//			BeanUtils.copyProperties(list.get(0), pathDetailEntity);
//		}

		pathDetailEntity = new PathDetailEntity();
		// 设置运载单号
		pathDetailEntity.setWaybillNo(waybillNo);

		oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		
		/*
		 * // 走货路径详细信息非空 if (null != pathDetailEntity) { // 设置路段号 routeNo = Integer.parseInt(pathDetailEntity.getRouteNo()); // 把所有查询出来的条目都放到老数据中等待删除 oldPathDetailList
		 * =pathDetailDao.listQueryNextStep(pathDetailEntity); } else { // 表示没有之前的条目,则需要把所有路径都进行删除 pathDetailEntity = new PathDetailEntity(); // 设置运载单号 pathDetailEntity.setWaybillNo(waybillNo);
		 * //设置流水号 pathDetailEntity.setGoodsNo(serialNo); // 把所有查询出来的条目都放到老数据中等待删除 oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity); }
		 */

		// 走货路径线路列表
		List<FreightRouteLineDto> freightRouteLineDto = null;
		try {
			// 调用基础资料接口得到路径detail 从现部门之后
			freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, model, new Date());
		}
		catch (Exception e) {
			// modify by liangfuxiang 2013-5-24下午12:56:57 begin
			logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH
					+ queryFreightRouteBySourceTarget + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			// modify by liangfuxiang 2013-5-24下午12:57:08 end;
			// 异常：
			// 找不到走货路径
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
		}
		// 走货路径线路为空
		if (CollectionUtils.isEmpty(freightRouteLineDto)) {
			// modify by liangfuxiang 2013-5-24下午12:56:57 begin
			logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH
					+ queryFreightRouteBySourceTarget + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			// modify by liangfuxiang 2013-5-24下午12:57:08 end;
			// 异常：
			// 找不到走货路径
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
		}
		else {
			// 赋值
			for (int i = 0; i < freightRouteLineDto.size(); i++) {
				// 新建
				newPathDetailList.add(new PathDetailEntity());
				// 设置出发部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+ queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode)  });
				}
				// 设置出发部门
				newPathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
				// 设置到达部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+ queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径目的地
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
							TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode) });
				}
				newPathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
				// 设置下一到达部门
				if ((i + 1) < freightRouteLineDto.size()) {
					// 设置下一目的地
					newPathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
					// 设置到达时间
					newPathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
				}
				// 设置开单部门
				newPathDetailList.get(i).setBillingOrgCode(billingOrgCode);
				// 重新确定ourteNo
				newPathDetailList.get(i).setRouteNo(String.valueOf(routeNo + i + 1));
				// 设置计划出发时间
				if (null == freightRouteLineDto.get(i).getLeaveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-24下午12:56:57 begin
						logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+ queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24下午12:57:08 end;
						// 异常：
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 根据条件设置出发时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
						}
						else {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(new Date());
						}
					}
				}
				// 设置计划出发时间
				newPathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置计划到达时间
				if (null == freightRouteLineDto.get(i).getArriveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// modify by liangfuxiang 2013-5-24下午12:56:57 begin
						logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+ queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24下午12:57:08 end;
						// 异常：
						// 找不到到达时间
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 上一路段到达时间
						long beforeArrive = (new Date()).getTime();
						// 到达时间非空
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 上一路段到达时间
							beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
						}
						// 分钟
						long min = freightRouteLineDto.get(i).getAging();
						// 到达日期
						Date arrive = new Date(sixtyThousand * min + beforeArrive);
						// 设置到达日期
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
				}
				newPathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置调整出发时间
				newPathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置调整到达时间
				newPathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置是否调整时间
				newPathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置其他基本信息
				newPathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
				// 设置单号
				newPathDetailList.get(i).setWaybillNo(waybillNo);
				// 设置流水号
				newPathDetailList.get(i).setGoodsNo(serialNo);
				// 更新状态
				newPathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			}
			// 原路径信息非空
			if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
				// 批量删除
				pathDetailDao.deleteListPathDetail(oldPathDetailList);
			}
			// 新路径非空
			if (newPathDetailList.size() > 0) {
				// 批量增加
				pathDetailDao.addListPathDetail(newPathDetailList);
			}
		}
	}

	/**
	 * 非合车调整走货路径
	 * 
	 * 
	 * @author huyue
	 * @date 2012-11-6 下午7:59:32
	 */
	public void notJoinCarModify(String waybillNo, String serialNo, String origGoodsAreaCode, Date modifyTime, String nowOrgCode) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-9下午1:41:11 begin BUG-10112
		// 对输入的参数进行有效性判断
		varifyInputParameters(waybillNo, origGoodsAreaCode, modifyTime, nowOrgCode);
		// modify by liangfuxiang 2013-5-9下午1:41:26 end; BUG-10112
		
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建走货路径详细信息列表
		List<PathDetailEntity> changePathDetailList = new ArrayList<PathDetailEntity>();
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 查询走货路径为空
		if (null == transportPathEntity) {
			// 异常：
			// 找不到走货路径
			// modify by liangfuxiang 2013-5-24下午2:55:26 begin 增加日志
			logger.error("CalculateTransportPathService[notJoinCarModify()]:"+TransportPathConstants.TRANSPORTPATH_ADJUST_WAYBILLNO+TransportPathConstants.WAYBILL_NO+waybillNo);
			// modify by liangfuxiang 2013-5-24下午2:55:38 end;
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_ADJUST_WAYBILLNO, new Object[] { ": ", waybillNo });
		}
		// 判断是否分批配载
		// 如果是否分批字段有值,则表示已经分批,否则进行拆分
		if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
			// 设置主表分批字段为1
			transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
			// 拆分明细表
			seperatePathDetail(waybillNo);
			// 更新走货路径
			transportationPathDao.updateTransportPath(transportPathEntity);
		}
		
		// modify by liangfuxiang 2013-5-9下午1:41:37 begin BUG-10112
		// 分批配载时，流水号非空
		if (TransportPathConstants.PARTIALSTOWAGE.equalsIgnoreCase(transportPathEntity.getIfPartialStowage())) {
			if (StringUtils.isEmpty(serialNo)) {
				logger.error("CalculateTransportPathService[notJoinCarModify()]:" + TransportPathConstants.NOTJOINCARMODIFY_SERIALNO_NULL + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.NOTJOINCARMODIFY_SERIALNO_NULL_GLOB, new Object[] { waybillNo });
			}
		}
		// modify by liangfuxiang 2013-5-9下午1:41:41 BUG-10112 end;
		
		// 查找到目标部门为当前部门的detail条目
		pathDetailEntity.setWaybillNo(waybillNo);
		// 分批,需要判断货件号查询明细条目
		pathDetailEntity.setGoodsNo(serialNo);
		// 设置目的地
		pathDetailEntity.setObjectiveOrgCode(nowOrgCode);
		// 查询走货路径详细信息列表
		List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
		// 走货路径详细信息列表为空
		if (list.size() == 0) {
			// 走货路径详细信息为空
			pathDetailEntity = null;
			// 走货路径详细信息非空
		}
		else if (list.size() > 1) {
			
			// modify by liangfuxiang 2013-6-16下午9:56:26 begin 修改，只保留大路段的,小路段号的置为releave.
			// 异常
			// 路径不唯一
			// modify by liangfuxiang 2013-5-24下午2:55:26 begin 增加日志  BUG-23308 调整走货路径 查询走货路径明细多于一条
			//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
			// String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
			// logger.error("CalculateTransportPathService[notJoinCarModify()]:" + exps[0] + waybillNo + exps[1] + nowOrgCode + exps[2]);
			// throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB,new Object[]{waybillNo,nowOrgCode});
			PathDetailEntity maxPathDetailEntity = dealMaxRouteNoPathDetail(list, transportPathEntity, nowOrgCode);
			BeanUtils.copyProperties(maxPathDetailEntity, pathDetailEntity);
			// modify by liangfuxiang 2013-5-24下午2:55:26 end 增加日志
			// modify by liangfuxiang 2013-6-16下午9:57:13 end;
		}
		else {
			// 赋值
			BeanUtils.copyProperties(list.get(0), pathDetailEntity);
		}
		// 定义routeNo
		int routeNo = 0;
		// 查找之后的条目并且全部删除
		if (null != pathDetailEntity) {
			// 获取routeNo号
			routeNo = Integer.parseInt(pathDetailEntity.getRouteNo());
			// 查询原走货路径详细信息列表
			List<PathDetailEntity> oldPathDetailList = pathDetailDao.listQueryNextStep(pathDetailEntity);
			// 原走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
				// 批量删除
				pathDetailDao.deleteListPathDetail(oldPathDetailList);
			}
		}
		else {
			// 异常
			// 查询不到原路径
			//加入运单号，目标部门信息
			// modify by liangfuxiang 2013-7-8下午3:29:08 begin BUG-27719 南京线路调整走货路由 ----将走货路径删除，不再报错
			// logger.error("CalculateTransportPathService[notJoinCarModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDBEFOREDETAILDATA+TransportPathConstants.WAYBILL_NO+waybillNo+BLANK_SPACE_STRING+TransportPathConstants.DEST_ORGCODE+nowOrgCode);
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDBEFOREDETAILDATA, new Object[] { waybillNo, nowOrgCode });
			//先更新当前部门作为起始部门的最大路段的走货路径之前的路段状态为RELEAVE 后删除当前部门作为起始部门的最大路段的走货路径(含当前)之后的所有路段信息;
			dealCantfindBeforeDetailData(waybillNo,serialNo,nowOrgCode);
			
			// modify by liangfuxiang 2013-7-29下午1:33:05 begin BUG-45448
			// 查询最后一段走货路径
			pathDetailEntity = queryLastPathDetail(waybillNo,serialNo);
			// modify by liangfuxiang 2013-7-29下午1:33:17 end BUG-45448; 
			
			// modify by liangfuxiang 2013-7-8下午3:29:08 end BUG-27719
		}
		// 根据原货区code,改变时间,现部门 查询改变表找到修改的目标list
		Map<String, Object> map = new HashMap<String, Object>();
		
		// modify by liangfuxiang 2013-5-9下午1:36:16 begin BUG-10112
		// 当前部门
		//map.put(origOrgCode, nowOrgCode);
		map.put("origOrgCode", nowOrgCode);
		// modify by liangfuxiang 2013-5-9下午1:36:24 BUG-10112 end;
		
		// 货区编码
		map.put("origGoodsAreaCode", origGoodsAreaCode);
		// 修改时间
		map.put("executeTime", modifyTime);
		// 路径调整状态 非合车调整
		map.put("changeType", TransportPathConstants.CHANGEPATH_STATUS_MODIFY);
		// 修改的走货路径详细信息列表
		List<ChangePathEntity> changePathList = changePathDao.queryByTime(map);
		//BUG-53100  判断changePathList的大小等于0 mod by songjie
		// 判断是否为
		if (null == changePathList || changePathList.size()==0) {
			// 异常
			// 查询不到修改的路径详情
			// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志 细化异常信息
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDCHANGEDETAILDATA, "");
			logger.error("CalculateTransportPathService[notJoinCarModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDCHANGEDETAILDATA + TransportPathConstants.CURRENT_ORGCODE
					+ nowOrgCode + TransportPathConstants.BLANK_STRING_CONSTANT + TransportPathConstants.ORIGGOODSAREACODE + TransportPathConstants.BLANK_STRING_CONSTANT
					+ TransportPathConstants.ADJUST_STATUS + TransportPathConstants.CHANGEPATH_STATUS_MODIFY);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDCHANGEDETAILDATA_GLOB, new Object[] { nowOrgCode, origGoodsAreaCode,
					TransportPathConstants.CHANGEPATH_STATUS_MODIFY });
			// modify by liangfuxiang 2013-5-24上午11:32:57 end;
			
		}
		else {
			
			// modify by liangfuxiang 2013-7-29下午1:52:11 begin BUG-45448
			// 设置老路径最后一段走货路径信息
			if (null != pathDetailEntity) {
				pathDetailEntity.setObjectiveOrgCode(changePathList.get(0).getOrigOrgCode());
				pathDetailEntity.setNextDestOrgCode(changePathList.get(0).getDestOrgCode());
				pathDetailEntity.setNextArriveTime(changePathList.get(0).getPlanArriveTime());
				//加标识
				pathDetailEntity.setTruckDetailId(TransportPathConstants.NOTJOINCAR_OLD);
				pathDetailDao.updatePathDetail(pathDetailEntity);
			}
			// modify by liangfuxiang 2013-7-29下午1:52:19 end BUG-45448;
			
			
			// 根据改变条目新增后序条目
			for (int i = 0; i < changePathList.size(); i++) {
				// 新建走货路径详细信息对象
				PathDetailEntity changeEntity = new PathDetailEntity();
				// 设置ID
				changeEntity.setPathDetailId(UUIDUtils.getUUID());
				// 设置单号
				changeEntity.setWaybillNo(waybillNo);
				// 设置流水号
				changeEntity.setGoodsNo(serialNo);
				// 更新routeNo
				changeEntity.setRouteNo(String.valueOf(routeNo + Integer.parseInt(changePathList.get(i).getRouteNo())));
				// 是否修改
				changeEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置计划开始时间
				changeEntity.setPlanStartTime(changePathList.get(i).getPlanStartTime());
				// 设置计划到达时间
				changeEntity.setPlanArriveTime(changePathList.get(i).getPlanArriveTime());
				// 设置修改出发时间
				changeEntity.setModifyStartTime(changePathList.get(i).getPlanStartTime());
				// 设置修改到达时间
				changeEntity.setModifyArriveTime(changePathList.get(i).getPlanArriveTime());
				// 设置出发部门
				changeEntity.setOrigOrgCode(changePathList.get(i).getOrigOrgCode());
				// 设置到达部门
				changeEntity.setObjectiveOrgCode(changePathList.get(i).getDestOrgCode());
				// 增加
				changePathDetailList.add(changeEntity);
			}
			// 设置第一条状态为未离开
			changePathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			// 根据改变的最后地点,调用综合接口生成后序走货路径
			String changeDestOrgCode = changePathDetailList.get(changePathDetailList.size() - 1).getObjectiveOrgCode();
			// 根据改变的最后routeNo,设置routeNo
			routeNo = Integer.parseInt(changePathDetailList.get(changePathDetailList.size() - 1).getRouteNo());
			// 路径详情列表
			List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
			// 走货路径线路
			List<FreightRouteLineDto> freightRouteLineDto = null;
			try {
				// 调用基础资料接口得到路径detail 从现部门之后
				freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(changeDestOrgCode, transportPathEntity.getDestOrgCode(), transportPathEntity.getTransportModel(), new Date());
			}
			catch (Exception e) {
				// 异常
				
				// 走货路径线路为空
					// 调用基础资料接口得到路径detail 从现部门之后
			 String	model2 ="";
					try {
						// 汽运短途
						model2 = ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_ROAD_FREIGHT;
						freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(changeDestOrgCode, transportPathEntity.getDestOrgCode(), ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_ROAD_FREIGHT, new Date());
					}
					catch (Exception e2) {
						// 异常：
						try {
								// 精准城运
								model2 = ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT;
								freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(changeDestOrgCode, transportPathEntity.getDestOrgCode(),ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT, new Date());
						}
						catch (Exception e3) {
							// 异常：
							// 找不到走货路径
							logger.error("CalculateTransportPathService[alterDetailforModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
									+ origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
									+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(transportPathEntity.getDestOrgCode())
									+ TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode() + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
									+ getTransportModelNameByTransportModelCode(model2) + TransportPathConstants.LEFTBRACKET + model2 + TransportPathConstants.RIGHTBRACKET });
						}
						// 找不到走货路径
						logger.error("CalculateTransportPathService[alterDetailforModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
								+ origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
								+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(transportPathEntity.getDestOrgCode())
								+ TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode() + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
								+ getTransportModelNameByTransportModelCode(model2) + TransportPathConstants.LEFTBRACKET + model2 + TransportPathConstants.RIGHTBRACKET });
					}
				
				// 无走货路径
				// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志
				logger.error("CalculateTransportPathService[notJoinCarModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
						+ origOrgCode + ": " + changeDestOrgCode + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());
				// modify by liangfuxiang 2013-5-24上午11:32:57 end;
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME
						+ getNameByCode(changeDestOrgCode) + TransportPathConstants.LEFTBRACKET + changeDestOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA
						+ getNameByCode(transportPathEntity.getDestOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode() + TransportPathConstants.RIGHTBRACKET
						+ TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME + getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel())
						+ TransportPathConstants.LEFTBRACKET + transportPathEntity.getTransportModel() + TransportPathConstants.RIGHTBRACKET });
			}
			// 走货路径线路为空
			if (CollectionUtils.isEmpty(freightRouteLineDto)) {
				// 异常
				// 无走货路径
				// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志
				logger.error("CalculateTransportPathService[notJoinCarModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
						+ origOrgCode + ": " + changeDestOrgCode + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());
				// modify by liangfuxiang 2013-5-24上午11:32:57 end;
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME
						+ getNameByCode(changeDestOrgCode) + TransportPathConstants.LEFTBRACKET + changeDestOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA
						+ getNameByCode(transportPathEntity.getDestOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode() + TransportPathConstants.RIGHTBRACKET
						+ TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME + getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel())
						+ TransportPathConstants.LEFTBRACKET + transportPathEntity.getTransportModel() + TransportPathConstants.RIGHTBRACKET });
			}
			else {
				// 赋值
				for (int i = 0; i < freightRouteLineDto.size(); i++) {
					// 新建
					newPathDetailList.add(new PathDetailEntity());
					// 设置出发部门
					if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
						// 异常
						// 无出发部门
						// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志
						logger.error("CalculateTransportPathService[notJoinCarModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24上午11:32:57 end;
						// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(changeDestOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
					}
					// 设置出发部门
					newPathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
					// 设置到达部门
					if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
						// 异常:
						// 无到达部门
						// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志
						logger.error("CalculateTransportPathService[notJoinCarModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-5-24上午11:32:57 end;
						// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
								TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(changeDestOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
					}
					// 设置到达部门
					newPathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
					// 设置下一到达部门
					if ((i + 1) < freightRouteLineDto.size()) {
						// 设置下一到达部门
						newPathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
						// 设置下一到达部门时间
						newPathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
					}
					// 设置开单部门
					newPathDetailList.get(i).setBillingOrgCode(transportPathEntity.getBillingOrgCode());
					// 重新确定ourteNo
					newPathDetailList.get(i).setRouteNo(String.valueOf(routeNo + i + 1));
					// 设置计划出发时间
					if (null == freightRouteLineDto.get(i).getLeaveDate()) {
						// //综合管理-线路-始发线路
						// 综合管理-线路-到达线路
						// 综合管理-线路-中转到中转线路-专线
						if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
								|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
								|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
										.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
							// 异常:
							// 无出发时间
							// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志
							logger.error("CalculateTransportPathService[notJoinCarModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+queryFreightRouteBySourceTarget);
							// modify by liangfuxiang 2013-5-24上午11:32:57 end;
							// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
						}
						else {
							// 到达时间非空
							if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
								// 设置到达时间
								freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
							}
							else {
								// 设置到达时间
								freightRouteLineDto.get(i).setLeaveDate(new Date());
							}
						}
					}
					// 设置计划到达时间
					newPathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
					// 设置计划到达时间
					if (null == freightRouteLineDto.get(i).getArriveDate()) {
						// 综合管理-线路-始发线路
						// 综合管理-线路-到达线路
						// 综合管理-线路-中转到中转线路-专线
						if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
								|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
								|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
										.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
							// 异常:
							// 无到达时间
							// modify by liangfuxiang 2013-5-24上午11:32:31 begin 增加日志
							logger.error("CalculateTransportPathService[notJoinCarModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+queryFreightRouteBySourceTarget);
							// modify by liangfuxiang 2013-5-24上午11:32:57 end;
							// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
						}
						else {
							// 上一到达时间
							long beforeArrive = (new Date()).getTime();
							// 到达时间非空
							if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
								// 到达时间
								beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
							}
							// 分
							long min = freightRouteLineDto.get(i).getAging();
							// 到达时间
							Date arrive = new Date(sixtyThousand * min + beforeArrive);
							// 到达时间
							freightRouteLineDto.get(i).setArriveDate(arrive);
						}
					}
					// 设置计划到达时间
					newPathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
					// 设置调整出发时间
					newPathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
					// 设置调整到达时间
					newPathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
					// 设置是否调整时间
					newPathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
					// 更新状态
					newPathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
					// 设置其他基本信息
					newPathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
					// 设置单号
					newPathDetailList.get(i).setWaybillNo(waybillNo);
					// 设置流水号
					newPathDetailList.get(i).setGoodsNo(serialNo);
				}
				
				// modify by liangfuxiang 2013-7-29下午1:19:33 begin BUG-45448
				// 将changePathDetailList最后一条的nextOrgCode变成新生成走货路径第一条的目标部门
				// 修改到达时间
				if (changePathDetailList.size() > 0 && newPathDetailList.size() > 0) {
					changePathDetailList.get(changePathDetailList.size() - 1).setNextDestOrgCode(newPathDetailList.get(0).getObjectiveOrgCode());
					changePathDetailList.get(changePathDetailList.size() - 1).setNextArriveTime(newPathDetailList.get(0).getPlanArriveTime());
					// 加标识
					changePathDetailList.get(changePathDetailList.size() - 1).setTruckDetailId(TransportPathConstants.NOTJOINCAR_NEW);
				}
				// modify by liangfuxiang 2013-7-29下午1:19:57 end BUG-45448;
				
				// 拼接新路径至最后
				changePathDetailList.addAll(newPathDetailList);
				// 新路径非空
				if (changePathDetailList.size() > 0) {
					// 保存路径明细
					pathDetailDao.addListPathDetail(changePathDetailList);
				}
				
				//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
				// 分批配载更新path
				//transportPathEntity.setTransportPath(getChangedPath(transportPathEntity.getWaybillNo()));
				// 更新主表
				transportationPathDao.updateTransportPath(transportPathEntity);
			}
		}
	}

	/** 
	* @Title: queryLastPathDetail 
	* @Description: 查询最后一段走货路径
	* @param waybillNo
	* @param serialNo
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see queryLastPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-29 下午1:43:27   
	* @throws 
	*/ 
	private PathDetailEntity queryLastPathDetail(String waybillNo, String serialNo) {
		PathDetailEntity tempPathDetailEntity = new PathDetailEntity();
		tempPathDetailEntity.setWaybillNo(waybillNo);
		tempPathDetailEntity.setGoodsNo(serialNo);
		return queryLastPathDetailEntity(tempPathDetailEntity);
	}

	/** 
	* @Title: dealCantfindBeforeDetailData 
	* @Description: 先更新当前部门作为起始部门的最大路段的走货路径之前的路段状态为RELEAVE
	* 后删除当前部门作为起始部门的最大路段的走货路径(含当前)之后的所有路段信息;
	* 
	* @param waybillNo
	* @param serialNo
	* @param nowOrgCode  设定文件 
	* @return void    返回类型 
	* @see dealCantfindBeforeDetailData
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-8 下午3:40:02   
	* @throws 
	*/ 
	private void dealCantfindBeforeDetailData(String waybillNo, String serialNo, String nowOrgCode) {
		PathDetailEntity pde=new PathDetailEntity();
		pde.setWaybillNo(waybillNo);
		pde.setGoodsNo(serialNo);
		pde.setOrigOrgCode(nowOrgCode);
		pde.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
		// 先更新当前部门作为起始部门的最大路段的走货路径之前的路段状态为RELEAVE
	    pathDetailDao.updateBeforePathDetailEntityWithOrigOrgCode(pde);
		// 后删除当前部门作为起始部门的最大路段的走货路径(含当前)之后的所有路段信息
		pathDetailDao.deleteBehindPathDetailEntityWithOrigOrgCode(pde);
		
	}

	/** 
	* @Title: varifyInputParameters 
	* @Description:非合车调整走货路径 对输入的参数进行有效性判断
	* @param waybillNo
	* @param origGoodsAreaCode
	* @param modifyTime
	* @param nowOrgCode  设定文件 
	* @return void    返回类型 
	* @see varifyInputParameters
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-9 下午1:53:25   
	* @throws 
	*/ 
	private void varifyInputParameters(String waybillNo, String origGoodsAreaCode, Date modifyTime, String nowOrgCode) {
		//运单号为空，抛出异常
		if(StringUtils.isEmpty(waybillNo)){
			logger.error("CalculateTransportPathService[varifyInputParameters()]:"+TransportPathConstants.NOTJOINCARMODIFY_WAYBILLNO_NULL);
			throw new TfrBusinessException(TransportPathConstants.NOTJOINCARMODIFY_WAYBILLNO_NULL_GLOB);
		}
		//库区为空，抛出异常
		if(StringUtils.isEmpty(origGoodsAreaCode)){
			logger.error("CalculateTransportPathService[varifyInputParameters()]:" + TransportPathConstants.NOTJOINCARMODIFY_ORIGGOODSAREACODE_NULL + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.NOTJOINCARMODIFY_ORIGGOODSAREACODE_NULL_GLOB, new Object[] { waybillNo });
		}
		//修改时间为空，抛出异常
		if(null==modifyTime){
			logger.error("CalculateTransportPathService[varifyInputParameters()]:"+TransportPathConstants.NOTJOINCARMODIFY_MODIFYTIME_NULL);
			throw new TfrBusinessException(TransportPathConstants.NOTJOINCARMODIFY_MODIFYTIME_NULL_GLOB);
		}
		//当前部门为空，抛出异常
		if(StringUtils.isEmpty(nowOrgCode)){
			logger.error("CalculateTransportPathService[varifyInputParameters()]:"+TransportPathConstants.NOTJOINCARMODIFY_NOWORGCODE_NULL);
			throw new TfrBusinessException(TransportPathConstants.NOTJOINCARMODIFY_NOWORGCODE_NULL_GLOB);
		}
	}

	/**
	 * 拆分走货路径明细条目,用于各种类型的分批配载
	 * 
	 * @author huyue
	 * @date 2012-10-26 上午10:44:13
	 */
	public void seperatePathDetail(String waybillNo) throws TfrBusinessException {
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 设置单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 查询走货路径详细信息
		List<PathDetailEntity> originalList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		// 走货路径详细信息非空
		if (originalList.size() > 0) {
			// 查询全部货件号
			List<String> listGoodsNo = pathDetailDao.listQueryGoodsNo(waybillNo);
			// 流水号为空
			if (listGoodsNo.size() == 0) {
				// 异常:
				// 无流水号
				// modify by liangfuxiang 2013-5-29下午8:54:55 begin 加入日志
				logger.error("CalculateTransportPathService[seperatePathDetail()]:" + TransportPathConstants.TRANSPORTPATH_RECREATE_CANTFINDSERIALNOBYWAYBILLNO + waybillNo);
				// modify by liangfuxiang 2013-5-29下午8:55:18 end;
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_RECREATE_CANTFINDSERIALNOBYWAYBILLNO, new Object[] { waybillNo });
			}
			// 将原来的条目赋值并更新
			for (int i = 0; i < originalList.size(); i++) {
				//如果流水号不为空时 执行如下操作,故添加此判断 modify by songjie
				if(StringUtils.isBlank(originalList.get(i).getGoodsNo())){
					// 设置流水号
					originalList.get(i).setGoodsNo(listGoodsNo.get(0));
					// 更新走货路径详细信息
					pathDetailDao.updateListPathDetail(originalList);
				}
				
			}
			// 创建新条目

			// modify by liangfuxiang 2013-3-26下午3:43:07 begin BUG-6019 点击修改按钮，进入修改页面，把某运单的其中一个流水号删掉，报唯一键重复异常
			// 新建走货路径详细信息
			// List<PathDetailEntity> newList = new ArrayList<PathDetailEntity>(listGoodsNo.size() - 1);
			// 遍历流水号
			// for (int i = 0; i < (listGoodsNo.size() - 1); i++) {
			List<PathDetailEntity> newList = null;
			for (int i = 0; i < (listGoodsNo.size() - 1); i++) {
				newList = new ArrayList<PathDetailEntity>();
				// modify by liangfuxiang 2013-3-26下午3:43:50 end;
				for (int j = 0; j < originalList.size(); j++) {
					// 走货路径详细信息
					PathDetailEntity newEntity = new PathDetailEntity();
					// 赋值
					BeanUtils.copyProperties(originalList.get(j), newEntity);
					// 设置ID
					newEntity.setPathDetailId(UUIDUtils.getUUID());
					// 设置流水号
					newEntity.setGoodsNo(listGoodsNo.get(i + 1));
					// 添加
					newList.add(newEntity);
				}
				// 走货路径详细信息非空
				if (newList.size() > 0) {
					// 添加
					pathDetailDao.addListPathDetail(newList);
				}
			}
		}
		else {
			// 异常:
			// 无走货路径信息
			// modify by liangfuxiang 2013-5-24上午11:12:35 begin 增加日志，细化异常信息
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[seperatePathDetail()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午11:12:58 end;
		}
	}

	/**
	 * 获取分批配载后的主表path 拼接
	 * @author huyue
	 * @date 2012-11-7 下午6:58:27
	 */
	public String getChangedPath(String waybillNo) {
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 设置单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 根据运单号找到走货路径list
		List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		// 新建集合
		Set<String> set = new HashSet<String>();
		// 路径信息
		StringBuffer pathByGoods = new StringBuffer();
		
		//modify by liangfuxiang 2013-6-5上午1:38:21 begin BUG-24241 迁移数据无法重新计算走货路径!
		//将返回的走货路径，按照路段号排序：如分批配载，则按照流水号，获取分别不同的起始路段号（迁移数据和开单生成的走货路径不同）。否则，获取第一个路段号。
		//设置第一个路段号为0---只是初始值，若pathDetailList非空，会赋新值
		String firstRoutNo=TransportPathConstants.CONSTANT_ZERO;
		//保存流水号的set---去重复
		Map<String,String> goodsNoMap=null;
		//pathDetailList  已经按照运单，流水号，路段排序
		if(!CollectionUtils.isEmpty(pathDetailList)){
			//说明非分批配载
			if(!StringUtils.isEmpty(StringUtils.trim(pathDetailList.get(0).getGoodsNo()))){
				goodsNoMap=new HashMap<String,String>();
				//遍历，保存唯一 流水号对应的第一个路段
				for(int k=0;k<pathDetailList.size();k++){
					//路段好
					String routeNo=StringUtils.trim(pathDetailList.get(k).getRouteNo());
					//路段号为空，抛出异常!
					if(StringUtils.isEmpty(routeNo)){
						logger.error("CalculateTransportPathService[getChangedPath()]" + TransportPathConstants.PATH_DETAIL_ROUTE_NO_IS_NULL + waybillNo);
						throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_ROUTE_NO_IS_NULL_GLOB, new Object[] { waybillNo });
					}
					String goodsNo=StringUtils.trim(pathDetailList.get(k).getGoodsNo());
					if(StringUtils.isEmpty(pathDetailList.get(k).getGoodsNo())){
						logger.error("CalculateTransportPathService[getChangedPath()]" + TransportPathConstants.PATH_DETAIL_GOODSNO_IS_NULL + waybillNo);
						throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_GOOODSNO_IS_NULL_GLOB, new Object[] { waybillNo });
					}
					//第一条数据
					if(goodsNoMap.size()==0){
						//将第一个流水号。。对应的最小的路段号加入到map中。
						goodsNoMap.put(goodsNo, routeNo);
					}
					else{
						//说明GOODSNO还未保存至MAP中，保存唯一的流水号和最小的路段号
						if(StringUtils.isEmpty(goodsNoMap.get(routeNo))){
							goodsNoMap.put(goodsNo, routeNo);
						}
					}
				}
			}
			//非分批配载
			else{
				//若路段号为空
				if(StringUtils.isEmpty(StringUtils.trim(pathDetailList.get(0).getRouteNo()))){
					logger.error("CalculateTransportPathService[getChangedPath()]" + TransportPathConstants.PATH_DETAIL_ROUTE_NO_IS_NULL + waybillNo);
					throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_ROUTE_NO_IS_NULL_GLOB, new Object[] { waybillNo });
				}
				else{
					//第一路段
					firstRoutNo=pathDetailList.get(0).getRouteNo();
				}
			}
		}
		//modify by liangfuxiang 2013-6-5上午1:38:21 end BUG-24241
		
		// 遍历走货路径详细信息
		for (int i = 0; i < pathDetailList.size(); i++) {
			
			// modify by liangfuxiang 2013-6-5上午1:38:21 begin BUG-24241 迁移数据无法重新计算走货路径!
			// 原因。。迁移数据，第一个路段号为"0",而foss中，默认的开始路段号为“1” 故如下直接判断第一个路段为“1”的代码就有问题
			// 判断如果是第一段
			// if (StringUtils.isNotEmpty(pathDetailList.get(i).getRouteNo()) && pathDetailList.get(i).getRouteNo().equals("1")) {

			// 分批配载，获取每个流水号对应的最小路段号
			if (null != goodsNoMap && goodsNoMap.size() > 0) {
				firstRoutNo = goodsNoMap.get(StringUtils.trim(pathDetailList.get(i).getGoodsNo()));
			}

			if (StringUtils.isNotEmpty(pathDetailList.get(i).getRouteNo()) && pathDetailList.get(i).getRouteNo().equals(firstRoutNo)) {
			// modify by liangfuxiang 2013-6-5上午1:41:04 end;
				// 走货路径非空
				if (StringUtils.isNotEmpty(pathByGoods.toString())) {
					// 把上一条保存路径保存至set集合中
					set.add(pathByGoods.toString());
					// 清空保存的内容
					pathByGoods.delete(0, pathByGoods.length() - 1);
				}
				// 添加起始部门
				pathByGoods.append(getNameByCode(pathDetailList.get(i).getOrigOrgCode()));
			}
			// 拼接
			pathByGoods.append("-");
			// 拼接路径
			pathByGoods.append(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
		}
		// modify by liangfuxiang 2013-6-5上午1:43:15 end;
		
		
		// modify by liangfuxiang 2013-5-28下午7:19:34 begin 防止极端情况：分批配载只有一条货物，也分批--清仓多货会发生类似的情况
		if (!StringUtils.isEmpty(pathByGoods.toString()) && set.size() == 0) {
			set.add(pathByGoods.toString());
		}
		// modify by liangfuxiang 2013-5-28下午7:20:29 end;
		
		// 设置起始地
		StringBuffer path = new StringBuffer();
		
		// 如果set不为空.则拼接goodsPath
		if (set.size() > 0) {
			// 转化为数组
			Object goodsPath[] = set.toArray();
			// 取第一段
			path.append(goodsPath[0]);
			// 拼接其他段
			for (int i = 1; i < set.size(); i++) {
				// 拼接
				path.append("/");
				// 拼接走货路径
				path.append(goodsPath[i]);
			}
		}
		else {
			// 走货路径为空
			path.append(TransportPathConstants.SET_NULL_STRING);
		}
		// 返回走货路径
		return path.toString();
	}

	/**
	 * 查询运单中货件号,以剩余线路段数排序
	 * 
	 * 
	 * @author huyue
	 * @date 2012-11-26 上午10:32:45
	 */
	public List<String> listFastGoodsNo(String waybillNo) throws TfrBusinessException {
		// 走货路径详细信息
		PathDetailEntity pathDetail = new PathDetailEntity();

		// modify by liangfuxiang 2013-6-8上午12:44:30 begin
		waybillNo = StringUtils.trim(waybillNo);
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[listFastGoodsNo()]" + TransportPathConstants.WAYBILL_NO_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_NULL_GLOB);
		}
		// modify by liangfuxiang 2013-6-8上午12:44:40 end;

		// 设置单号
		pathDetail.setWaybillNo(waybillNo);
		// 路径明细状态 未离开
		pathDetail.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		// 获取流水号
		List<String> goodsNo = pathDetailDao.listFastGoodsNo(pathDetail);
		// 流水号非空
		if (CollectionUtils.isEmpty(goodsNo) || goodsNo.size() == 0) {

			// 路径明细状态 再离开
			pathDetail.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			// 设置货件号
			goodsNo = pathDetailDao.listFastGoodsNoByReleave(pathDetail);

			// modify by liangfuxiang 2013-6-13下午4:34:49 begin BUG-30644 根据此单要求，注释掉如下代码
			
			// // modify by liangfuxiang 2013-6-8上午12:44:30 begin SUBBUG-940
			// if (CollectionUtils.isEmpty(goodsNo) || goodsNo.size() == 0) {
			//
			// // 若未查询到，则从走货路径明细信息备份表中查询
			// goodsNo = pathDetailDao.listFastGoodsNoFromMigration(pathDetail);
			// pathDetail.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			//
			// if (CollectionUtils.isEmpty(goodsNo) || goodsNo.size() == 0) {
			// // 路径明细状态 再离开
			// pathDetail.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			// // 从走货路径明细信息备份表中查询
			// goodsNo = pathDetailDao.listFastGoodsNoByReleaveFromMigration(pathDetail);
			// }
			// }
			// // modify by liangfuxiang 2013-6-8上午12:44:40 end;
			// modify by liangfuxiang 2013-6-13下午4:34:55 end;
		}
		// 返回货件号
		return goodsNo;
	}

	/**
	 * 找到有效的第一条返回 可以找到上一部门
	 * 
	 * @author huyue
	 * @date 2012-12-4 下午2:26:17
	 */
	public PathDetailEntity findBeforeOrgCode(String waybillNo, String serialNo) throws TfrBusinessException {
		// 首先判断是否分批
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 判断是否存在条目
		if (null != transportPathEntity) {
			// 如果不是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.NOTPARTIALSTOWAGE)) {
				// 查询有效的全部
				return queryEffect(waybillNo, null);
			}
			else {
				// 返回查询有效的全部
				return queryEffect(waybillNo, serialNo);
			}
		}
		else {
			// 异常:
			// 无走货路径信息
			// modify by liangfuxiang 2013-5-24上午11:12:35 begin 增加日志，细化异常信息
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[findBeforeOrgCode()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午11:12:58 end;
		}
	}

	/**
	 * 查询有效的全部list
	 * 
	 * @author huyue
	 * @date 2012-11-26 上午11:22:44
	 */
	public PathDetailEntity queryEffect(String waybillNo, String serialNo) throws TfrBusinessException {
		// 走货路径详细信息
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 设置单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 流水号非空
		if (null != serialNo) {
			// 设置流水号
			pathDetailEntity.setGoodsNo(serialNo);
		}
		// 状态为在离开表示已经无效.本查询意义是找到第一条有效的.进行修改
		pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
		
		// modify by liangfuxiang 2013-6-25上午9:11:09 begin 
		// 修改为查找最新的状态为releave的(路段号为最大的),此路段下一条即为要返回的有效的走货路段。
		// 查找到最大的releave状态的走货路径后，将其比自己小的路段，非releave状态的，全部置为releave状态。
		PathDetailEntity maxReleavePathDetailEntity = getMaxReleavePathDetailEntity(pathDetailEntity);

		//没有已离开的状态
		if(null==maxReleavePathDetailEntity){
			// 查询走货路径详细信息
			List<PathDetailEntity> pathDetailList = pathDetailDao.queryWrong(pathDetailEntity);
			// 走货路径详细信息列表非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 返回走货路径详细信息
				return pathDetailList.get(0);
			}
			else {
				// 返回空
				return null;
			}
		}
		else{
			//将把比此已经离开状态的路段小的路段信息--非releave状态，全部置为已离开状态
			// modify by liangfuxiang 2013-7-4上午11:07:16 begin BUG-40029 带来事务问题 故注释掉
			//releaveBeforePathDetails(maxReleavePathDetailEntity);
			// modify by liangfuxiang 2013-7-4上午11:07:20 end;
			//将此已经离开状态的路段大“1”的路段信息返回---存在未找到,为null的情况。
			return getNextPathDetail(maxReleavePathDetailEntity);
		}
		// modify by liangfuxiang 2013-6-25上午9:16:46 end;
	}

	/** 
	* @Title: getNextPathDetail 
	* @Description: 将此已经离开状态的路段大“1”的路段信息返回---存在未找到,为null的情况。
	* @param maxReleavePathDetailEntity
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see nextPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-25 上午11:20:39   
	* @throws 
	*/ 
	private PathDetailEntity getNextPathDetail(PathDetailEntity maxReleavePathDetailEntity) {
		
		//获取路段号
		int maxRouteNo = getIntRoutNo(maxReleavePathDetailEntity.getRouteNo(), maxReleavePathDetailEntity.getWaybillNo());

		PathDetailEntity nextPathDetailEntity =  new PathDetailEntity();
		//设置下路段的路段号
		nextPathDetailEntity.setRouteNo(String.valueOf(maxRouteNo+1));
		//运单号
		nextPathDetailEntity.setWaybillNo(maxReleavePathDetailEntity.getWaybillNo());
		//流水号
		nextPathDetailEntity.setGoodsNo(maxReleavePathDetailEntity.getGoodsNo());
		//下一路段
		List<PathDetailEntity> nextPathDetailList= pathDetailDao.queryPathDetailList(nextPathDetailEntity);
		
		//未查询到
		if(CollectionUtils.isEmpty(nextPathDetailList)){
			return null;
		}
		//重复
		else if(nextPathDetailList.size()>1){
			logger.error("CalculateTransportPathService[getNextPathDetail()]:"+TransportPathConstants.PATH_DETAIL_REPEAT+maxReleavePathDetailEntity.getWaybillNo());
			throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_REPEAT_GLOB,new Object[]{maxReleavePathDetailEntity.getWaybillNo()});
		}
		else{
			return nextPathDetailList.get(0);
		}
	}

	/** 
	* @Title: releaveBeforePathDetails 
	* @Description:将之前的路段信息置为已离开状态
	* @param maxReleavePathDetailEntity  设定文件 
	* @return void    返回类型 
	* @see releaveBeforePathDetails
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-25 上午9:55:31   
	* @throws 
	*/ 
	private void releaveBeforePathDetails(PathDetailEntity maxReleavePathDetailEntity) {
		pathDetailDao.updateBeforePathDetailList(maxReleavePathDetailEntity);
	}

	/** 
	* @Title: getMaxReleavePathDetailEntity 
	* @Description: 获取最大路段的已经离开状态的走货路径信息
	* @param pathDetailEntity
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see getMaxReleavePathDetailEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-25 上午9:23:09   
	* @throws 
	*/ 
	private PathDetailEntity getMaxReleavePathDetailEntity(PathDetailEntity pathDetailEntity) {
		
		//查询已离开状态，最大路段信息
		List<PathDetailEntity> maxReleavePathDetailEntityList=pathDetailDao.queryMaxReleavePathDetailEntityList(pathDetailEntity);
		
		//未查询到已经离开状态的走货路径
		if(CollectionUtils.isEmpty(maxReleavePathDetailEntityList)){
			return null;
		}
		else{
			//走货路径重复
			if(maxReleavePathDetailEntityList.size()>1){
				logger.error("CalculateTransportPathService[getMaxReleavePathDetailEntity()]:"+TransportPathConstants.PATH_DETAIL_REPEAT+pathDetailEntity.getWaybillNo());
				throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_REPEAT_GLOB,new Object[]{pathDetailEntity.getWaybillNo()});
			}
			else{
				//返回唯一值
				return maxReleavePathDetailEntityList.get(0);
			}
		}
	}

	/**
	 * 根据运单号,流水号,到达部门查询出发部门CODE
	 * --------------------------------------------------此接口有问题，根据waybillNo,serialNo,arriveOrgCode 并不能确认路段信息的唯一性
	 * --------------------------------------------------故，查询到的出发部门可能有多个
	 * --------------------------------------------------目前未找到该公共接口被使用的地方，所以建议作废掉或不在使用此接口!
	 * --------------------------------------------------liangfuxiang 2013-07-18
	 * @author huyue
	 * @date 2013-2-27 下午4:48:43
	 */
	public String queryBeforeOrgCode(String waybillNo, String serialNo, String arriveOrgCode) throws TfrBusinessException {
		// 首先判断是否分批
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 判断是否存在条目
		if (null != transportPathEntity) {
			// 走货路径详细信息
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 如果是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 设置流水号
				pathDetailEntity.setGoodsNo(serialNo);
			}
			// 设置目标部门编码
			pathDetailEntity.setObjectiveOrgCode(arriveOrgCode);
			// 查询走货路径详细信息
			List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
			// 走货路径详细信息唯一
			if (pathDetailList.size() == 1) {
				// 返回目标部门编码
				return pathDetailList.get(0).getOrigOrgCode();
			}
			// modify by liangfuxiang 2013-5-24上午11:28:14 begin 添加日志，修改错误的异常---存在查不到的情况
			// else {
			// // 路径明细数据不唯一
			// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE, "");
			// }
			// 查询到多条
			else if (pathDetailList.size() > 1) {
				String[] exps = TransportPathConstants.PATHDETAIL_MORE_THAN_ONE.split(":");
				logger.error("CalculateTransportPathService[queryBeforeOrgCode()]:" + exps[0] + waybillNo + exps[1] + arriveOrgCode + exps[2]);
				throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_MORE_THAN_ONE_GLOB, new Object[] { waybillNo, arriveOrgCode });
			}
			// 未查询到
			else {
				String[] exps = TransportPathConstants.PATHDETAIL_IS_NULL.split(":");
				logger.error("CalculateTransportPathService[queryBeforeOrgCode()]:" + exps[0] + waybillNo + exps[1] + arriveOrgCode + exps[2]);
				throw new TfrBusinessException(TransportPathConstants.PATHDETAIL_IS_NULL_DES_GLOB, new Object[] { waybillNo, arriveOrgCode });
			}
			// modify by liangfuxiang 2013-5-24上午11:28:37 end;
		}
		else {
			// 抛出异常
			// modify by liangfuxiang 2013-5-24上午11:12:35 begin 增加日志，细化异常信息
			//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, "");
			logger.error("CalculateTransportPathService[queryBeforeOrgCode()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			// modify by liangfuxiang 2013-5-24上午11:12:58 end;
		}
	}

	/**
	 * 查询货物全部路径
	 * 
	 * 
	 * @author huyue
	 * @date 2012-12-6 下午4:12:20
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#queryTotalPath(java.lang.String, java.lang.String)
	 */
	public List<PathDetailEntity> queryTotalPath(String waybillNo, String serialNo) throws TfrBusinessException {
		
		// modify by liangfuxiang 2013-5-20上午11:12:41 begin BUG-10466 验证单号非空
		if(StringUtils.isEmpty(waybillNo)){
			logger.error("CalculateTransportPathService[queryTotalPath()]:"+TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		// modify by liangfuxiang 2013-5-20上午11:12:48 end;
		
		// 首先判断是否分批
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		
		// modify by liangfuxiang 2013-5-20上午11:12:41 begin BUG-10466 如果获取失败，读取走货路径备份表，获取中转走货路径
		// if (null == transportPathEntity) {
		// transportPathEntity = queryTransportPathFromMigration(waybillNo);
		// }
		// modify by liangfuxiang 2013-5-20上午11:12:48 end;

		// 判断是否存在条目
		if (null != transportPathEntity) {
			// 走货路径详细信息
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 如果是分批
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				
				// modify by liangfuxiang 2013-5-20下午1:55:28 begin BUG-10466  分批配载，要求流水号非空
				if(StringUtils.isEmpty(serialNo)){
					logger.error("CalculateTransportPathService[queryTotalPath()]:"+TransportPathConstants.SERIALNO_IS_NULL);
					throw new TfrBusinessException(TransportPathConstants.SERIALNO_IS_NULL_GLOB);
				}
				// modify by liangfuxiang 2013-5-20下午1:56:17 end;
				
				// 设置流水号
				pathDetailEntity.setGoodsNo(serialNo);
			}
			// 查询走货路径详细信息
			List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
			
			// modify by liangfuxiang 2013-5-20上午11:12:41 begin BUG-10466 如果获取失败，读取走货路径备份表，获取中转走货路径
			// if (CollectionUtils.isEmpty(pathDetailList)) {
			// pathDetailList = queryPathDetailFromMigration(pathDetailEntity);
			// }
			// modify by liangfuxiang 2013-5-20上午11:22:47 end;
			
			// 走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 返回走货路径详细信息
				return pathDetailList;
			}
			else {
				// 抛出异常
				// 无走货路径
				// modify by liangfuxiang 2013-5-23下午4:26:48 begin 添加日志
				//throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA, "");
				String expInfo=TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA;
				if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
					expInfo+=BLANK_SPACE_STRING+TransportPathConstants.SERIAL_NO+serialNo;
				}
				logger.error("CalculateTransportPathService[queryTotalPath()]:"+expInfo);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDETAILDATA_ONLY_SER, new Object[] { waybillNo, serialNo });
				// modify by liangfuxiang 2013-5-23下午4:27:03 end;
			}
		}
		else {
			// 抛出异常
			// 无走货路径
			// modify by liangfuxiang 2013-5-23下午4:26:48 begin 添加日志
			logger.error("CalculateTransportPathService[queryTotalPath()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA+TransportPathConstants.WAYBILL_NO+waybillNo);
			// modify by liangfuxiang 2013-5-23下午4:27:03 end;
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
		}
	}

	/**
	 * 
	* @Title: queryTotalPathForPrintLabel 
	* @Description: 打印标签查找走货路径接口
	* @param waybillNo
	* @param serialNo
	* @return
	* @throws TfrBusinessException  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see queryTotalPathForPrintLabel
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-20 上午11:37:38   
	* @throws
	 */
	public List<PathDetailEntity> queryTotalPathForPrintLabel(String waybillNo, String serialNo) throws TfrBusinessException {

		List<PathDetailEntity> pathDetailEntityList = null;

		try {
			// 从中转查询走货路径
			pathDetailEntityList = queryTotalPath(waybillNo, serialNo);
		}
		// 从中转未查询到走货路径信息，捕获异常
		catch (TfrBusinessException e) {
			// 获取运单信息
			WaybillEntity waybillEntity = queryWaybillEntityInfo(waybillNo);
			// 从综合查询走货路径信息
			pathDetailEntityList = pathDetailEntityListFromFreightRoute(waybillEntity, serialNo);
		}

		return pathDetailEntityList;
	}
	
	/** 
	* @Title: pathDetailEntityListFromFreightRoute 
	* @Description: 从综合查询走货路径信息
	* @param waybillEntity
	* @param serialNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see pathDetailEntityListFromFreightRoute
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-20 下午1:07:42   
	* @throws 
	*/ 
	private List<PathDetailEntity> pathDetailEntityListFromFreightRoute(WaybillEntity waybillEntity, String serialNo) {
		//从基础数据获取路线信息
		List<FreightRouteLineDto> freightRouteLineDtoList=getFreightRouteLineDtoList(waybillEntity);
		//获取走货路径详细信息
		List<PathDetailEntity> pathDetailEntityList=getPathDetailEntityList(freightRouteLineDtoList,waybillEntity,serialNo);
		
		return pathDetailEntityList;
	}

	/**
	 * @param waybillEntity  
	* @Title: getpathDetailEntityList 
	* @Description: 获取走货路径详细信息
	* @param freightRouteLineDtoList
	* @param serialNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see getpathDetailEntityList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-20 下午1:48:15   
	* @throws 
	*/ 
	private List<PathDetailEntity> getPathDetailEntityList(List<FreightRouteLineDto> freightRouteLineDtoList, WaybillEntity waybillEntity, String serialNo) {

		PathDetailEntity pathDetailEntity = null;

		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();

		for (int i = 0; i < freightRouteLineDtoList.size(); i++) {
			// 走货路径详情
			pathDetailEntity = new PathDetailEntity();

			// 设置出发部门
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getSourceCode())) {
				logger.error("CalculateTransportPathService[getPathDetailEntityList()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+queryFreightRouteBySourceTarget);
				// 抛出异常
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, freightRouteLineDtoList });
			}
			// 设置出发部门编码
			pathDetailEntity.setOrigOrgCode(freightRouteLineDtoList.get(i).getSourceCode());
			// 设置到达部门
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getTargetCode())) {
				logger.error("CalculateTransportPathService[getPathDetailEntityList()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+queryFreightRouteBySourceTarget);
				// 抛出异常
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget, freightRouteLineDtoList });
			}
			// 设置目标部门编码
			pathDetailEntity.setObjectiveOrgCode(freightRouteLineDtoList.get(i).getTargetCode());
			// 设置下一到达部门&时间
			if ((i + 1) < freightRouteLineDtoList.size()) {
				// 设置目标部门编码
				pathDetailEntity.setNextDestOrgCode(freightRouteLineDtoList.get(i + 1).getTargetCode());
				// 设置到达时间
				pathDetailEntity.setNextArriveTime(freightRouteLineDtoList.get(i + 1).getArriveDate());
			}
			// 设置开单部门
			//pathDetailEntity.setBillingOrgCode(waybillEntity.getCreateOrgCode());
			//forrest
			pathDetailEntity.setBillingOrgCode(waybillEntity.getReceiveOrgCode());
			// 设置线路段号
			pathDetailEntity.setRouteNo(String.valueOf(i + 1));

			// 设置计划出发时间,如果为空，且非汽运偏线\精准空运\整车则抛出异常
			String lineSort = freightRouteLineDtoList.get(i).getLineSort();
			// 离开时间为空
			if (null == freightRouteLineDtoList.get(i).getLeaveDate()) {
				if (StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i).getLineType(),
								DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 找不到离开时间
					// 抛出异常
					logger.error("CalculateTransportPathService[getPathDetailEntityList()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 非空
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 设置离开时间
						freightRouteLineDtoList.get(i).setLeaveDate(freightRouteLineDtoList.get(i - 1).getArriveDate());
					}
					else {
						// 设置离开时间
						freightRouteLineDtoList.get(i).setLeaveDate(new Date());
					}
				}
			}
			// 设置计划出发时间
			pathDetailEntity.setPlanStartTime(freightRouteLineDtoList.get(i).getLeaveDate());

			// 设置计划到达时间,如果为空，且非汽运偏线\精准空运\整车则抛出异常
			if (null == freightRouteLineDtoList.get(i).getArriveDate()) {
				// 综合管理-线路-始发线路
				if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
								.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 抛出异常
					logger.error("CalculateTransportPathService[getPathDetailEntityList()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 上一路段到达时间
					long beforeArrive = (new Date()).getTime();
					// 非空
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 上一到达时间
						beforeArrive = freightRouteLineDtoList.get(i - 1).getArriveDate().getTime();
					}
					// 分钟
					long min = freightRouteLineDtoList.get(i).getAging();
					// 设置到达时间
					Date arrive = new Date(sixtyThousand * min + beforeArrive);
					// 设置到达时间
					freightRouteLineDtoList.get(i).setArriveDate(arrive);
				}
			}
			pathDetailEntity.setPlanArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// 设置是否调整时间
			pathDetailEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
			// 设置调整出发时间
			pathDetailEntity.setModifyStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置调整到达时间
			pathDetailEntity.setModifyArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// 更新状态
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			// 设置上一段车牌号为空
			pathDetailEntity.setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);

			// 设置运单号
			pathDetailEntity.setWaybillNo(waybillEntity.getWaybillNo());

			// 设置ID
			pathDetailEntity.setPathDetailId(UUIDUtils.getUUID());

			// 设置流水号
			pathDetailEntity.setGoodsNo(serialNo);

			// 增加走货路径详细信息
			pathDetailList.add(pathDetailEntity);
		}

		return pathDetailList;
	}

	/** 
	* @Title: getFreightRouteLineDtoList 
	* @Description: 从基础数据获取路线信息
	* @param waybillEntity
	* @return  设定文件 
	* @return List<FreightRouteLineDto>    返回类型 
	* @see getFreightRouteLineDtoList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-20 下午1:29:57   
	* @throws 
	*/ 
	private List<FreightRouteLineDto> getFreightRouteLineDtoList(WaybillEntity waybillEntity) {
		// modify by liangfuxiang 2013-5-24下午5:29:32 begin BUG-12359 当前部门应该为收货部门，不应该为开单部门
		// 获取开单部门---表示，单子所属部门
		//String currentOrgCode = waybillEntity.getCreateOrgCode();
		//String currentOrgCode=waybillEntity.getReceiveOrgCode();
		//forrest
		String currentOrgCode = getCurrentOrgCodeFromWaybillEntity(waybillEntity);
		// modify by liangfuxiang 2013-5-24下午5:29:52 end;
		if (StringUtils.isEmpty(currentOrgCode)) {
			logger.error("CalculateTransportPathService[getFreightRouteLineDtoList()]:" + TransportPathConstants.WAYBILL_CREATEORGCODE_NULL + waybillEntity.getWaybillNo());
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_CREATEORGCODE_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo() });
		}
		// 到达部门
		String destOrgCode = waybillEntity.getCustomerPickupOrgCode();
		if (StringUtils.isEmpty(destOrgCode)) {
			logger.error("CalculateTransportPathService[getFreightRouteLineDtoList()]:" + TransportPathConstants.WAYBILL_PICKUPORGCODE_NULL + waybillEntity.getWaybillNo());
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_PICKUPORGCODE_NULL_GLOB,new Object[] { waybillEntity.getWaybillNo() });
		}
		// 运输类型
		String transportModel = waybillEntity.getProductCode();
		if (StringUtils.isEmpty(transportModel)) {
			logger.error("CalculateTransportPathService[getFreightRouteLineDtoList()]:" + TransportPathConstants.WAYBILL_PRODUCTCODE_NULL + waybillEntity.getWaybillNo());
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_PRODUCTCODE_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo() });
		}
		// 从基础资料查询走货路径
		List<FreightRouteLineDto> freightRouteLineDtoList = null;

		try {
			// 调用基础资料接口得到路径detail
			freightRouteLineDtoList = freightRouteService.queryFreightRouteBySourceTarget(currentOrgCode, destOrgCode, transportModel, new Date());
		}
		catch (Exception e) {
			String[] exps=TransportPathConstants.FREIGHTROUTE_IS_NULL.split(":");
			// 日志记录
			logger.error("CalculateTransportPathService[getFreightRouteLineDtoList()]"+exps[0]+currentOrgCode+exps[1]+destOrgCode+exps[2]+TransportPathConstants.TRANS_MODEL+transportModel);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTE_IS_NULL_GLOB,new Object[]{currentOrgCode,destOrgCode,transportModel});
		}

		// 若未查询到走货路线
		if (CollectionUtils.isEmpty(freightRouteLineDtoList)) {
			String[] exps=TransportPathConstants.FREIGHTROUTE_IS_NULL.split(":");
			// 日志记录
			logger.error(exps[0]+currentOrgCode+exps[1]+destOrgCode+exps[2]);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTE_IS_NULL_GLOB,new Object[]{currentOrgCode,destOrgCode,transportModel});
		}
		
		return freightRouteLineDtoList;
	}

	/** 
	* @Title: queryPathDetailFromMigration 
	* @Description: 从做货路径详细信息数目迁移表中查询走货路径信息
	* @param pathDetailEntity
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see queryPathDetailFromMigration
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-20 上午11:25:38   
	* @throws 
	*/ 
	private List<PathDetailEntity> queryPathDetailFromMigration(PathDetailEntity pathDetailEntity) {
		return pathDetailDao.queryPathDetailFromMigration(pathDetailEntity);
	}

	/** 
	* @Title: queryTransportPathFromMigration 
	* @Description: 从走货路径数据迁移表中查询走货路径信息
	* @param waybillNo
	* @return  设定文件 
	* @return TransportPathEntity    返回类型 
	* @see queryTransportPathFromMigration
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-20 上午11:19:14   
	* @throws 
	*/ 
	private TransportPathEntity queryTransportPathFromMigration(String waybillNo) {
		
		// 查询数据迁移表
		List<TransportPathEntity> transportPathEntityList = transportationPathDao.queryTransportPathMigration(waybillNo);

		if (CollectionUtils.isEmpty(transportPathEntityList)) {
			// 未查询到走货路径
			logger.error("CalculateTransportPathService[queryTransportPathFromMigration()]:" + TransportPathConstants.QUERY_TRANSPORT_PATH_FROM_MIGRATION_NORESULT + waybillNo);
			return null;
		}
		// 查询到多条，异常
		else if (transportPathEntityList.size() > 1) {
			logger.error("CalculateTransportPathService[queryTransportPathFromMigration()]:" + TransportPathConstants.MULTY_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.MULTY_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION_GLOB,new Object[]{waybillNo});
		}
		else {
			return transportPathEntityList.get(0);
		}
	}

	/**
	 * 提供给综合查询的接口,返回运单的状态明细, group by状态 ,出发部门,到达部门,出发时间,到达时间,下一到达时间
	 * ---------------------------此接口，目前已经作废，综合查询中状态信息的接口已经不在使用此
	 * ---------------------------liangfuxiang 2013-07-18
	 * @author huyue
	 * @date 2012-12-24 上午10:30:50
	 */
	public List<GeneralQueryDto> queryWaybillStatusByWaybillNoForPkp(String waybillNo) throws TfrBusinessException {
		// 统计车辆类型和数量
		List<GeneralQueryDto> generalQueryList = new ArrayList<GeneralQueryDto>();
		// 走货路径详细信息
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 走货路径详细信息
		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();
		// 货件数量
		List<String> goodsList = new ArrayList<String>();
		// 货件数量
		List<String> goodsList2 = new ArrayList<String>();
		// 结算部门编码
		String billingOrg;
		// 目标部门编码
		String destOrg;
		// 判断是否分批配载 如果没有分批,则直接查询 否则需要group by serialNo
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 判断是否存在条目
		if (null != transportPathEntity) {
			// 获取开单部门,最终到达部门和运输类型
			billingOrg = transportPathEntity.getBillingOrgCode();
			// 目标部门编码
			destOrg = transportPathEntity.getDestOrgCode();
			// 查询营业部已出发
			pathDetailEntity = new PathDetailEntity();
			// 走货路径详细信息
			pathDetailList = new ArrayList<PathDetailEntity>();
			// 货件数量
			goodsList = new ArrayList<String>();
			// 货件数量
			goodsList2 = new ArrayList<String>();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置开单部门为出发部门,状态为出发的
			pathDetailEntity.setOrigOrgCode(billingOrg);
			// 路径明细状态 离开
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
			// 查询走货路径详细信息
			pathDetailList = pathDetailDao.generalQuery(pathDetailEntity);
			// 查询开单部门为出发部门,状态为交接的
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
			// 增加走货路径详细信息
			pathDetailList.addAll(pathDetailDao.generalQuery(pathDetailEntity));
			// 走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历走货路径详细信息列表
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 路径明细状态 离开
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
					// 货件数量
					goodsList = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// 路径明细状态 已交接
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
					// 货件数量
					goodsList2 = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// //货件数量大于0
					if (goodsList.size() > 0 || goodsList2.size() > 0) {
						// 统计车辆类型和数量
						GeneralQueryDto dto = new GeneralQueryDto();
						// 如果为空则说明没有分批配载 否则为分批
						int count = 0;
						// 货件数量不为空
						if (CollectionUtils.isNotEmpty(goodsList) && StringUtils.isNotEmpty(goodsList.get(0))) {
							count += goodsList.size();
						}
						// 货件数量不为空
						if (CollectionUtils.isNotEmpty(goodsList2) && StringUtils.isNotEmpty(goodsList2.get(0))) {
							// 货件数量
							count += goodsList2.size();
						}
						// 货件数量不为0
						if (count != 0) {
							// 货件数量
							dto.setGoodsCount(count);
						}
						else {
							// 货件数量
							dto.setGoodsCount(transportPathEntity.getGoodsQtyTotal());
						}
						// 综合查询状态
						// 营业部已出发
						dto.setAction(TransportPathConstants.GENERAL_QUERY_DEPARTBILLING);
						// modify by liangfuxiang 2013-4-24上午10:56:51 begin
						dto.setActionCode(TransportPathConstants.GENERAL_QUERY_DEPARTBILLING_CODE);
						// modify by liangfuxiang 2013-4-24上午10:56:57 end;
						// 综合查询状态 不可提货
						dto.setIfAvailedPickup(TransportPathConstants.NOTAVAILEDPICKUP);
						// 设置下以部门编码
						dto.setNextOrgCode(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
						// 在途中,拼接出发到达部门
						dto.setNowPosition(getNameByCode(pathDetailList.get(i).getOrigOrgCode()) + "到" + getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()) + "运输中");
						// 设置修改到达时间
						dto.setPlanArriveTime(pathDetailList.get(i).getModifyArriveTime());
						// 获取预计派送和提货时间
						dto.setPlanPickupTime(pathDetailList.get(i).getPlanPickupTime());
						// 添加
						generalQueryList.add(dto);
					}
				}
			}
			// 查询已到达中转场
			pathDetailEntity = new PathDetailEntity();
			// 新建走货路径详细信息列表
			pathDetailList = new ArrayList<PathDetailEntity>();
			// 货件数量
			goodsList = new ArrayList<String>();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置到达部门不为最终部门 状态为到达
			pathDetailEntity.setObjectiveOrgCode(destOrg);
			// 路径明细状态 抵达
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
			// 查询走货路径详细信息列表
			pathDetailList = pathDetailDao.generalQueryNot(pathDetailEntity);
			// 走货路径详细信息列表非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历走货路径详细信息列表
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 路径明细状态 抵达
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
					// 货件数量
					goodsList = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// //货件数量大于0
					if (goodsList.size() > 0) {
						GeneralQueryDto dto = new GeneralQueryDto();
						// 如果为空则说明没有分批配载 否则为分批
						if (StringUtils.isNotEmpty(goodsList.get(0))) {
							// 货件数量
							dto.setGoodsCount(goodsList.size());
						}
						else {
							// //货件数量
							dto.setGoodsCount(transportPathEntity.getGoodsQtyTotal());
						}

						// 综合查询状态 已到达中转场
						// dto.setAction(TransportPathConstants.GENERAL_QUERY_ARRIVETRANSFERCENTER);
						// modify by liangfuxiang 2013-4-23下午3:44:28 begin BUG-7600 当前部门为营业部且非最终部门，则综合状态为营业部，否则为中转场
						// 综合查询状态 中转库存
						// 获取当前部门编码
						// String currOrgCode = pathDetailList.get(i).getOrigOrgCode();
						String currOrgCode = pathDetailList.get(i).getObjectiveOrgCode();
						// 若出发部门编码为空
						if (StringUtils.isEmpty(currOrgCode)) {
							logger.error("CalculateTransportPathService[queryWaybillStatusByWaybillNoForPkp()]:" + TransportPathConstants.ORGINAL_ORG_CODE_NULL);
							throw new TfrBusinessException(TransportPathConstants.ORGINAL_ORG_CODE_NULL_GLOB);
						}
						// 根据部门code查询部门信息
						OrgAdministrativeInfoEntity orgAdministrativeInfoEntity = orgAdministrativeInfoService.queryOrgAdministrativeInfoByCode(StringUtils.trim(currOrgCode));
						// 根据部门code未查询到部门信息
						if (null == orgAdministrativeInfoEntity) {
							logger.error("CalculateTransportPathService[queryWaybillStatusByWaybillNoForPkp()]:" + TransportPathConstants.QUERY_DEPARTMENT_BY_CODE_WRONG + currOrgCode);
							throw new TfrBusinessException(TransportPathConstants.QUERY_DEPARTMENT_BY_CODE_WRONG_GLOB, new Object[] { currOrgCode });
						}

						// 是否营业部
						String isSalesDepartment = orgAdministrativeInfoEntity.getSalesDepartment();
						// 是营业部
						if (StringUtils.isNotEmpty(isSalesDepartment) && isSalesDepartment.equalsIgnoreCase(TransportPathConstants.IS_SALESDEPARTMENT_YES)) {
							// 已到达达营业部
							dto.setAction(TransportPathConstants.GENERAL_QUERY_ARRIVEDEST);
							dto.setActionCode(TransportPathConstants.GENERAL_QUERY_ARRIVEDEST_CODE);
						}
						else {
							// 状态：已到达中转场
							dto.setAction(TransportPathConstants.GENERAL_QUERY_ARRIVETRANSFERCENTER);
							dto.setActionCode(TransportPathConstants.GENERAL_QUERY_ARRIVETRANSFERCENTER_CODE);
						}
						// modify by liangfuxiang 2013-4-23下午3:46:52 end;

						// 综合查询状态 不可提货
						dto.setIfAvailedPickup(TransportPathConstants.NOTAVAILEDPICKUP);
						// 下一到达部门为本条中的到达部门
						dto.setNextOrgCode(getNameByCode(pathDetailList.get(i).getNextDestOrgCode()));
						// 现部门为到达部门
						dto.setNowPosition(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
						// 下一到达部门计划到达时间
						dto.setPlanArriveTime(pathDetailList.get(i).getNextArriveTime());
						// 获取预计派送和提货时间
						dto.setPlanPickupTime(pathDetailList.get(i).getPlanPickupTime());
						// 添加
						generalQueryList.add(dto);
					}
				}
			}
			// 查询中转库存
			pathDetailEntity = new PathDetailEntity();
			// 走货路径详细信息
			pathDetailList = new ArrayList<PathDetailEntity>();
			// 货件数量
			goodsList = new ArrayList<String>();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置到达部门不为最终部门 类型为入库
			pathDetailEntity.setObjectiveOrgCode(destOrg);
			// 路径明细状态 入库
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
			// 查询走货路径详细信息
			pathDetailList = pathDetailDao.generalQueryNot(pathDetailEntity);
			// 走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历走货路径详细信息
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 路径明细状态 入库
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
					// 货件数量
					goodsList = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// 货件数量不为0
					if (goodsList.size() > 0) {
						GeneralQueryDto dto = new GeneralQueryDto();
						// 如果为空则说明没有分批配载 否则为分批
						if (StringUtils.isNotEmpty(goodsList.get(0))) {
							// 货件数量
							dto.setGoodsCount(goodsList.size());
						}
						else {
							// 货件数量
							dto.setGoodsCount(transportPathEntity.getGoodsQtyTotal());
						}
						// modify by liangfuxiang 2013-4-23下午3:44:28 begin BUG-7600 当前部门为营业部且非最终部门，则综合状态为营业部库存，否则为中转库存
						// 综合查询状态 中转库存
						// 获取当前部门编码
						// String currOrgCode = pathDetailList.get(i).getOrigOrgCode();
						String currOrgCode = pathDetailList.get(i).getObjectiveOrgCode();
						// 若出发部门编码为空
						if (StringUtils.isEmpty(currOrgCode)) {
							logger.error("CalculateTransportPathService[queryWaybillStatusByWaybillNoForPkp()]:" + TransportPathConstants.ORGINAL_ORG_CODE_NULL);
							throw new TfrBusinessException(TransportPathConstants.ORGINAL_ORG_CODE_NULL_GLOB);
						}
						// 根据部门code查询部门信息
						OrgAdministrativeInfoEntity orgAdministrativeInfoEntity = orgAdministrativeInfoService.queryOrgAdministrativeInfoByCode(StringUtils.trim(currOrgCode));
						// 根据部门code未查询到部门信息
						if (null == orgAdministrativeInfoEntity) {
							logger.error("CalculateTransportPathService[queryWaybillStatusByWaybillNoForPkp()]:" + TransportPathConstants.QUERY_DEPARTMENT_BY_CODE_WRONG + currOrgCode);
							throw new TfrBusinessException(TransportPathConstants.QUERY_DEPARTMENT_BY_CODE_WRONG_GLOB, new Object[] { currOrgCode });
						}

						// 是否营业部
						String isSalesDepartment = orgAdministrativeInfoEntity.getSalesDepartment();
						// 是营业部
						if (StringUtils.isNotEmpty(isSalesDepartment) && isSalesDepartment.equalsIgnoreCase(TransportPathConstants.IS_SALESDEPARTMENT_YES)) {
							dto.setAction(TransportPathConstants.GENERAL_QUERY_DESTINSTORE);
							dto.setActionCode(TransportPathConstants.GENERAL_QUERY_DESTINSTORE_CODE);
						}
						else {
							// 状态：中转库存
							dto.setAction(TransportPathConstants.GENERAL_QUERY_TRANSFERCENTERINSTORE);
							dto.setActionCode(TransportPathConstants.GENERAL_QUERY_TRANSFERCENTERINSTORE_CODE);
						}
						// modify by liangfuxiang 2013-4-23下午3:46:52 end;

						// 综合查询状态 不可提货
						dto.setIfAvailedPickup(TransportPathConstants.NOTAVAILEDPICKUP);
						// 下一到达部门为本条中的到达部门
						dto.setNextOrgCode(getNameByCode(pathDetailList.get(i).getNextDestOrgCode()));
						// 现部门为到达部门
						dto.setNowPosition(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
						// 下一到达部门计划到达时间
						dto.setPlanArriveTime(pathDetailList.get(i).getNextArriveTime());
						// 获取预计派送和提货时间
						dto.setPlanPickupTime(pathDetailList.get(i).getPlanPickupTime());
						// 添加
						generalQueryList.add(dto);
					}
				}
			}
			// 查询中转运输 包括已交接&出发
			pathDetailEntity = new PathDetailEntity();
			// 查询走货路径详细信息
			pathDetailList = new ArrayList<PathDetailEntity>();
			// 货件数量
			goodsList = new ArrayList<String>();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置开单部门为出发部门,到达部门为最终部门,
			// 根据条件判断过滤本两种类型, 设置状态为出发
			pathDetailEntity.setOrigOrgCode(billingOrg);
			// 路径明细状态 离开
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
			// 查询走货路径详细信息
			pathDetailList = pathDetailDao.generalQueryNot(pathDetailEntity);
			// 查询开单部门为出发部门,状态为交接的
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
			// 添加
			pathDetailList.addAll(pathDetailDao.generalQueryNot(pathDetailEntity));
			// 走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 路径明细状态 离开
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
					// 获取货件信息
					goodsList = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// 获取走货路径详细信息
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
					// 获取货件信息
					goodsList2 = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// 数量不为0
					if (goodsList.size() > 0 || goodsList2.size() > 0) {
						// 统计车辆类型和数量
						GeneralQueryDto dto = new GeneralQueryDto();
						// 如果为空则说明没有分批配载 否则为分批
						int count = 0;
						// 数量不为0
						if (CollectionUtils.isNotEmpty(goodsList) && StringUtils.isNotEmpty(goodsList.get(0))) {
							// 件数
							count += goodsList.size();
						}
						if (CollectionUtils.isNotEmpty(goodsList2) && StringUtils.isNotEmpty(goodsList2.get(0))) {
							// 件数
							count += goodsList2.size();
						}
						// 数量不为0
						if (count != 0) {
							// 件数
							dto.setGoodsCount(count);
						}
						else {
							// 件数
							dto.setGoodsCount(transportPathEntity.getGoodsQtyTotal());
						}
						// 综合查询状态 中转运输
						dto.setAction(TransportPathConstants.GENERAL_QUERY_INTRANSIT);
						dto.setActionCode(TransportPathConstants.GENERAL_QUERY_INTRANSIT_CODE);
						// 综合查询状态 不可提货
						dto.setIfAvailedPickup(TransportPathConstants.NOTAVAILEDPICKUP);
						// 下一部门编码
						dto.setNextOrgCode(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
						// 在途中,拼接出发到达部门
						dto.setNowPosition(getNameByCode(pathDetailList.get(i).getOrigOrgCode()) + "到" + getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()) + "运输中");
						// 计划到达时间
						dto.setPlanArriveTime(pathDetailList.get(i).getModifyArriveTime());
						// 获取预计派送和提货时间
						dto.setPlanPickupTime(pathDetailList.get(i).getPlanPickupTime());
						// 添加
						generalQueryList.add(dto);
					}
				}
			}
			// 查询已到达营业部 状态是否可提取为是
			pathDetailEntity = new PathDetailEntity();
			// 新建走货路径详细信息
			pathDetailList = new ArrayList<PathDetailEntity>();
			// 新建列表
			goodsList = new ArrayList<String>();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置到达部门为最终部门,状态为到达
			pathDetailEntity.setObjectiveOrgCode(destOrg);
			// 路径明细状态 抵达
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
			// 查询走货路径详细信息
			pathDetailList = pathDetailDao.generalQuery(pathDetailEntity);
			// 走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历走货路径详细信息
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 设置路径明细状态
					// 抵达
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_ARRIVE);
					// 查询货物数量
					goodsList = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// 货物数量不为0
					if (goodsList.size() > 0) {
						// 统计车辆类型和数量DTO
						GeneralQueryDto dto = new GeneralQueryDto();
						// 如果为空则说明没有分批配载 否则为分批
						if (StringUtils.isNotEmpty(goodsList.get(0))) {
							// 货件数量
							dto.setGoodsCount(goodsList.size());
						}
						else {
							// 货物数量
							dto.setGoodsCount(transportPathEntity.getGoodsQtyTotal());
						}
						// 综合查询状态 已到达营业部
						dto.setAction(TransportPathConstants.GENERAL_QUERY_ARRIVEDEST);
						dto.setActionCode(TransportPathConstants.GENERAL_QUERY_ARRIVEDEST_CODE);
						// 综合查询状态 可提货
						dto.setIfAvailedPickup(TransportPathConstants.AVAILEDPICKUP);
						// 到达
						dto.setNowPosition(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
						// 没有下一部门和到达时间
						dto.setNextOrgCode(null);
						// 到达时间为空
						dto.setPlanArriveTime(null);
						// 获取预计派送和提货时间
						dto.setPlanPickupTime(pathDetailList.get(i).getPlanPickupTime());
						// 添加
						generalQueryList.add(dto);
					}
				}
			}
			// 查询营业部库存 状态是否可提取为是
			pathDetailEntity = new PathDetailEntity();
			// 走货路径详细信息
			pathDetailList = new ArrayList<PathDetailEntity>();
			// 流水号
			goodsList = new ArrayList<String>();
			// 设置单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置到达部门为最终部门,
			// 状态为到达
			pathDetailEntity.setObjectiveOrgCode(destOrg);
			// 入库
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
			// 走货路径详细信息
			pathDetailList = pathDetailDao.generalQuery(pathDetailEntity);
			// 走货路径详细信息非空
			if (CollectionUtils.isNotEmpty(pathDetailList)) {
				// 遍历
				for (int i = 0; i < pathDetailList.size(); i++) {
					// 设置是否离开状态.
					pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
					// 查询流水号
					goodsList = pathDetailDao.generalGoodsNoList(pathDetailList.get(i));
					// 流水号不唯一
					if (goodsList.size() > 0) {
						// 新建统计车辆类型和数量DTO
						GeneralQueryDto dto = new GeneralQueryDto();
						// 如果为空则说明没有分批配载 否则为分批
						if (StringUtils.isNotEmpty(goodsList.get(0))) {
							// 设置数量
							dto.setGoodsCount(goodsList.size());
						}
						else {
							// 设置数量
							dto.setGoodsCount(transportPathEntity.getGoodsQtyTotal());
						}
						// 设置状态
						dto.setAction(TransportPathConstants.GENERAL_QUERY_DESTINSTORE);
						dto.setActionCode(TransportPathConstants.GENERAL_QUERY_DESTINSTORE_CODE);
						// 设置 是否可提货.
						dto.setIfAvailedPickup(TransportPathConstants.AVAILEDPICKUP);
						// 到达
						dto.setNowPosition(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
						// 没有下一部门和到达时间
						dto.setNextOrgCode(null);
						// 设置计划到达时间为空
						dto.setPlanArriveTime(null);
						// 获取预计派送和提货时间
						dto.setPlanPickupTime(pathDetailList.get(i).getPlanPickupTime());
						// 增加
						generalQueryList.add(dto);
					}
				}
			}
			// 返回列表
			return generalQueryList;
		}
		else {
			// 返回空
			return null;
		}
	}

	/**
	 * 根据组织code查询缓存获取name
	 * 
	 * @author huyue
	 * @date 2013-1-22 下午3:42:47
	 */
	public String getNameByCode(String orgCode) {
		// 根据部门代码获取部门名称
		String orgName = orgAdministrativeInfoService.queryCommonNameByCommonCodeFromCache(orgCode);
		// 名称为空
		if (StringUtils.isEmpty(orgName)) {
			// 返回代码
			return orgCode;
		}
		else {
			// 返回名称
			return orgName;
		}
	}

	/**
	 * 新增流水号走货路径的初始化。
	 * -------更改单专用接口---增加货件数
	 * @author liangfuxiang
	 * @date 2013-03-13
	 * @throws TfrBusinessException
	 */
	@Transactional
	public void addNewTransportPath(String waybillNo, List<String> goodsNos, String currentOrgCode, String destOrgCode, String transportModel) throws TfrBusinessException {
		// 新增流水号走货路径的初始化 ..参数有效性验证
		addNewTransportPathPramaterValidate(waybillNo, currentOrgCode, destOrgCode, transportModel);

		// 根据货运单号查询走货路径信息
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 判断是否有该运单对应的走货路径,如果没有返回NODATA.需要进行新增
		if (null != transportPathEntity) {

			// modify by liangfuxiang 2013-6-17上午11:17:50 begin
			// 途中的运单发起更改，运单入库下一个部门且生成待办之后，发现在库存里显示货区不对，货物显示在多个货区，有一部分件数不在走货路径下一部门的货区
			// 分批配载
			// if (StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage())) {

			// modify by liangfuxiang 2013-7-2下午7:31:59 begin 若当前部门与目的站相同
			
			// 设置当前部门
			transportPathEntity.setCurrentOrgCode(currentOrgCode);
			transportPathEntity.setCurrentOrgCodeName(getNameByCode(currentOrgCode));
			// 设置目标部门
			transportPathEntity.setDestOrgCode(destOrgCode);
			transportPathEntity.setDestOrgCodeName(getNameByCode(destOrgCode));
			
			if (StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage())) {
				// 删除相同流水号的走货路径
				deleteSameGoodsNosPathDetailEntityList(waybillNo, goodsNos);
			}
			
			// 原走货路径未分批。。此时要强制分批
			if (StringUtils.equals(TransportPathConstants.NOTPARTIALSTOWAGE, transportPathEntity.getIfPartialStowage())) {
				//主表是否分批---设置为分批配载
				transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
				//强制分批
				forceSepratePathForAmendmentBill(waybillNo, goodsNos);
			}
			
			List<FreightRouteLineDto> freightRouteLineDtoList = null;
			//若当前部门与目的站相同
			if (StringUtils.equalsIgnoreCase(currentOrgCode, destOrgCode)) {
				//根据运单生成走货路径，当前部门之前的状态全部默认为releave
				for (int i = 0; i < goodsNos.size(); i++) {
					//当前部门和目的部门相同 从开单信息中生成走货路径信息
					dealTransportPathSameOrgCode(waybillNo, currentOrgCode, goodsNos.get(i), transportPathEntity);
				}
			}
			else {
				// 调用基础资料接口得到路径detail
				freightRouteLineDtoList = getFreightRouteLineDtoList(currentOrgCode, destOrgCode, transportModel);
				// 增加走货路径详细信息
				addPathDetails(transportPathEntity, freightRouteLineDtoList, goodsNos);
			}
			// modify by liangfuxiang 2013-7-2下午7:31:59 end 若当前部门与目的站相同
			
			
			// modify by liangfuxiang 2013-6-6下午11:04:39 begin BUG-26697 正式环境，运单156368600更改件数：件数:1->2;，受理待办事项后没有入库。
			// 目的地更改则需要更改库存 调用接口更改库存
			InOutStockEntity inOutStockEntity = null;
			for (int s = 0; s < goodsNos.size(); s++) {
				if(null == goodsNos.get(s)){
					continue;
				}
				// 新建入库实例
				inOutStockEntity = new InOutStockEntity();
				// 设置运载单号
				inOutStockEntity.setWaybillNO(transportPathEntity.getWaybillNo());
				// 设置序列号
				inOutStockEntity.setSerialNO(goodsNos.get(s));
				// 设置当前部门
				inOutStockEntity.setOrgCode(currentOrgCode);
				
				try {
					// 设置操作员工工号
					inOutStockEntity.setOperatorCode(FossUserContext.getCurrentInfo().getEmpCode());
					// 设置操作员工姓名
					inOutStockEntity.setOperatorName(FossUserContext.getCurrentInfo().getEmpName());
				}
				catch (Exception e) {
					//352203-sonar
					logger.info("CalculateTransportPathService.addNewTransportPath 报错:" + StringUtils.substring(e.toString(), 0, ConstantsNumberSonar.SONAR_NUMBER_100));
				}
				
				// 设置更改单类型
				inOutStockEntity.setInOutStockType(StockConstants.WAYBILL_RFC_IN_STOCK_TYPE);
				// 入库
				stockService.inStockPC(inOutStockEntity);
			}
			// modify by liangfuxiang 2013-6-6下午11:05:50 end;
		}
		else {
			// 记录日志
			logger.error("CalculateTransportPathService[addNewTransportPath()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + waybillNo);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
		}
	}

	
	/** 
	* @Title: deleteSameGoodsNosPathDetailEntityList 
	* @Description: 删除相同流水号的走货路径
	* @param waybillNo
	* @param goodsNos  设定文件 
	* @return void    返回类型 
	* @see deleteSameGoodsNosPathDetailEntityList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-24 上午9:48:58   
	* @throws 
	*/ 
	private void deleteSameGoodsNosPathDetailEntityList(String waybillNo, List<String> goodsNos) {
		
		PathDetailEntity pathDetailEntity=null;
		List<PathDetailEntity> sameGoodsNosPathDetailList=new ArrayList<PathDetailEntity>();
		for(int k=0;k<goodsNos.size();k++){
			pathDetailEntity=new PathDetailEntity();
			pathDetailEntity.setWaybillNo(waybillNo);
			pathDetailEntity.setGoodsNo(goodsNos.get(k));
			sameGoodsNosPathDetailList.add(pathDetailEntity);
		}
		//删除
		pathDetailDao.deleteListPathDetail(sameGoodsNosPathDetailList);
	}

	/**
	 * @param goodsNos  
	* @Title: forceSepratePathForAmendmentBill 
	* @Description: 强制分批
	* @param waybillNo  设定文件 
	* @return void    返回类型 
	* @see forceSepratePathForAmendmentBill
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午8:20:04   
	* @throws 
	*/ 
	private void forceSepratePathForAmendmentBillNoRemove(String waybillNo, List<String> goodsNos) {

		// 获取原走货路径明细
		List<PathDetailEntity> originalPathDetailList = getOriginalPathDetailList(waybillNo);
		// 查询全部货件号
		List<String> goodsNoList = getGoodNoList(waybillNo);
		
		//获取需要分批配载的流水号
		List<String> partGoodsNoList=goodsNoList; //getPartGoodsNoList(goodsNos,goodsNoList);
		
		// 加了流水后以后的新的走货路径详细信息列表
		List<PathDetailEntity> newPathDetailEntityList = new ArrayList<PathDetailEntity>();

		PathDetailEntity tempPathDetailEntity = null;
		// 将原走货路径加入流水号
		for (int i = 0; i < partGoodsNoList.size(); i++) {
			for (PathDetailEntity pathDetailEntity : originalPathDetailList) {
				tempPathDetailEntity = new PathDetailEntity();
				BeanUtils.copyProperties(pathDetailEntity, tempPathDetailEntity);
				tempPathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
				tempPathDetailEntity.setGoodsNo(partGoodsNoList.get(i));
				newPathDetailEntityList.add(tempPathDetailEntity);
			}
		}

		// 删除原始走货路径详细信息
		pathDetailDao.deleteListPathDetail(originalPathDetailList);
		// 保存新的走货路径相信信息
		pathDetailDao.addListPathDetail(newPathDetailEntityList);

	}
	
	
	/**
	 * @param goodsNos  
	* @Title: forceSepratePathForAmendmentBill 
	* @Description: 强制分批
	* @param waybillNo  设定文件 
	* @return void    返回类型 
	* @see forceSepratePathForAmendmentBill
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午8:20:04   
	* @throws 
	*/ 
	private void forceSepratePathForAmendmentBill(String waybillNo, List<String> goodsNos) {

		// 获取原走货路径明细
		List<PathDetailEntity> originalPathDetailList = getOriginalPathDetailList(waybillNo);
		// 查询全部货件号
		List<String> goodsNoList = getGoodNoList(waybillNo);
		
		//获取需要分批配载的流水号
		List<String> partGoodsNoList=getPartGoodsNoList(goodsNos,goodsNoList);
		
		// 加了流水后以后的新的走货路径详细信息列表
		List<PathDetailEntity> newPathDetailEntityList = new ArrayList<PathDetailEntity>();

		PathDetailEntity tempPathDetailEntity = null;
		// 将原走货路径加入流水号
		for (int i = 0; i < partGoodsNoList.size(); i++) {
			for (PathDetailEntity pathDetailEntity : originalPathDetailList) {
				tempPathDetailEntity = new PathDetailEntity();
				BeanUtils.copyProperties(pathDetailEntity, tempPathDetailEntity);
				tempPathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
				tempPathDetailEntity.setGoodsNo(partGoodsNoList.get(i));
				newPathDetailEntityList.add(tempPathDetailEntity);
			}
		}

		// 删除原始走货路径详细信息
		pathDetailDao.deleteListPathDetail(originalPathDetailList);
		// 保存新的走货路径相信信息
		pathDetailDao.addListPathDetail(newPathDetailEntityList);

	}

	/** 
	* @Title: getPartGoodsNoList 
	* @Description: 获取需要分批配载的流水号信息
	* @param goodsNos
	* @param goodsNoList
	* @return  设定文件 
	* @return List<String>    返回类型 
	* @see getPartGoodsNoList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午8:25:04   
	* @throws 
	*/ 
	private List<String> getPartGoodsNoList(List<String> goodsNos, List<String> goodsNoList) {
		Set<String> pathSet=new HashSet<String>(goodsNoList);
		pathSet.removeAll(goodsNos);
		return new ArrayList<String>(pathSet);
	}

	/**
	* @deprecated
	* @Title: isPARTIALSTOWAGE 
	* @Description: 判断是否分批配载
	* @param waybillNo
	* @return  设定文件 
	* @return String    返回类型 
	* @see isPARTIALSTOWAGE
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午3:52:10   
	* @throws
	 */
	private String isPartialStowage(String waybillNo) {
		// 判断是否分配配载
		String isPartLoad = stockService.querySeparateStatusByStock(waybillNo);
		// 库存无法判断时，查询交接单
		if (isPartLoad == null) {
			isPartLoad = handOverBillService.queryGoodsBeSeparatedFromHandOverBillByWaybillNo(waybillNo);
		}
		// 为空，则默认为非分批配载
		if (null == isPartLoad) {
			return FossConstants.NO;
		}
		else {
			return isPartLoad;
		}
	}

	/**
	 * 增加走货路径详细信息
	 * 
	 * @param freightRouteLineDtoList
	 * @author liangfuxiang
	 * @param transportPathEntity
	 * @param goodsNos
	 * @date 2013-03-13
	 */
	private void addPathDetails(TransportPathEntity transportPathEntity, List<FreightRouteLineDto> freightRouteLineDtoList, List<String> goodsNos) {

		// 新建走货路径详细信息列表
		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();

		// 新建走货路径详细信息
		PathDetailEntity pathDetailEntity = null;

		// 新建走货路径详细信息
		PathDetailEntity pathDetailEntitywithNewGoodsNo = null;

		// 遍历
		for (int i = 0; i < freightRouteLineDtoList.size(); i++) {
			// 走货路径详情
			pathDetailEntity = new PathDetailEntity();

			// 设置出发部门
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getSourceCode())) {
				logger.error("CalculateTransportPathService[addPathDetails()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG + queryFreightRouteBySourceTarget);
				// 抛出异常
				// modify by liangfuxiang 2013-7-1下午12:54:56 begin BUG-40000
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME
						+ getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
			}
			// 设置出发部门编码
			pathDetailEntity.setOrigOrgCode(freightRouteLineDtoList.get(i).getSourceCode());
			// 设置到达部门
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getTargetCode())) {
				logger.error("CalculateTransportPathService[addPathDetails()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG + queryFreightRouteBySourceTarget);
				// 抛出异常
				// modify by liangfuxiang 2013-7-1下午12:54:56 begin BUG-40000
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] {
						queryFreightRouteBySourceTarget,
						TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME
								+ getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
			}
			// 设置目标部门编码
			pathDetailEntity.setObjectiveOrgCode(freightRouteLineDtoList.get(i).getTargetCode());
			// 设置下一到达部门&时间
			if ((i + 1) < freightRouteLineDtoList.size()) {
				// 设置目标部门编码
				pathDetailEntity.setNextDestOrgCode(freightRouteLineDtoList.get(i + 1).getTargetCode());
				// 设置到达时间
				pathDetailEntity.setNextArriveTime(freightRouteLineDtoList.get(i + 1).getArriveDate());
			}
			// 设置开单部门
			pathDetailEntity.setBillingOrgCode(transportPathEntity.getBillingOrgCode());
			// 设置线路段号
			pathDetailEntity.setRouteNo(String.valueOf(i + 1));

			// 设置计划出发时间,如果为空，且非汽运偏线\精准空运\整车则抛出异常
			String lineSort = freightRouteLineDtoList.get(i).getLineSort();
			// 离开时间为空
			if (null == freightRouteLineDtoList.get(i).getLeaveDate()) {
				if (StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(lineSort, DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i).getLineType(),
								DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 找不到离开时间
					// 抛出异常
					logger.error("CalculateTransportPathService[addPathDetails()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME + queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 非空
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 设置离开时间
						freightRouteLineDtoList.get(i).setLeaveDate(freightRouteLineDtoList.get(i - 1).getArriveDate());
					}
					else {
						// 设置离开时间
						freightRouteLineDtoList.get(i).setLeaveDate(new Date());
					}
				}
			}
			// 设置计划出发时间
			pathDetailEntity.setPlanStartTime(freightRouteLineDtoList.get(i).getLeaveDate());

			// 设置计划到达时间,如果为空，且非汽运偏线\精准空运\整车则抛出异常
			if (null == freightRouteLineDtoList.get(i).getArriveDate()) {
				// 综合管理-线路-始发线路
				if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
								.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					logger.error("CalculateTransportPathService[addPathDetails()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME + queryFreightRouteBySourceTarget);
					// 抛出异常
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 上一路段到达时间
					long beforeArrive = (new Date()).getTime();
					// 非空
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 上一到达时间
						beforeArrive = freightRouteLineDtoList.get(i - 1).getArriveDate().getTime();
					}
					// 分钟
					long min = freightRouteLineDtoList.get(i).getAging();
					// 设置到达时间
					Date arrive = new Date(sixtyThousand * min + beforeArrive);
					// 设置到达时间
					freightRouteLineDtoList.get(i).setArriveDate(arrive);
				}
			}
			pathDetailEntity.setPlanArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// 设置是否调整时间
			pathDetailEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
			// 设置调整出发时间
			pathDetailEntity.setModifyStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置调整到达时间
			pathDetailEntity.setModifyArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// 更新状态
			pathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			// 设置上一段车牌号为空
			pathDetailEntity.setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);

			// 设置运单号
			pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());

			// modify by liangfuxiang 2013-6-17上午11:55:08 begin 
			if (CollectionUtils.isEmpty(goodsNos)) {
				pathDetailList.add(pathDetailEntity);
			}
			else {
				// 遍历流水号
				for (String goodsNo : goodsNos) {
					// 新建走货路径详细信息
					pathDetailEntitywithNewGoodsNo = new PathDetailEntity();
					// 复制各个属性值
					BeanUtils.copyProperties(pathDetailEntity, pathDetailEntitywithNewGoodsNo);
					// 设置主键ID
					pathDetailEntitywithNewGoodsNo.setPathDetailId(UUIDUtils.getUUID());
					// 设置流水号
					pathDetailEntitywithNewGoodsNo.setGoodsNo(goodsNo);
					// 增加走货路径详细信息
					pathDetailList.add(pathDetailEntitywithNewGoodsNo);
				}
			}
			// modify by liangfuxiang 2013-6-17上午11:55:13 end;
		}
		
		// 按照流水号和路段号排序
		pathDetailList = sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);
		
		// 走货路径详细信息非空
		if (CollectionUtils.isNotEmpty(pathDetailList)) {
			
			// modify by liangfuxiang 2013-6-17下午1:30:52 begin
			// 更新主表信息
			// 非分批配载，更新走货路径主表信息
			if (CollectionUtils.isEmpty(goodsNos)) {
				//更新第一段路径状态
				pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
				pathDetailList.get(0).setActualArriveTime(new Date());
				pathDetailList.get(0).setActualStartTime(new Date());
				transportPathEntity.setIfPartialStowage(TransportPathConstants.NOTPARTIALSTOWAGE);
				
				// modify by liangfuxiang 2013-6-20上午9:10:30 begin
				// 若只有一段走货路径--需要拼接一段,因为打标签至少需要两段走货路径
				pathDetailList = spliceFirstPathDetailEntity(pathDetailList, null);
				// modify by liangfuxiang 2013-6-20上午9:10:36 end;
			}
			else {
				
				for(String goodsNo:goodsNos){
					for(int k=0;k<pathDetailList.size();k++){
						//流水号相同，取第一个,修改其状态信息
						if(goodsNo.equalsIgnoreCase(pathDetailList.get(k).getGoodsNo())){
							pathDetailList.get(k).setArriveOrLeave(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
							pathDetailList.get(k).setActualArriveTime(new Date());
							pathDetailList.get(k).setActualStartTime(new Date());
							// modify by liangfuxiang 2013-6-20上午9:10:30 begin
							// 若相同流水号的走货路径，只有一段走货路径--需要拼接一段,因为打标签至少需要两段走货路径
							pathDetailList = spliceFirstPathDetailEntity(pathDetailList, goodsNo);
							// modify by liangfuxiang 2013-6-20上午9:10:36 end;
							break;
						}
					}
				}
				// 分批配载
				transportPathEntity.setIfPartialStowage(TransportPathConstants.PARTIALSTOWAGE);
			}
			
			// 更新走货路径明细
			pathDetailDao.addListPathDetail(pathDetailList);
			
			//上一状态
			String beforeAction = transportPathEntity.getAction();
			// 入库
			transportPathEntity.setAction(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
			//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
			//transportPathEntity.setTransportPath(splicePathString(pathDetailList,transportPathEntity));
			transportPathEntity.setBeforeAction(beforeAction);
			if(pathDetailList.size()>1){
				transportPathEntity.setPlanStartTime(pathDetailList.get(1).getPlanStartTime());
				transportPathEntity.setPlanArriveTime(pathDetailList.get(1).getPlanArriveTime());
				transportPathEntity.setNextOrgCode(pathDetailList.get(1).getOrigOrgCode());
				transportPathEntity.setNextOrgCodeName(getNameByCode(pathDetailList.get(1).getOrigOrgCode()));
			}

			transportationPathDao.updateTransportPath(transportPathEntity);
			// modify by liangfuxiang 2013-6-17下午1:30:56 end;
			
		}
	}

	/** 
	* @Title: spliceFirstPathDetailEntity 
	* @Description: 拼接第一段走货路径
	* @param pathDetailList
	* @param object  设定文件 
	* @return void    返回类型 
	* @see spliceFirstPathDetailEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-20 上午9:24:25   
	* @throws 
	*/ 
	private List<PathDetailEntity> spliceFirstPathDetailEntity(List<PathDetailEntity> pathDetailList, String goodsNo) {

		List<PathDetailEntity> splicedPathDetailEntityList = null;

		// 分批配载，根据流水号来获取对应的走货路径
		if (StringUtils.isNotEmpty(goodsNo)) {
			// 获取相同流水号的走货路径
			List<PathDetailEntity> sameGoodsNoPathDetailList = getSameGoodsNoPathDetailList(pathDetailList, goodsNo);
			if (sameGoodsNoPathDetailList.size() == 1) {
				// pathDetailList中删除sameGoodsNoPathDetailList中唯一的走货路径路段
				pathDetailList = pathDetailListRemoveSame(pathDetailList, sameGoodsNoPathDetailList.get(0));
				// 拼接第一段路径
				splicedPathDetailEntityList = spliceFirstPathDetail(sameGoodsNoPathDetailList, goodsNo, splicedPathDetailEntityList);
				if (CollectionUtils.isEmpty(splicedPathDetailEntityList)) {
					pathDetailList.add(sameGoodsNoPathDetailList.get(0));
				}
				else {
					pathDetailList.add(splicedPathDetailEntityList.get(0));
					pathDetailList.add(splicedPathDetailEntityList.get(1));
				}
			}
			return pathDetailList;
		}
		else {
			if (pathDetailList.size() == 1) {
				// 拼接第一段走货路径
				splicedPathDetailEntityList = spliceFirstPathDetail(pathDetailList, goodsNo, splicedPathDetailEntityList);
			}

			if (CollectionUtils.isEmpty(splicedPathDetailEntityList)) {
				return pathDetailList;
			}
			else {
				return splicedPathDetailEntityList;
			}
		}

	}

	/**
	 * @Title: pathDetailListRemoveSame
	 * @Description: pathDetailList中删除sameGoodsNoPathDetailList中唯一的走货路径路段
	 * @param pathDetailList
	 * @param pathDetailEntity
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see pathDetailListRemoveSame
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-20 上午10:44:15
	 * @throws
	 */
	private List<PathDetailEntity> pathDetailListRemoveSame(List<PathDetailEntity> pathDetailList, PathDetailEntity pathDetailEntity) {

		for (int i = 0; i < pathDetailList.size(); i++) {
			// 删除相同的走货路径信息
			if (StringUtils.equalsIgnoreCase(pathDetailList.get(i).getPathDetailId(), pathDetailEntity.getPathDetailId())) {
				pathDetailList.remove(i);
				break;
			}
		}

		return pathDetailList;
	}

	/**
	 * 
	* @Title: spliceFirstPathDetail 
	* @Description: 拼接第一段走货路径
	* @param pathDetailList
	* @param goodsNo
	* @param splicedPathDetailEntityList
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see spliceFirstPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-20 上午10:35:27   
	* @throws
	 */
	private List<PathDetailEntity> spliceFirstPathDetail(List<PathDetailEntity> pathDetailList, String goodsNo, List<PathDetailEntity> splicedPathDetailEntityList) {
		
		// modify by liangfuxiang 2013-7-11上午9:38:28 begin ISSUE-3095
		WaybillEntity waybillEntity = queryWaybillEntityInfo(pathDetailList.get(0).getWaybillNo());
		
		splicedPathDetailEntityList = new ArrayList<PathDetailEntity>();
		
		PathDetailEntity firstPathDetailEntity = new PathDetailEntity();
		
		//当走货路由是从最初的开单部门出发的
		if (StringUtils.equalsIgnoreCase(pathDetailList.get(0).getOrigOrgCode(), waybillEntity.getReceiveOrgCode())) {
			firstPathDetailEntity.setOrigOrgCode(getCurrentOrgCodeFromWaybillEntity(waybillEntity));
		}
		//当走货路由不是从最初的起始位置出发的，此时，最初部门应该是开单时候的出发部门
		else{
			firstPathDetailEntity.setOrigOrgCode(waybillEntity.getReceiveOrgCode());
		}
		
		firstPathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
		firstPathDetailEntity.setWaybillNo(pathDetailList.get(0).getWaybillNo());
		firstPathDetailEntity.setGoodsNo(goodsNo);
		firstPathDetailEntity.setObjectiveOrgCode(pathDetailList.get(0).getOrigOrgCode());
		// 设置路段为1
		firstPathDetailEntity.setRouteNo(TransportPathConstants.CONSTONT_NUMBER_ONE);
		firstPathDetailEntity.setPlanStartTime(new Date());
		firstPathDetailEntity.setActualStartTime(new Date());
		// 默认为已离开
		firstPathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
		firstPathDetailEntity.setPlanArriveTime(new Date());
		firstPathDetailEntity.setActualArriveTime(new Date());
		firstPathDetailEntity.setBillingOrgCode(waybillEntity.getReceiveOrgCode());
		// 下一目的地
		firstPathDetailEntity.setNextDestOrgCode(pathDetailList.get(0).getObjectiveOrgCode());
		firstPathDetailEntity.setVehicleNo(TransportPathConstants.SET_NULL_STRING);
		firstPathDetailEntity.setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);
		firstPathDetailEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
		firstPathDetailEntity.setModifyStartTime(new Date());
		firstPathDetailEntity.setModifyArriveTime(new Date());
		firstPathDetailEntity.setNextArriveTime(new Date());
		//加入一个拼接的标识
		firstPathDetailEntity.setTruckDetailId(TransportPathConstants.ONLY_ONE_SPLICE_ONE);

		// 设置唯一的pathDetailList的信息,路段设置为2
		pathDetailList.get(0).setRouteNo(TransportPathConstants.SPLICEPATH_CURRENT_ROUTE_NO);

		splicedPathDetailEntityList.add(firstPathDetailEntity);
		splicedPathDetailEntityList.add(pathDetailList.get(0));
		// modify by liangfuxiang 2013-7-11上午9:38:46 end ISSUE-3095
		return splicedPathDetailEntityList;
	}

	/**
	 * @param goodsNo
	 * @Title: getSameGoodsNoPathDetailList
	 * @Description: 获取相同流水号的走货路径
	 * @param pathDetailList
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see getSameGoodsNoPathDetailList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-20 上午10:22:39
	 * @throws
	 */
	private List<PathDetailEntity> getSameGoodsNoPathDetailList(List<PathDetailEntity> pathDetailList, String goodsNo) {

		List<PathDetailEntity> sameGoodsNoPathDetailList = new ArrayList<PathDetailEntity>();

		for (int i = 0; i < pathDetailList.size(); i++) {
			if (StringUtils.equalsIgnoreCase(goodsNo, pathDetailList.get(i).getGoodsNo())) {
				sameGoodsNoPathDetailList.add(pathDetailList.get(i));
			}
		}

		return sameGoodsNoPathDetailList;
	}
	
	/**
	 * 
	* @Title: spliceTransportPath 
	* @Description:拼接走货路径
	* @param originalTransportPath
	* @param path
	* @return  设定文件 
	* @return String    返回类型 
	* @see spliceTransportPath
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-26 下午7:33:31   
	* @throws
	 */
	private String spliceTransportPath(String originalTransportPath, StringBuffer path) {
		//拼接走货路径
		if(StringUtils.isNotEmpty(originalTransportPath)){
			String[] pathSegments=originalTransportPath.split(TransportPathConstants.BACKSLASH);
			for(int k=0;k<pathSegments.length;k++){
				if(pathSegments[k].compareToIgnoreCase(path.toString())==0){
					//若原来已经存在路径了，则直接返回。
					return originalTransportPath;
				}
			}
			return originalTransportPath + TransportPathConstants.BACKSLASH + path.toString();
		}
		else{
			return path.toString();
		}
	}

	/**
	 * 调用基础资料接口得到路径detail
	 * 
	 * @param transportPathEntity
	 * @return
	 * @author liangfuxiang
	 * @date 2013-03-13
	 */
	private List<FreightRouteLineDto> getFreightRouteLineDtoList(String currentOrgCode, String destOrgCode, String transportModel) {

		// 新建走货路径线路列表
		List<FreightRouteLineDto> freightRouteLineDtoList = null;

		try {
			// 调用基础资料接口得到路径detail
			freightRouteLineDtoList = freightRouteService.queryFreightRouteBySourceTarget(currentOrgCode, destOrgCode, transportModel, new Date());
		}
		catch (Exception e) {
			// 日志记录
			logger.error("CalculateTransportPathService[getFreightRouteLineDtoList()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(currentOrgCode)
					+ TransportPathConstants.LEFTBRACKET + currentOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(transportModel) + TransportPathConstants.LEFTBRACKET + transportModel + TransportPathConstants.RIGHTBRACKET });
		}

		if (CollectionUtils.isEmpty(freightRouteLineDtoList)) {
			// 日志记录
			logger.error("CalculateTransportPathService[getFreightRouteLineDtoList()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(currentOrgCode)
					+ TransportPathConstants.LEFTBRACKET + currentOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(transportModel) + TransportPathConstants.LEFTBRACKET + transportModel + TransportPathConstants.RIGHTBRACKET });
		}

		// 返回列表
		return freightRouteLineDtoList;
	}

	/**
	 * 新增流水号走货路径的初始化 ..参数有效性验证
	 * 
	 * @param waybillNo
	 * @param goodsNos
	 * @param currentOrgCode
	 * @param destOrgCode
	 * @param transportModel
	 * @author liangfuxiang
	 * @date 2013-03-13
	 */
	//private void addNewTransportPathPramaterValidate(String waybillNo, List<String> goodsNos, String currentOrgCode, String destOrgCode, String transportModel) throws TfrBusinessException {
	private void addNewTransportPathPramaterValidate(String waybillNo, String currentOrgCode, String destOrgCode, String transportModel) throws TfrBusinessException {
		// 货运单号非空判断
		if (StringUtils.isEmpty(StringUtils.trim(waybillNo))) {
			// 日志记录
			logger.error("CalculateTransportPathService[addNewTransportPathPramaterValidate()]:"+TransportPathConstants.TRANSPORTPATH_WAYBILLNO_ISEMPTY);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_WAYBILLNO_ISEMPTY, BLANK_STRING);
		}

		// // 流水号非空判断
		// if (CollectionUtils.isEmpty(goodsNos)) {
		// // 日志记录
		// logger.error("CalculateTransportPathService[addNewTransportPathPramaterValidate()]:"+TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY);
		// // 抛出异常
		// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY, new Object[]{waybillNo});
		// }

		// 入库部门编号非空判断
		if (StringUtils.isEmpty(StringUtils.trim(currentOrgCode))) {
			// 日志记录
			logger.error("CalculateTransportPathService[addNewTransportPathPramaterValidate()]:"+TransportPathConstants.TRANSPORTPATH_CURRENTORGCODE_ISEMPTY);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CURRENTORGCODE_ISEMPTY, BLANK_STRING);
		}

		// 入 提货网点编号非空判断
		if (StringUtils.isEmpty(StringUtils.trim(destOrgCode))) {
			// 日志记录
			logger.error("CalculateTransportPathService[addNewTransportPathPramaterValidate()]:"+TransportPathConstants.TRANSPORTPATH_CURRENTORGCODE_ISEMPTY);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CURRENTORGCODE_ISEMPTY, BLANK_STRING);
		}

		// 运输性质非空判断
		if (StringUtils.isEmpty(StringUtils.trim(transportModel))) {
			// 日志记录
			logger.error("CalculateTransportPathService[addNewTransportPathPramaterValidate()]:"+TransportPathConstants.TRANSPORTPATH_TRANSPORTMODEL_ISEMPTY);
			// 抛出异常
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_TRANSPORTMODEL_ISEMPTY, BLANK_STRING);
		}
	}

	/**
	 * 移除选定货件的中转信息
	 * 
	 * @author liangfuxiang
	 * @date 2013-03-13
	 * @throws TfrBusinessException
	 */
	@Transactional
	public void deleteTransportPathByGoodsNos(String waybillNo, List<String> goodsNos) throws TfrBusinessException {

		// 参数有效性验证
		deleteTranPathByGoodsNosPramValidate(waybillNo, goodsNos);

		// 根据货运单号查询走货路径信息
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);

		// 走货路径非空
		if (null != transportPathEntity) {
			// 分批配载
			if (StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage())) {
				// 删除对应流水号走货路径信息
				deletePathInfos(transportPathEntity, goodsNos);
			}
		}
		else {
			// 日志记录:未找到走货路径
			logger.error("CalculateTransportPathService[deleteTransportPathByGoodsNos()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA);
			// 抛出异常
			// 未找到走货路径
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA , new Object[] { waybillNo });
		}
	}

	/**
	 * 
	 * @Title: deletePathInfos
	 * @Description: 删除对应流水号走货路径信息
	 * @param @param transportPathEntity
	 * @param @param goodsNos 设定文件
	 * @return void 返回类型
	 * @see deletePathInfos
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 013-03-13
	 * @throws
	 */
	private void deletePathInfos(TransportPathEntity transportPathEntity, List<String> goodsNos) {
		// 走货路径详情信息列表
		List<PathDetailEntity> pathDetailEntityList = new ArrayList<PathDetailEntity>();
		// 走货路径详情信息
		PathDetailEntity pathDetailEntity = null;
		// 设置各个走货路径详情信息
		for (String goodsNo : goodsNos) {
			// 新建走货路径详情信息对象
			pathDetailEntity = new PathDetailEntity();
			// 设置单号
			pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
			// 设置流水号
			pathDetailEntity.setGoodsNo(goodsNo);
			// 添加详细信息
			pathDetailEntityList.add(pathDetailEntity);
		}

		// 删除走货路径详情
		pathDetailDao.deleteListPathDetail(pathDetailEntityList);
	}

	/**
	 * 
	 * @Title: deleteTranPathByGoodsNosPramValidate
	 * @Description: 移除选定货件的中转信息...参数有效性验证
	 * @param @param waybillNo
	 * @param @param goodsNos
	 * @param @throws TfrBusinessException 设定文件
	 * @return void 返回类型
	 * @see deleteTranPathByGoodsNosPramValidate
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-03-13
	 * @throws
	 */
	private void deleteTranPathByGoodsNosPramValidate(String waybillNo, List<String> goodsNos) throws TfrBusinessException {

		// 货运单号非空判断
		if (StringUtils.isEmpty(StringUtils.trim(waybillNo))) {
			// 日志记录:单号为空
			logger.error("CalculateTransportPathService[deleteTranPathByGoodsNosPramValidate()]:"+TransportPathConstants.TRANSPORTPATH_WAYBILLNO_ISEMPTY);
			// 抛出异常
			// 单号为空
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_WAYBILLNO_ISEMPTY, BLANK_STRING);
		}

		// 流水号非空判断
		if (CollectionUtils.isEmpty(goodsNos)) {
			// 日志记录:流水号为空
			logger.error("CalculateTransportPathService[deleteTranPathByGoodsNosPramValidate()]:"+TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY);
			// 抛出异常
			// 流水号为空
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY, new Object[]{waybillNo});
		}
	}

	/**
	 * @param transportPathEntity 
	 * 
	 * @Title: alterDetailforModify
	 * 
	 * @Description:调整走货路径
	 * 
	 * @param waybillNo
	 * 
	 * @param serialNo
	 * 
	 * @param nowOrgCode
	 * 
	 * @param destOrgCode
	 * 
	 * @param billingOrgCode
	 * 
	 * @param model
	 * 
	 * @param TfrBusinessException 设定文件
	 * 
	 * @return void 返回类型
	 * 
	 * @see alterDetailforModify
	 * 
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * 
	 * @version: 2013-3-19 下午5:06:19
	 * 
	 * @throws
	 */
	private void alterDetailforModify(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String billingOrgCode, String model, TransportPathEntity transportPathEntity) throws TfrBusinessException {
		// 路段号
		int routeNo = 0;
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建走货路径详细信息列表
		List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
		// 新建走货路径详细信息列表-原信息
		List<PathDetailEntity> oldPathDetailList;
		// 设置运载单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 设置流水号
		pathDetailEntity.setGoodsNo(serialNo);
		// 找到目标部门为现部门的一条数据
		pathDetailEntity.setObjectiveOrgCode(nowOrgCode);
		// 查询走货路径详细信息列表
		List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
		
		boolean pathEntityQueryed = false;
		
		// 走货路径详细信息为空
		if (list.size() == 0) {
			// 走货路径详细信息为空
			pathDetailEntity = null;
			// 走货路径详细信息不唯一
		}
		else if (list.size() > 1) {
			// 异常：
			// 找不到走货路径
			logger.error("CalculateTransportPathService[alterDetailforModify()]" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { waybillNo, nowOrgCode, serialNo });
		}
		else {
			// 赋值
			BeanUtils.copyProperties(list.get(0), pathDetailEntity);
		}
		// 走货路径详细信息非空
		if (null != pathDetailEntity) {
			
			pathEntityQueryed = true;
			
			// 设置路段号
			routeNo = Integer.parseInt(pathDetailEntity.getRouteNo());
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.listQueryNextStep(pathDetailEntity);
		}
		else {
			// 表示没有之前的条目,则需要把所有路径都进行删除
			pathDetailEntity = new PathDetailEntity();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置流水号
			pathDetailEntity.setGoodsNo(serialNo);
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		}
		// 走货路径线路列表
		List<FreightRouteLineDto> freightRouteLineDto;
		try {
			// 调用基础资料接口得到路径detail 从现部门之后
			freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, model, new Date());
		}
		catch (Exception e) {
			// 异常：
			// 找不到走货路径
			logger.error("CalculateTransportPathService[alterDetailforModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
					+ origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
		}
		// 走货路径线路为空
		if (CollectionUtils.isEmpty(freightRouteLineDto)) {
			// 调用基础资料接口得到路径detail 从现部门之后
			try {
				// 汽运短途
				freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_ROAD_FREIGHT, new Date());

				// 走货路径线路为空
				if (CollectionUtils.isEmpty(freightRouteLineDto)) {
					// 精准城运
					freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT, new Date());
				}
			}
			catch (Exception e) {
				// 异常：
				// 找不到走货路径
				logger.error("CalculateTransportPathService[alterDetailforModify()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
						+ origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
						+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
						+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
						+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
			}
		}
		else {

			// modify by liangfuxiang 2013-4-24下午5:48:28 begin BUG-7600
			if(pathEntityQueryed){
				// 将老路径，最后一站未变更的路径的下一部门设置为目标部门
				if (StringUtils.isNotEmpty(pathDetailEntity.getObjectiveOrgCode())) {
					pathDetailEntity.setNextDestOrgCode(freightRouteLineDto.get(0).getTargetCode());
					pathDetailEntity.setNextArriveTime(freightRouteLineDto.get(0).getArriveDate());
					pathDetailDao.updatePathDetail(pathDetailEntity);
				}
				// modify by liangfuxiang 2013-4-24下午5:48:57 end;
			}

			// 赋值
			for (int i = 0; i < freightRouteLineDto.size(); i++) {
				// 新建
				newPathDetailList.add(new PathDetailEntity());
				// 设置出发部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
					// 异常：
					logger.error("CalculateTransportPathService[alterDetailforModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
				}
				// 设置出发部门
				newPathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
				// 设置到达部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
					// 异常：
					// 找不到走货路径目的地
					logger.error("CalculateTransportPathService[alterDetailforModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
							TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
				}
				newPathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
				// 设置下一到达部门
				if ((i + 1) < freightRouteLineDto.size()) {
					// 设置下一目的地
					newPathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
					// 设置到达时间
					newPathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
				}
				// 设置开单部门
				newPathDetailList.get(i).setBillingOrgCode(billingOrgCode);
				// 重新确定ourteNo
				newPathDetailList.get(i).setRouteNo(String.valueOf(routeNo + i + 1));
				// 设置计划出发时间
				if (null == freightRouteLineDto.get(i).getLeaveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// 异常：
						// 找不到出发时间
						logger.error("CalculateTransportPathService[alterDetailforModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 根据条件设置出发时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
						}
						else {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(new Date());
						}
					}
				}
				// 设置计划出发时间
				newPathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置计划到达时间
				if (null == freightRouteLineDto.get(i).getArriveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// 异常：
						// 找不到到达时间
						logger.error("CalculateTransportPathService[alterDetailforModify()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 上一路段到达时间
						long beforeArrive = (new Date()).getTime();
						// 到达时间非空
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 上一路段到达时间
							beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
						}
						// 分钟
						long min = freightRouteLineDto.get(i).getAging();
						// 到达日期
						Date arrive = new Date(sixtyThousand * min + beforeArrive);
						// 设置到达日期
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
				}
				newPathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置调整出发时间
				newPathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置调整到达时间
				newPathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置是否调整时间
				newPathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置其他基本信息
				newPathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
				// 设置单号
				newPathDetailList.get(i).setWaybillNo(waybillNo);
				// 设置流水号
				newPathDetailList.get(i).setGoodsNo(serialNo);
				// 更新状态
				newPathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			}
			// 原路径信息非空
			if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
				// 批量删除
				pathDetailDao.deleteListPathDetail(oldPathDetailList);
			}
			// 新路径非空
			if (newPathDetailList.size() > 0) {
				
				// modify by liangfuxiang 2013-6-18上午10:57:57 begin
				//排序
				newPathDetailList=sortPathDetailListByGoodsNoAndRouteNo(newPathDetailList);
				//入库
				newPathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
				newPathDetailList.get(0).setActualArriveTime(new Date());
				newPathDetailList.get(0).setActualStartTime(new Date());
				
				String beforeAction = transportPathEntity.getAction();
				transportPathEntity.setBeforeAction(beforeAction);
				transportPathEntity.setAction(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
				if(newPathDetailList.size()>1){
					transportPathEntity.setPlanStartTime(newPathDetailList.get(1).getPlanStartTime());
					transportPathEntity.setPlanArriveTime(newPathDetailList.get(1).getPlanArriveTime());
					transportPathEntity.setNextOrgCode(newPathDetailList.get(1).getOrigOrgCode());
					transportPathEntity.setNextOrgCodeName(getNameByCode(newPathDetailList.get(1).getOrigOrgCode()));
				}
				// modify by liangfuxiang 2013-6-18上午10:58:03 end;
				
				// 批量增加
				pathDetailDao.addListPathDetail(newPathDetailList);
			}
		}
	}

	/**
	 * @param transportPathEntity 
	 * 
	* @Title: alterDetailforAmendmentBill 
	* @Description: 变更修改走货路径--更改单专用接口
	* @param waybillNo
	* @param serialNo
	* @param nowOrgCode
	* @param destOrgCode
	* @param billingOrgCode
	* @param model
	* @throws TfrBusinessException  设定文件 
	* @return void    返回类型 
	* @see alterDetailforAmendmentBill
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午4:56:45   
	* @throws
	 */
	private void alterDetailforAmendmentBill(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String billingOrgCode, String model, TransportPathEntity transportPathEntity) throws TfrBusinessException {
		// 路段号
		int routeNo = 0;
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建走货路径详细信息列表
		List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
		// 新建走货路径详细信息列表-原信息
		List<PathDetailEntity> oldPathDetailList;
		// 设置运载单号
		pathDetailEntity.setWaybillNo(waybillNo);
		// 设置流水号
		pathDetailEntity.setGoodsNo(serialNo);
		// 找到目标部门为现部门的一条数据
		pathDetailEntity.setObjectiveOrgCode(nowOrgCode);
		// 查询走货路径详细信息列表
		List<PathDetailEntity> list = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
		
		// modify by liangfuxiang 2013-7-26下午2:15:46 begin BUG-47421
		
		//判断对象pathDetailEntity是否为查询获取到的。
		boolean pathEntityQueryed = false;
		
		// 走货路径详细信息为空
		if (list.size() == 0) {
			// 走货路径详细信息为空
			pathDetailEntity = null;
			// 走货路径详细信息不唯一
		}
		else if (list.size() > 1) {
			// 异常：
			// 找不到走货路径
			logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { waybillNo, nowOrgCode, serialNo });
		}
		else {
			// 赋值
			BeanUtils.copyProperties(list.get(0), pathDetailEntity);
		}
		// 走货路径详细信息非空
		if (null != pathDetailEntity) {
			
			pathEntityQueryed = true;
			
			// 设置路段号
			routeNo = Integer.parseInt(pathDetailEntity.getRouteNo());
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.listQueryNextStep(pathDetailEntity);
		}
		else {
			// 表示没有之前的条目,则需要把所有路径都进行删除
			pathDetailEntity = new PathDetailEntity();
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);
			// 设置流水号
			pathDetailEntity.setGoodsNo(serialNo);
			// 把所有查询出来的条目都放到老数据中等待删除
			oldPathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
		}
		// 走货路径线路列表
		List<FreightRouteLineDto> freightRouteLineDto = null;
		try {
			// 调用基础资料接口得到路径detail 从现部门之后
			freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, model, new Date());
		}
		catch (Exception e) {
			// 异常：
			// 找不到走货路径
			logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
					+ origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
					+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
					+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
		}
		// 走货路径线路为空
		if (CollectionUtils.isEmpty(freightRouteLineDto)) {
			// 调用基础资料接口得到路径detail 从现部门之后
			try {
				// 汽运短途
				freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_ROAD_FREIGHT, new Date());

				// 走货路径线路为空
				if (CollectionUtils.isEmpty(freightRouteLineDto)) {
					// 精准城运
					freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT, new Date());
				}
			}
			catch (Exception e) {
				// 异常：
				// 找不到走货路径
				logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget
						+ origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
						+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME+getNameByCode(destOrgCode)
						+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
						+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
			}
		}
		else {
			
			if (pathEntityQueryed) {
				// 将老路径，最后一站未变更的路径的下一部门设置为目标部门
				if (StringUtils.isNotEmpty(pathDetailEntity.getObjectiveOrgCode())) {
					pathDetailEntity.setNextDestOrgCode(freightRouteLineDto.get(0).getTargetCode());
					pathDetailEntity.setNextArriveTime(freightRouteLineDto.get(0).getArriveDate());
					pathDetailDao.updatePathDetail(pathDetailEntity);
				}
			}
			// 赋值
			for (int i = 0; i < freightRouteLineDto.size(); i++) {
				// 新建
				newPathDetailList.add(new PathDetailEntity());
				// 设置出发部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getSourceCode())) {
					// 异常：
					logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME+getOrgNameAndCode(nowOrgCode)+TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME });
				}
				// 设置出发部门
				newPathDetailList.get(i).setOrigOrgCode(freightRouteLineDto.get(i).getSourceCode());
				// 设置到达部门
				if (StringUtils.isEmpty(freightRouteLineDto.get(i).getTargetCode())) {
					// 异常：
					// 找不到走货路径目的地
					logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+queryFreightRouteBySourceTarget);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME+getOrgNameAndCode(nowOrgCode)+TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME });
				}
				newPathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDto.get(i).getTargetCode());
				// 设置下一到达部门
				if ((i + 1) < freightRouteLineDto.size()) {
					// 设置下一目的地
					newPathDetailList.get(i).setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
					// 设置到达时间
					newPathDetailList.get(i).setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
				}
				// 设置开单部门
				newPathDetailList.get(i).setBillingOrgCode(billingOrgCode);
				// 重新确定ourteNo
				newPathDetailList.get(i).setRouteNo(String.valueOf(routeNo + i + 1));
				// 设置计划出发时间
				if (null == freightRouteLineDto.get(i).getLeaveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// 异常：
						// 找不到出发时间
						logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 根据条件设置出发时间
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
						}
						else {
							// 设置出发时间
							freightRouteLineDto.get(i).setLeaveDate(new Date());
						}
					}
				}
				// 设置计划出发时间
				newPathDetailList.get(i).setPlanStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置计划到达时间
				if (null == freightRouteLineDto.get(i).getArriveDate()) {
					// 综合管理-线路-始发线路
					// 综合管理-线路-到达线路
					// 综合管理-线路-中转到中转线路-专线
					if (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
							|| StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
							|| (StringUtils.equals(freightRouteLineDto.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDto.get(i)
									.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
						// 异常：
						// 找不到到达时间
						logger.error("CalculateTransportPathService[alterDetailforAmendmentBill()]:"+TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+queryFreightRouteBySourceTarget);
						// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
						throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDto.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDto.get(i).getTargetCode()) });
					}
					else {
						// 上一路段到达时间
						long beforeArrive = (new Date()).getTime();
						// 到达时间非空
						if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
							// 上一路段到达时间
							beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
						}
						// 分钟
						long min = freightRouteLineDto.get(i).getAging();
						// 到达日期
						Date arrive = new Date(sixtyThousand * min + beforeArrive);
						// 设置到达日期
						freightRouteLineDto.get(i).setArriveDate(arrive);
					}
				}
				newPathDetailList.get(i).setPlanArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置调整出发时间
				newPathDetailList.get(i).setModifyStartTime(freightRouteLineDto.get(i).getLeaveDate());
				// 设置调整到达时间
				newPathDetailList.get(i).setModifyArriveTime(freightRouteLineDto.get(i).getArriveDate());
				// 设置是否调整时间
				newPathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
				// 设置其他基本信息
				newPathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
				// 设置单号
				newPathDetailList.get(i).setWaybillNo(waybillNo);
				// 设置流水号
				newPathDetailList.get(i).setGoodsNo(serialNo);
				// 更新状态
				newPathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			}
			// 原路径信息非空
			if (CollectionUtils.isNotEmpty(oldPathDetailList)) {
				// 批量删除
				pathDetailDao.deleteListPathDetail(oldPathDetailList);
			}
			
			// modify by liangfuxiang 2013-7-26下午2:29:22 begin BUG-47421
			// 未查询到老的路径
			if (!pathEntityQueryed && newPathDetailList.size() == 1) {
				// 需要拼接一段走货路径
				List<PathDetailEntity> splicePathDetailEntityList = null;
				// 拼接
				newPathDetailList = spliceFirstPathDetail(newPathDetailList, serialNo, splicePathDetailEntityList);
			}
			
			// 新路径非空
			if (newPathDetailList.size() > 0) {
				//排序
				//newPathDetailList=sortPathDetailListByGoodsNoAndRouteNo(newPathDetailList);
				
				// 批量增加
				pathDetailDao.addListPathDetail(newPathDetailList);
			}
		}
	}

	
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#migrateTransportPathData()
	 */

	@Override
	@Transactional
	public void migrateTransportPathData() throws TfrBusinessException{
		
		try {
			//直接通过存储过程进行处理
			Map<String,String> params=new HashMap<String,String>();
			//签收时间间隔
			params.put(TransportPathConstants.SIGNINTIMEINTERVAL, signInTimeInterval);
			//未签收时间间隔
			//主要针对交接单整车上业务处理，走货路径不会更改为签收状态的时间间隔的处理
			params.put(TransportPathConstants.UNSIGNINTIMEINTERVAL, unsignInTimeInterval);
			//走货路径无效的时间间隔(走货路径主表有数据，明细表无数据。在签收表查询也不存在，一个星期之后，移除。)
			params.put(TransportPathConstants.INVALIDTIMEINTERVAL, invalidTimeInterval);
			transportationPathDao.migrateTransportPathData(params);
		}
		catch (Exception e) {
			logger.error("CalculateTransportPathService[migrateTransportPathData()]"+e.getMessage());
			throw new TfrBusinessException(e.getMessage());
		}

	}
	  
	/*
	 * (non-Javadoc)
	 *  存在增删改查的操作 -- 调用的时候，注意回滚
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#getNextOrgAndTimeForDetailResult(java.lang.String, java.lang.String, java.lang.String)
	 */
	@Override
	public FeedbackDto getNextOrgAndTimeForDetailResult(String waybillNo, String goodsNo, String correntOrgCode) throws TfrBusinessException {
		
		// 新建走货路径详细信息对象
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 新建上一走货路径详细信息对象
		PathDetailEntity beforePathDetailEntity = new PathDetailEntity();
		// 先查是否分批配载
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 以本部门为出发部门查询
		FeedbackDto feedback = new FeedbackDto();
		// 如果条目不为空
		if (null != transportPathEntity) {
			// 是分批配载
			if (StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 使用货件号进行查询
				pathDetailEntity.setGoodsNo(goodsNo);
				// 设置上一走货路径详细信息货件号
				beforePathDetailEntity.setGoodsNo(goodsNo);
			}
			// 设置运载单号
			pathDetailEntity.setWaybillNo(waybillNo);

			// 当只根据运单号查询走货路径信息,查看走货路径是否存在.
			List<PathDetailEntity> allPathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
			// 若返回值为空，则表示明细表中午走货路径详细信息
			if (CollectionUtils.isEmpty(allPathDetailList)) {	
				// 不存在走货路径
				feedback.setResult(TransportPathConstants.STATUS_TRANPATHDETAILNULL);
			}
			else {
				// 设置当前部门
				pathDetailEntity.setOrigOrgCode(correntOrgCode);
				// 查询明细条目
				List<PathDetailEntity> pathDetailList = pathDetailDao.pathDetailNotReleave(pathDetailEntity);
				// 以本部门为到达部门查询
				beforePathDetailEntity.setWaybillNo(waybillNo);
				// 设置目标部门
				beforePathDetailEntity.setObjectiveOrgCode(correntOrgCode);
				// 查询明细条目
				List<PathDetailEntity> beforePathDetailList = pathDetailDao.pathDetailNotReleave(beforePathDetailEntity);
				// 如果没有条目则返回无条目 这时可能无条目,所以不抛错误
				if (pathDetailList.size() == 0 && beforePathDetailList.size() == 0) {
					// modify by liangfuxiang 2013-7-16下午4:17:03 begin BUG-42167 线路问题 对于当前部门(correntOrgCode)为最终目的地,走货路径状态为RELEAVE的，查询不到走货路径。
					// 当前部门不在走货路径上
					// feedback.setResult(TransportPathConstants.STATUS_CURRENTORGNOPATHDETAIL);
					feedback = getDestOrgCodePathDetailInfo(waybillNo, correntOrgCode, pathDetailEntity, transportPathEntity, feedback, TransportPathConstants.STATUS_CURRENTORGNOPATHDETAIL);
					// modify by liangfuxiang 2013-7-16下午4:26:46 end;
				}
				else if (pathDetailList.size() == 0 && beforePathDetailList.size() != 0) {
					// 当前部门在走货路径上，但没有下一段走货路径
					feedback.setResult(TransportPathConstants.STATUS_NODATA);
				}
				else if (pathDetailList.size() == 1) {
					// 在走货路径上且有下一段走货路径
					feedback.setResult(TransportPathConstants.STATUS_RIGHT);
					// 设置走货路径详细信息
					feedback.setPathDetailEntity(pathDetailList.get(0));
				}
				else {
					// modify by liangfuxiang 2013-6-14下午7:19:09 begin 当有多条时，将要入库之前的无效的走货路径状态置为RELEAVE,保证目前可以返回一条正确的数据
					// logger.error("CalculateTransportPathService[getNextOrgAndTimeForDetailResult()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE);
					// // 如果大于一条则返回错误
					// throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_DETAILMORETHANONE_GLOB, new Object[] { waybillNo, correntOrgCode,
					// TransportPathConstants.BLANK_SPACE_STRING });
					//dealWithNonUniquenessPathDetailList(pathDetailList, transportPathEntity, correntOrgCode);
					feedback.setResult(TransportPathConstants.STATUS_RIGHT);
					// 设置走货路径详细信息
					feedback.setPathDetailEntity(dealMaxRouteNoPathDetail(pathDetailList,transportPathEntity,correntOrgCode));
					// modify by liangfuxiang 2013-6-14下午7:19:23 end;
				}
			}
		}
		else {
			logger.warn("CalculateTransportPathService[getNextOrgAndTimeForDetailResult()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH);
			// 不存在在走货路径
			feedback.setResult(TransportPathConstants.STATUS_TRANPATHNULL);
		}

		return feedback;
	}

	/**
	 * @param wrongCode 
	 * 
	* @Title: getDestOrgCodePathDetailInfo 
	* @Description: 查询目的站和当前部门相同的路径信息
	* @param waybillNo
	* @param correntOrgCode
	* @param pathDetailEntity
	* @param transportPathEntity
	* @param feedback
	* @return  设定文件 
	* @return FeedbackDto    返回类型 
	* @see getDestOrgCodePathDetailInfo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-16 下午4:57:22   
	* @throws
	 */
	private FeedbackDto getDestOrgCodePathDetailInfo(String waybillNo, String correntOrgCode, PathDetailEntity pathDetailEntity, TransportPathEntity transportPathEntity, FeedbackDto feedback, int wrongCode) {
		// 输入的当前部门就是目的地
		if (correntOrgCode.equalsIgnoreCase(transportPathEntity.getDestOrgCode())) {
			// 查询走货路径，最大路段的路段信息，判断目标部门与当前部门是否相同
			PathDetailEntity tempPathDetailEntity = new PathDetailEntity();
			tempPathDetailEntity.setWaybillNo(waybillNo);
			tempPathDetailEntity.setGoodsNo(pathDetailEntity.getGoodsNo());
			// 查询最后一段走货路径
			PathDetailEntity lastPathDetailEntity = queryLastPathDetailEntity(tempPathDetailEntity);
			// 非空，且是走货路径的目的站---则说明未最后一段走货路径
			if (null != lastPathDetailEntity && StringUtils.equalsIgnoreCase(lastPathDetailEntity.getObjectiveOrgCode(), correntOrgCode)) {
				feedback.setPathDetailEntity(lastPathDetailEntity);
				feedback.setResult(TransportPathConstants.STATUS_RIGHT);
			}
			else {
				// 当前部门不在走货路径上
				feedback.setResult(wrongCode);
			}
		}
		else {
			// 当前部门不在走货路径上
			feedback.setResult(wrongCode);
		}
		return feedback;
	}

	/** 
	* @Title: queryLastPathDetailEntity 
	* @Description: 查询最后一段走货路径
	* @param tempPathDetailEntity
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see queryLastPathDetailEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-16 下午4:47:18   
	* @throws 
	*/ 
	private PathDetailEntity queryLastPathDetailEntity(PathDetailEntity tempPathDetailEntity) {
		
		// 查询最终的走货路径
		List<PathDetailEntity> lastPathDetailEntityList = pathDetailDao.queryLastPathDetailEntity(tempPathDetailEntity);

		// 非空，且只有一条
		if (CollectionUtils.isNotEmpty(lastPathDetailEntityList) && lastPathDetailEntityList.size() == 1) {
			return lastPathDetailEntityList.get(0);
		}
		else {
			logger.warn("CalculateTransportPathService[queryLastPathDetailEntity()]:" + TransportPathConstants.LAST_PATHDETAIL_EXCEPTION + tempPathDetailEntity.getWaybillNo());
			return null;
		}
	}

	/** 
	* @Title: getMaxRouteNoPathDetail 
	* @Description: 设置走货路径详细信息
	* @param pathDetailList
	* @param transportPathEntity
	* @param correntOrgCode
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see getMaxRouteNoPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-14 下午8:59:01   
	* @throws 
	*/ 
	private PathDetailEntity dealMaxRouteNoPathDetail(List<PathDetailEntity> pathDetailList, TransportPathEntity transportPathEntity, String correntOrgCode) {
		
		// 按照路段号排序
		pathDetailList = sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);

		// 获取最大路段的信息
		PathDetailEntity maxRouteNoPathDetailEntity = new ArrayList<PathDetailEntity>(pathDetailList.subList(pathDetailList.size() - 1, pathDetailList.size())).get(0);

		//要修改状态的走货路径明细信息
		List<PathDetailEntity> newPathDetailEntityList = new ArrayList<PathDetailEntity>();

		// 获取应当置为已离开的走货路径明细信息
		List<PathDetailEntity> releavePathDetailList = new ArrayList<PathDetailEntity>(pathDetailList.subList(0, pathDetailList.size() - 1));
		PathDetailEntity releavePathDetailEntity = null;
		for (int i = 0; i < releavePathDetailList.size(); i++) {
			releavePathDetailEntity = releavePathDetailList.get(i);
			// 已离开
			releavePathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			newPathDetailEntityList.add(releavePathDetailEntity);
		}

		// 更新走货路径明细信息
		/**
		 * modify by songjie on 2013-08-14 begin
		 */
//		pathDetailDao.updateListPathDetail(pathDetailList);
		pathDetailDao.updateListPathDetail(newPathDetailEntityList);
		/**
		 * modify by songjie on 2013-08-14 end
		 */

		// 更新走货路径主表信息
		// 设置本部门
		transportPathEntity.setCurrentOrgCode(correntOrgCode);
		// 设置下一部门
		transportPathEntity.setNextOrgCode(maxRouteNoPathDetailEntity.getNextDestOrgCode());
		// 更新主表
		transportationPathDao.updateTransportPath(transportPathEntity);

		return maxRouteNoPathDetailEntity;
	}

	/*
	 * BUG-8208  中转对无走货路径货物加入处理
	 * 
	 * 1:新增流水号的时候，如果生成的走货路径只有一段，则需要前面在补一段（从开单部门，到当前库存部门，状态为RELEAVE）， 
     *  目的是，如果只有一段走货路径，无法打标签 
     * 2:注意如果是一整票无走货路径，可以先生成一个未分批配载的走货路径，如果是某一个流水号无走货路径，则单独生成着一个流水号的走货路径。 
     * 3：完全生成新的走货路径的时候，如果新增失败，可以考虑在走货路径主表生成一条记录，这样可以通过重新生成走货路径界面去再次生成走货路径。
     * 4：确保走货路径主表，运单号唯一有一条记录
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#createTransportPathForStorage(com.deppon.foss.module.transfer.scheduling.api.shared.domain.
	 * TransportPathEntity)
	 */  
	@Override
	public void createTransportPathForStorage(String waybillNo, String currentOrgCode, String serialNo) throws TfrBusinessException {

		waybillNo = StringUtils.trim(waybillNo);
		currentOrgCode = StringUtils.trim(currentOrgCode);
		serialNo = StringUtils.trim(serialNo);
		// 判断参数有效性
		verifyParameters(waybillNo, currentOrgCode);
		// 查询走货路径主表，查看当前运单是否存在走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 若为空，则生成全新的未分批配载的走货路径
		if (null == transportPathEntity) {
			
			// modify by liangfuxiang 2013-7-29下午2:22:14 begin BUG-45448
			// 为防止主表中无对应运单的走货路径，而明晰中有这样的脏数据。对走货路径明细表进行一个删除
			deletePathDetailList(waybillNo, null, null);
			// modify by liangfuxiang 2013-7-29下午2:23:22 end;
			// 创建全新的走货路径信息
			createBrandNewTransportPath(waybillNo, currentOrgCode);
			
		}
		// 说明此货运单在走货主表信息中存在走货路径,判断走货路径详情表中是否存在走货路径信息
		else {

			// modify by liangfuxiang 2013-7-2下午7:31:17 begin
			// 当前部门和目的部门相同
			if (StringUtils.equalsIgnoreCase(currentOrgCode, transportPathEntity.getDestOrgCode())) {
				dealTransportPathSameOrgCode(waybillNo, currentOrgCode, serialNo, transportPathEntity);
			}
			else {
				// 创建走货路径详细信息
				createNewTransportPathDetail(transportPathEntity, waybillNo, currentOrgCode, serialNo);
				// 更新主表信息
				updateTransportPathEntity(transportPathEntity, currentOrgCode);
			}
			// modify by liangfuxiang 2013-7-2下午7:31:26 end;
		}
	}

	/** 
	* @Title: deleteListPathDetailList 
	* @Description: 删除走货路径明细信息
	* @param waybillNo
	* @param object  设定文件 
	* @return void    返回类型 
	* @see deleteListPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-29 下午2:27:03   
	* @throws 
	*/ 
	private void deletePathDetailList(String waybillNo, String goodsNo,String routeNo) {
		PathDetailEntity deletePathDetailEntity = new PathDetailEntity();
		deletePathDetailEntity.setWaybillNo(waybillNo);
		deletePathDetailEntity.setGoodsNo(goodsNo);
		deletePathDetailEntity.setRouteNo(routeNo);
		pathDetailDao.deletePathDetailList(deletePathDetailEntity);
	}

	/**
	 * 
	* @Title: dealTransportPathSameOrgCode 
	* @Description:当前部门和目的部门相同
	* @param waybillNo
	* @param currentOrgCode
	* @param serialNo
	* @param transportPathEntity  设定文件 
	* @return void    返回类型 
	* @see dealTransportPathSameOrgCode
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-2 下午5:35:14   
	* @throws
	 */
	private void dealTransportPathSameOrgCode(String waybillNo, String currentOrgCode, String serialNo, TransportPathEntity transportPathEntity) {
		// 根据运单生成走货路径，当前部门之前的状态全部默认为releave
		// 获取运单信息
		WaybillEntity waybillEntity = queryWaybillEntityInfo(waybillNo);
		// 生成走货路径明细
		List<PathDetailEntity> pathDetailEntityReleaveList = createPathDetailListSameOrgCode(serialNo, transportPathEntity, waybillEntity);

		// modify by liangfuxiang 2013-7-26上午10:27:48 begin 将老路径进行拼接
		List<PathDetailEntity> maxPathDetailEntityList = queryMaxRouteNoPathDetailEntityWithObjOrgCodeList(currentOrgCode, serialNo, transportPathEntity);

		if (CollectionUtils.isNotEmpty(maxPathDetailEntityList)) {
			// 获取最大路段号
			String maxRouteNo = maxPathDetailEntityList.get(maxPathDetailEntityList.size() - 1).getRouteNo();
			// 查询要保留的走货路径信息
			List<PathDetailEntity> needSpliceOldPathList = queryBeforePathDetailList(waybillNo, serialNo, transportPathEntity.getIfPartialStowage(), maxRouteNo);
			//非空
			if(CollectionUtils.isNotEmpty(needSpliceOldPathList)){
				//将所有状态均置为RELEAVE
				for(int i=0;i<needSpliceOldPathList.size();i++){
					needSpliceOldPathList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
				}
				// 拼接老路径
				pathDetailEntityReleaveList = connectOldPathDetailList(pathDetailEntityReleaveList, needSpliceOldPathList);
			}
		}

		// 除原走货路径明细
		deleteOldPathDetailList(waybillNo, serialNo, transportPathEntity);
		// modify by liangfuxiang 2013-7-26上午10:28:13 end;

		// 更新主表信息
		updateTransportPath(currentOrgCode, transportPathEntity, pathDetailEntityReleaveList);

		// 增加新的走货路径
		pathDetailDao.addListPathDetail(pathDetailEntityReleaveList);
	}

	/**
	 * @param maxRouteNo  
	* @Title: queryBeforePathDetailList 
	* @Description: 查询指定目标部门和路段号的之前的部门，包含当前路段号
	* @param waybillNo
	* @param currentOrgCode
	* @param serialNo
	* @param ifPartialStowage
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see queryBeforePathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-26 上午11:10:14   
	* @throws 
	*/ 
	private List<PathDetailEntity> queryBeforePathDetailList(String waybillNo, String serialNo, String ifPartialStowage, String maxRouteNo) {
		
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		
		pathDetailEntity.setWaybillNo(waybillNo);
		//若分批配载，则设置路段号
		if(StringUtils.equalsIgnoreCase(ifPartialStowage, TransportPathConstants.PARTIALSTOWAGE)){
			pathDetailEntity.setGoodsNo(serialNo);
		}
		//设置路段号
		pathDetailEntity.setRouteNo(maxRouteNo);
		//查询指定目标部门和路段号的之前的部门，包含当前路段号
		return pathDetailDao.queryBeforePathDetailList(pathDetailEntity);
	}

	/**
	 * @Title: queryNeedsOldSplicePathDetailList
	 * @Description: 查询需要拼接的老路径
	 * @param currentOrgCode
	 * @param serialNo
	 * @param transportPathEntity
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see queryNeedsOldSplicePathDetailList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-26 上午10:39:47
	 * @throws
	 */
	private List<PathDetailEntity> queryMaxRouteNoPathDetailEntityWithObjOrgCodeList(String currentOrgCode, String serialNo, TransportPathEntity transportPathEntity) {

		PathDetailEntity pathDetailEntity = new PathDetailEntity();

		pathDetailEntity.setObjectiveOrgCode(currentOrgCode);
		pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());

		// 若分批配载，则设置流水号
		if (StringUtils.equalsIgnoreCase(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
			pathDetailEntity.setGoodsNo(serialNo);
		}
		
		//获取指定目标部门的最大走货路径
		return queryMaxRouteNoPathDetailEntityWithObjOrgCode(pathDetailEntity);
	}

	/**
	 * 
	* @Title: updateTransportPath 
	* @Description: 更新主表信息
	* @param currentOrgCode
	* @param transportPathEntity
	* @param pathDetailEntityReleaveList
	* @param pathDetailEntity  设定文件 
	* @return void    返回类型 
	* @see updateTransportPath
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-2 下午5:39:22   
	* @throws
	 */
	private void updateTransportPath(String currentOrgCode, TransportPathEntity transportPathEntity, List<PathDetailEntity> pathDetailEntityReleaveList) {
		
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		pathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
		//确定主表拼接的路径
		pathDetailEntity.setGoodsNo(null);
		List<PathDetailEntity> leftPathDetailEntityList= pathDetailDao.queryPathDetailList(pathDetailEntity);
		//当明细表中，无对应的走货路径信息，则走货路径为全新的，否则为老的拼接新的
		if(CollectionUtils.isEmpty(leftPathDetailEntityList)){
			//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
			//transportPathEntity.setTransportPath(TransportPathConstants.BLANK_SPACE_STRING);
		}
		//初始化主表信息
		transportPathEntity.setBeforeAction(transportPathEntity.getAction());
		transportPathEntity.setAction(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
		transportPathEntity.setNextOrgCode(null);
		transportPathEntity.setNextOrgCodeName(null);
		transportPathEntity.setCurrentOrgCode(currentOrgCode);
		
		//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
		//拼接
		//transportPathEntity.setTransportPath(splicePathString(pathDetailEntityReleaveList,transportPathEntity));
		transportationPathDao.updateTransportPath(transportPathEntity);
	}

	/**
	 * 
	* @Title: deleteOldPathDetailList 
	* @Description: 删除原走罗路径明细
	* @param waybillNo
	* @param serialNo
	* @param transportPathEntity
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see deleteOldPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-2 下午5:38:03   
	* @throws
	 */
	private void deleteOldPathDetailList(String waybillNo, String serialNo, TransportPathEntity transportPathEntity) {
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		//删除走货路径明细总对应明细信息
		pathDetailEntity.setWaybillNo(waybillNo);
		if(StringUtils.equalsIgnoreCase(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)){
			pathDetailEntity.setGoodsNo(serialNo);
		}
		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();
		pathDetailList.add(pathDetailEntity);
		pathDetailDao.deleteListPathDetail(pathDetailList);
	}

	/**
	 * 
	* @Title: createPathDetailListSameOrgCode 
	* @Description: 生成走货路径明细信息
	* @param serialNo
	* @param transportPathEntity
	* @param waybillEntity
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see createPathDetailListSameOrgCode
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-2 下午5:37:47   
	* @throws
	 */
	private List<PathDetailEntity> createPathDetailListSameOrgCode(String serialNo, TransportPathEntity transportPathEntity, WaybillEntity waybillEntity) {
		//新建临时走货路径信息
		TransportPathEntity tempTransportPathEntity = new TransportPathEntity();
		tempTransportPathEntity.setCurrentOrgCode(waybillEntity.getReceiveOrgCode());
		tempTransportPathEntity.setDestOrgCode(transportPathEntity.getDestOrgCode());
		tempTransportPathEntity.setTransportModel(transportPathEntity.getTransportModel());
		// 新建综合走货路径
		List<FreightRouteLineDto> freightRouteLineDtoList = getFrightRouteLineDtoList(tempTransportPathEntity);
		//初始化走货路径明细---除最后一段外，全部更新为RELEAVE状态
		List<PathDetailEntity> pathDetailEntityReleaveList = initPathDetailEntityList(freightRouteLineDtoList,transportPathEntity,serialNo);
		return pathDetailEntityReleaveList;
	}
	
	/** 
	* @Title: initPathDetailEntityList 
	* @Description: 初始化走货路径相信信息
	* @param freightRouteLineDtoList
	* @param transportPathEntity
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see initPathDetailEntityList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-2 下午4:44:45   
	* @throws 
	*/ 
	private List<PathDetailEntity> initPathDetailEntityList(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity, String serialNo) {

		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();

		for (int i = 0; i < freightRouteLineDtoList.size(); i++) {
			// 新建
			pathDetailList.add(new PathDetailEntity());

			// 设置ID
			pathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
			// 设置运单号
			pathDetailList.get(i).setWaybillNo(transportPathEntity.getWaybillNo());

			// 如果出发部门code为空
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getSourceCode())) {
				// 抛异常
				logger.error("CalculateTransportPathService[initPathDetailEntityList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] {
						queryFreightRouteBySourceTarget,
						TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME
								+ getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
			}
			// 设置出发部门
			pathDetailList.get(i).setOrigOrgCode(freightRouteLineDtoList.get(i).getSourceCode());
			// 设置到达部门
			// 如果到达部门code为空
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getTargetCode())) {
				// 抛异常
				logger.error("CalculateTransportPathService[initPathDetailEntityList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] {
						queryFreightRouteBySourceTarget,
						TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME
								+ getOrgNameAndCode(transportPathEntity.getDestOrgCode()) });
			}
			pathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDtoList.get(i).getTargetCode());
			// 设置下一到达部门&时间
			// 如果还有下一段
			if ((i + 1) < freightRouteLineDtoList.size()) {
				// 设置下一到达部门
				pathDetailList.get(i).setNextDestOrgCode(freightRouteLineDtoList.get(i + 1).getTargetCode());
				// 设置下一到达部门时间
				pathDetailList.get(i).setNextArriveTime(freightRouteLineDtoList.get(i + 1).getArriveDate());
			}
			// 设置开单部门
			pathDetailList.get(i).setBillingOrgCode(transportPathEntity.getBillingOrgCode());
			// 设置线路段号
			pathDetailList.get(i).setRouteNo(String.valueOf(i + 1));

			// 设置计划出发时间,如果为空，
			if (null == freightRouteLineDtoList.get(i).getLeaveDate()) {
				// 且非汽运偏线\精准空运\整车
				if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
								.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 则抛出异常
					logger.error("CalculateTransportPathService[initPathDetailEntityList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,
							getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()), getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 如果有出发时间
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 则设置出发时间
						freightRouteLineDtoList.get(i).setLeaveDate(freightRouteLineDtoList.get(i - 1).getArriveDate());
					}
					else {
						// 否则new date赋值
						freightRouteLineDtoList.get(i).setLeaveDate(new Date());
					}
				}
			}
			// 设置出发时间
			pathDetailList.get(i).setPlanStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置计划到达时间,如果为空，
			if (null == freightRouteLineDtoList.get(i).getArriveDate()) {
				// 且非汽运偏线\精准空运\整车
				if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
								.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 则抛出异常
					logger.error("CalculateTransportPathService[initPathDetailEntityList()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME);
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,
							getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()), getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 设置new date为到达时间
					long beforeArrive = (new Date()).getTime();
					// 如果有到达时间
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 设置为到达时间
						beforeArrive = freightRouteLineDtoList.get(i - 1).getArriveDate().getTime();
					}
					// 计算相差天数
					long min = freightRouteLineDtoList.get(i).getAging();
					// 计算最后到达的日期和时间
					Date arrive = new Date(sixtyThousand * min + beforeArrive);
					// 设置该段路的到达时间
					freightRouteLineDtoList.get(i).setArriveDate(arrive);
				}
			}
			// 设置到达时间
			pathDetailList.get(i).setPlanArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// 设置是否调整时间
			pathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
			// 设置调整出发时间
			pathDetailList.get(i).setModifyStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置调整到达时间
			pathDetailList.get(i).setModifyArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			
			if (i == freightRouteLineDtoList.size() - 1) {
				
				//设置实际出发时间
				pathDetailList.get(i).setActualStartTime(new Date());
				
				//设置实际到达时间
				pathDetailList.get(i).setActualArriveTime(new Date());
				
				// 若为最后一段走货路径
				pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
			}
			else {
				
				//设置实际出发时间---因为实际都没走过。。故设置成计划的出发时间。
				pathDetailList.get(i).setActualStartTime(pathDetailList.get(i).getPlanStartTime());
				//设置实际到达时间---因为实际都没走过。。故设置成计划的到达时间。
				pathDetailList.get(i).setActualArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
				
				pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			}
			// 设置上一段车牌号为空
			pathDetailList.get(i).setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);

			// 若分批配载
			if (StringUtils.equalsIgnoreCase(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)) {
				// 设置流水号
				pathDetailList.get(i).setGoodsNo(serialNo);
			}
		}

		return pathDetailList;
	}

	/**
	 * @param transportPathEntity  
	* @Title: createNewTransportPathDetail 
	* @Description: 创建走货路径详细信息
	* @param waybillNo
	* @param currentOrgCode
	* @param serialNo  设定文件 
	* @return void    返回类型 
	* @see createNewTransportPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-7 上午11:02:37   
	* @throws 
	*/
	private void createNewTransportPathDetail(TransportPathEntity transportPathEntity, String waybillNo, String currentOrgCode, String serialNo) {
		
		// modify by liangfuxiang 2013-6-24下午3:20:44 begin BUG-34871
		
		// // 若分批配载,且流水号为空,则抛出异常
		// if (TransportPathConstants.PARTIALSTOWAGE.equalsIgnoreCase(transportPathEntity.getIfPartialStowage()) && StringUtils.isEmpty(serialNo)) {
		// logger.error("CalculateTransportPathService[createNewTransportPathDetail()]：" + TransportPathConstants.SERIALNO_IS_NULL);
		// throw new TfrBusinessException(TransportPathConstants.SERIALNO_IS_NULL_GLOB);
		// }
		
		if(StringUtils.isEmpty(serialNo)){
			logger.error("CalculateTransportPathService[createNewTransportPathDetail()]:"+TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY+waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_GOODSNOS_ISEMPTY,new Object[]{serialNo});
		}
		
		//查找入库记录，查询当前运单是否在出入库之前，已经有了走货路径。-----只是当前部门不在走货路径上。此时，需要将货物原走货路径拼接至现在的路径上。
		//查询最后一次入库的部门编码
		//select w.org_code from tfr.t_opt_in_stock w where w.in_stock_time = (select max(s.in_stock_time) from tfr.t_opt_in_stock s where s.waybill_no='201314320' and s.serial_no='0002');
		String lastInStockOrgCode = transportPathEntity.getCurrentOrgCode();
		//若获取的走货路径中，当前部门为空,则查询最后一次入库的部门
		if(StringUtils.isEmpty(lastInStockOrgCode)){
			Map<String,String> paramsMap=new HashMap<String,String>();
			paramsMap.put("waybillNo", waybillNo);
			paramsMap.put("serialNo", serialNo);
			lastInStockOrgCode = queryLastInStockOrgCode(paramsMap);
		}
		
		//若走货路径主表为分批配载，则serialNo=null;
		if(!StringUtils.equals(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)){
			serialNo=null;
		}
		
		//需要保留下来拼接的老的走货路径
		List<PathDetailEntity> needsOldPathDetailList=null;
		//非空，则保留
		if(StringUtils.isNotEmpty(lastInStockOrgCode)){
			
			//查询到达部门为当前部门的最大走货路径信息，
			String maxRouteNo=queryMaxRouteNo(waybillNo,serialNo,lastInStockOrgCode);
			//若存在，则保留查询小于当前路段号的对应流水号的走货路径详细信息
			if(StringUtils.isNotEmpty(maxRouteNo)){
				needsOldPathDetailList=getNeedsOldPathDetailList(waybillNo,serialNo,maxRouteNo);
			}
		}
		// modify by liangfuxiang 2013-6-24下午3:20:47 end BUG-34871;
		
		//删除原流水号的老数据
		deletePathDetailEntityList(waybillNo, serialNo);
		//重新创建新数据
		createBrandNewTransportPathDetail(transportPathEntity, waybillNo, currentOrgCode, serialNo,needsOldPathDetailList);
	}

	/** 
	* @Title: getNeedsOldPathDetailList 
	* @Description: 若存在，则保留查询小于当前路段号的对应流水号的走货路径详细信息
	* @param waybillNo
	* @param serialNo
	* @param maxRouteNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see getNeedsOldPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-24 下午4:34:17   
	* @throws 
	*/ 
	private List<PathDetailEntity> getNeedsOldPathDetailList(String waybillNo, String serialNo, String maxRouteNo) {
		
		Map<String,String> needsOldMap=new HashMap<String,String>();
		
		needsOldMap.put("waybillNo", waybillNo);
		needsOldMap.put("serialNo", serialNo);
		needsOldMap.put("maxRouteNo", maxRouteNo);
		
		List<PathDetailEntity> needsOldPathDetailList=pathDetailDao.getNeedsOldPathDetailList(needsOldMap);
		
		return needsOldPathDetailList;
	}

	/** 
	* @Title: queryMaxRouteNo 
	* @Description: 根据目标部门以及流水，运单号获取最大路径的路段号
	* @param waybillNo
	* @param serialNo
	* @param lastInStockOrgCode
	* @return  设定文件 
	* @return String    返回类型 
	* @see queryMaxRouteNo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-24 下午4:27:20   
	* @throws 
	*/ 
	private String queryMaxRouteNo(String waybillNo, String serialNo, String lastInStockOrgCode) {
		
		Map<String,String> maxRouteNoMap=new HashMap<String,String>();
		maxRouteNoMap.put("waybillNo", waybillNo);
		maxRouteNoMap.put("serialNo", serialNo);
		maxRouteNoMap.put("lastInStockOrgCode", lastInStockOrgCode);
		//获取最大的路段号
		List<String> maxRouteNoList=pathDetailDao.queryMaxRouteNo(maxRouteNoMap);
		
		//返回为空
		if(CollectionUtils.isEmpty(maxRouteNoList)){
			return null;
		}
		else{
			//返回最大的路段号:
			maxRouteNoList=sortRouteNoStringList(maxRouteNoList,waybillNo);
			return maxRouteNoList.get(maxRouteNoList.size()-1);
		}
		
	}

	/** 
	* @Title: sortRouteNoStringList 
	* @Description: 排序获取最大路段号
	* @param maxRouteNoList
	* @return  设定文件 
	* @return List<String>    返回类型 
	* @see sortStringList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-24 下午4:45:55   
	* @throws 
	*/ 
	private List<String> sortRouteNoStringList(List<String> maxRouteNoList,String waybillNo) {
		
		Collections.sort(maxRouteNoList, new Comparator<String>() {

			public int compare(String o1, String o2) {
				return  routeNoCompare(o1,o2);
			}
			private int routeNoCompare(String o1, String o2) {
				// 流水号相等，比较路段号
				int routNo1 = getIntRoutNo(o1, null);
				int routNo2 = getIntRoutNo(o2, null);
				if (routNo1 <= routNo2) {
					return -1;
				}
				else {
					return 1;
				}
			}
		});
		
		return maxRouteNoList;
	}

	/** 
	* @Title: queryLastInStockOrgCode 
	* @Description: 查询最后的入库记录
	* @param paramsMap
	* @return  设定文件 
	* @return String    返回类型 
	* @see queryLastInStockOrgCode
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-24 下午4:10:06   
	* @throws 
	*/ 
	private String queryLastInStockOrgCode(Map<String, String> paramsMap) {
		
		List<String> orgCodeList = transportationPathDao.queryLastInStockOrgCode(paramsMap);
		if (CollectionUtils.isEmpty(orgCodeList)) {
			return null;
		}
		else {
			Set<String> orgCodeSet = new HashSet<String>(orgCodeList);
			if (orgCodeSet.size() > 1) {
				logger.error("CalculateTransportPathService[queryLastInStockOrgCode()]:" + TransportPathConstants.IN_STOCK_REPEAT_RECORD + paramsMap.get("waybillNo") + TransportPathConstants.COMMA
						+ paramsMap.get("serialNo"));
				throw new TfrBusinessException(TransportPathConstants.IN_STOCK_REPEAT_RECORD, new Object[] { paramsMap.get("waybillNo"), paramsMap.get("serialNo") });
			}
			else {
				return orgCodeSet.iterator().next();
			}
		}
	}

	/**
	 * @param needsOldPathDetailList  
	* @Title: createBrandNewTransportPathDetail 
	* @Description: 生成全新的走货路径详细信息
	* @param transportPathEntity
	* @param waybillNo
	* @param currentOrgCode
	* @param serialNo  设定文件 
	* @return void    返回类型 
	* @see createBrandNewTransportPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-7 上午11:33:17   
	* @throws 
	*/ 
	private void createBrandNewTransportPathDetail(TransportPathEntity transportPathEntity, String waybillNo, String currentOrgCode, String serialNo, List<PathDetailEntity> needsOldPathDetailList) {
		// 将走货路径当前部门设置为目前部门
		transportPathEntity.setCurrentOrgCode(currentOrgCode);
		// 获取走货路径信息
		List<FreightRouteLineDto> freightRouteLineDtoList = getFrightRouteLineDtoList(transportPathEntity);
		// 生成指定的走货路径信息
		createSpecifyNewPathDetail(freightRouteLineDtoList, transportPathEntity, serialNo, waybillNo,needsOldPathDetailList);
	}

	/**
	 * @param needsOldPathDetailList 
	 * @param waybillNo 
	 * @param serialNo
	 * @param transportPathEntity
	 * @Title: createSpecifyNewPathDetail
	 * @Description: 生成指定的走货路径信息
	 * @param freightRouteLineDtoList 设定文件
	 * @return void 返回类型
	 * @see createSpecifyNewPathDetail
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-7 下午1:43:19
	 * @throws
	 */
	private void createSpecifyNewPathDetail(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity, String serialNo, String waybillNo, List<PathDetailEntity> needsOldPathDetailList) {
		
		//获取运单信息
		WaybillEntity waybillEntity=queryWaybillEntityInfo(waybillNo);
		
		// 初始化指定的走货路径明细信息
		List<PathDetailEntity> pathDetailList = initSpecifyNewPathDetail(freightRouteLineDtoList, transportPathEntity,waybillEntity, serialNo);
		
		//老路径存在
		if (CollectionUtils.isNotEmpty(needsOldPathDetailList)) {
			// 更新老路径的状态
			needsOldPathDetailList = updateNeedsOldPathDetailList(needsOldPathDetailList);
			// 将老路径拼接出来
			pathDetailList = connectOldPathDetailList(pathDetailList, needsOldPathDetailList);
		}

		// 获取走货路径详细信息数量
		int size = pathDetailList.size();
		
		// 如果list大于0
		if (size > 0) {
			// 1:新增流水号的时候，如果生成的走货路径只有一段，则需要前面在补一段（从开单部门，到当前库存部门，状态为RELEAVE）， 目的是，如果只有一段走货路径，无法打标签
			if (size == 1) {
				// 拼接一段走货路径详细信息
				pathDetailList = splicePathDetailList(pathDetailList, transportPathEntity, serialNo);
			}
			// 更新明细list
			pathDetailDao.addListPathDetail(pathDetailList);
		}
		//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
		//拼接走货路径
		//transportPathEntity.setTransportPath(splicePathString(pathDetailList,transportPathEntity));
		transportationPathDao.updateTransportPath(transportPathEntity);
	}
	
	/**
	 * @Title: updateNeedsOldPathDetailList
	 * @Description: 更新老路径的状态
	 * @param needsOldPathDetailList
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see updateNeedsOldPathDetailList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-24 下午5:29:51
	 * @throws
	 */
	private List<PathDetailEntity> updateNeedsOldPathDetailList(List<PathDetailEntity> needsOldPathDetailList) {

		PathDetailEntity oldPathDetailEntity = null;
		List<PathDetailEntity> updatedOldPathDetailList = new ArrayList<PathDetailEntity>();
		for (int k = 0; k < needsOldPathDetailList.size(); k++) {
			oldPathDetailEntity = needsOldPathDetailList.get(k);
			// 状态为：已离开
			oldPathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
			// 若实际到达时间为空
			if (oldPathDetailEntity.getActualArriveTime() == null) {
				oldPathDetailEntity.setActualArriveTime(new Date());
			}
			updatedOldPathDetailList.add(oldPathDetailEntity);
		}
		return updatedOldPathDetailList;
	}

	/** 
	* @Title: connectOldPathDetailList 
	* @Description: 拼接走货路径详细信息
	* @param pathDetailList
	* @param needsOldPathDetailList
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see connectOldPathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-24 下午5:20:31   
	* @throws 
	*/ 
	private List<PathDetailEntity> connectOldPathDetailList(List<PathDetailEntity> pathDetailList, List<PathDetailEntity> needsOldPathDetailList) {
		
		// modify by liangfuxiang 2013-7-18下午8:32:38 begin BUG-45235 货区问题
		// 处理老路径的最后一段与新路径的第一段之间的拼接关系
		needsOldPathDetailList = dealOldLastAndNewFirstPathDetailEntity(pathDetailList, needsOldPathDetailList);
		// modify by liangfuxiang 2013-7-18下午8:32:38 end BUG-45235 货区问题
		
		// 获取最大路段号
		int maxRouteNo = getIntRoutNo(needsOldPathDetailList.get(needsOldPathDetailList.size() - 1).getRouteNo(), needsOldPathDetailList.get(needsOldPathDetailList.size() - 1).getWaybillNo());

		PathDetailEntity updatePathDetailEntity = null;
		// 遍历,更新路段号
		for (int i = 0; i < pathDetailList.size(); i++) {
			updatePathDetailEntity = pathDetailList.get(i);
			updatePathDetailEntity.setRouteNo(String.valueOf(getIntRoutNo(updatePathDetailEntity.getRouteNo(), updatePathDetailEntity.getWaybillNo()) + maxRouteNo));
			needsOldPathDetailList.add(updatePathDetailEntity);
		}

		return needsOldPathDetailList;
	}

	/**
	 * @Title: dealOldLastAndNewFirstPathDetailEntity
	 * @Description: 处理老路径的最后一段与新路径的第一段之间的拼接关系
	 * @param pathDetailList
	 * @param needsOldPathDetailList
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see dealOldLastAndNewFirstPathDetailEntity
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-18 下午7:29:21
	 * @throws
	 */
	private List<PathDetailEntity> dealOldLastAndNewFirstPathDetailEntity(List<PathDetailEntity> pathDetailList, List<PathDetailEntity> needsOldPathDetailList) {
		// 排序
		needsOldPathDetailList = sortPathDetailListByGoodsNoAndRouteNo(needsOldPathDetailList);
		pathDetailList = sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);
		// 获取老路径的最后一段
		PathDetailEntity lastOldPathDetailEntity = needsOldPathDetailList.get(needsOldPathDetailList.size() - 1);
		// 获取新路径的第一段路径
		PathDetailEntity firstNewPathDetailEntity = pathDetailList.get(0);

		// 老路径最后一段走货路径目标部门与新路径第一段的出发部门一致
		if (StringUtils.equalsIgnoreCase(lastOldPathDetailEntity.getObjectiveOrgCode(), firstNewPathDetailEntity.getOrigOrgCode())) {
			// 老路段最后一段的下以部门与新路段第一段的目标部门一致
			if (StringUtils.equalsIgnoreCase(lastOldPathDetailEntity.getNextDestOrgCode(), firstNewPathDetailEntity.getObjectiveOrgCode())) {
				// 直接返回
				return needsOldPathDetailList;
			}
			else {
				// 记录日志
				logger.info("CalculateTransportPathService[dealOldLastAndNewFirstPathDetailEntity()]:" + TransportPathConstants.MODIFY_NEXTDESTORGCODE + TransportPathConstants.WAYBILL_NO
						+ lastOldPathDetailEntity.getWaybillNo() + TransportPathConstants.SERIAL_NO
						+ (StringUtils.isEmpty(lastOldPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_STRING_CONSTANT : lastOldPathDetailEntity.getGoodsNo())
						+ TransportPathConstants.ROUTE_NO + lastOldPathDetailEntity.getRouteNo() + TransportPathConstants.NEXT_DEST_ORG_CODE
						+ (StringUtils.isEmpty(lastOldPathDetailEntity.getNextDestOrgCode()) ? TransportPathConstants.BLANK_STRING_CONSTANT : lastOldPathDetailEntity.getNextDestOrgCode())
						+ TransportPathConstants.NEW_DEST_ORG_CODE + firstNewPathDetailEntity.getObjectiveOrgCode());
				// 将老路径的nextDestOrgCode更新为新路径的第一段的目标部门
				needsOldPathDetailList.get(needsOldPathDetailList.size() - 1).setNextDestOrgCode(firstNewPathDetailEntity.getObjectiveOrgCode());
				return needsOldPathDetailList;
			}
		}
		else {

			// 需要拼接一段完全无关的走货路径
			PathDetailEntity chickenRibsPathDetailEntity = getChickenRibsPathDetailEntity(lastOldPathDetailEntity, firstNewPathDetailEntity);

			if (!StringUtils.equalsIgnoreCase(lastOldPathDetailEntity.getNextDestOrgCode(), chickenRibsPathDetailEntity.getObjectiveOrgCode())) {

				// 记录日志
				logger.info("CalculateTransportPathService[dealOldLastAndNewFirstPathDetailEntity()]:" + TransportPathConstants.MODIFY_NEXTDESTORGCODE + TransportPathConstants.WAYBILL_NO
						+ lastOldPathDetailEntity.getWaybillNo() + TransportPathConstants.SERIAL_NO
						+ (StringUtils.isEmpty(lastOldPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_STRING_CONSTANT : lastOldPathDetailEntity.getGoodsNo())
						+ TransportPathConstants.ROUTE_NO + lastOldPathDetailEntity.getRouteNo() + TransportPathConstants.NEXT_DEST_ORG_CODE
						+ (StringUtils.isEmpty(lastOldPathDetailEntity.getNextDestOrgCode()) ? TransportPathConstants.BLANK_STRING_CONSTANT : lastOldPathDetailEntity.getNextDestOrgCode())
						+ TransportPathConstants.NEW_DEST_ORG_CODE + chickenRibsPathDetailEntity.getObjectiveOrgCode());
				// 将老路径的nextDestOrgCode更新为新路径的第一段的目标部门
				needsOldPathDetailList.get(needsOldPathDetailList.size() - 1).setNextDestOrgCode(chickenRibsPathDetailEntity.getObjectiveOrgCode());
			}

			needsOldPathDetailList.add(chickenRibsPathDetailEntity);

			return needsOldPathDetailList;
		}

	}

	/**
	 * @Title: getChickenRibsPathDetailEntity
	 * @Description: 需要拼接一段完全无关的走货路径
	 * @param lastOldPathDetailEntity
	 * @param firstNewPathDetailEntity
	 * @return 设定文件
	 * @return PathDetailEntity 返回类型
	 * @see getChickenRibsPathDetailEntity
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-18 下午8:03:21
	 * @throws
	 */
	private PathDetailEntity getChickenRibsPathDetailEntity(PathDetailEntity lastOldPathDetailEntity, PathDetailEntity firstNewPathDetailEntity) {

		PathDetailEntity chickenRibsPathDetailEntity = new PathDetailEntity();
		// 初始化额外的走货路径---目的主要是为了衔接老新路径
		chickenRibsPathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
		chickenRibsPathDetailEntity.setActualArriveTime(new Date());
		chickenRibsPathDetailEntity.setActualStartTime(new Date());
		chickenRibsPathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
		chickenRibsPathDetailEntity.setBeforeVehicleNo(lastOldPathDetailEntity.getVehicleNo());
		chickenRibsPathDetailEntity.setBillingOrgCode(lastOldPathDetailEntity.getBillingOrgCode());
		chickenRibsPathDetailEntity.setGoodsNo(lastOldPathDetailEntity.getGoodsNo());
		chickenRibsPathDetailEntity.setIfChangeTime(TransportPathConstants.SPLICEPATH_IFCHANGETIME_NO);
		chickenRibsPathDetailEntity.setNextArriveTime(new Date());
		chickenRibsPathDetailEntity.setNextDestOrgCode(firstNewPathDetailEntity.getObjectiveOrgCode());
		chickenRibsPathDetailEntity.setObjectiveOrgCode(firstNewPathDetailEntity.getOrigOrgCode());
		chickenRibsPathDetailEntity.setOrigOrgCode(lastOldPathDetailEntity.getObjectiveOrgCode());
		chickenRibsPathDetailEntity.setPlanArriveTime(new Date());
		chickenRibsPathDetailEntity.setPlanStartTime(new Date());
		chickenRibsPathDetailEntity.setRouteNo(String.valueOf(getIntRoutNo(lastOldPathDetailEntity.getRouteNo(), lastOldPathDetailEntity.getWaybillNo()) + 1));
		chickenRibsPathDetailEntity.setVehicleNo(null);
		chickenRibsPathDetailEntity.setWaybillNo(lastOldPathDetailEntity.getWaybillNo());
		//标识这个路径为拼接出来的路段
		chickenRibsPathDetailEntity.setTruckDetailId(TransportPathConstants.CHICKENRIBS_PATH);
		//记录日志
		logger.info("CalculateTransportPathService[getChickenRibsPathDetailEntity()]:"+TransportPathConstants.SPLICE_CHICKENRIBSPATHDETAILENTITY+ TransportPathConstants.WAYBILL_NO
				+ lastOldPathDetailEntity.getWaybillNo() + TransportPathConstants.SERIAL_NO
				+ (StringUtils.isEmpty(chickenRibsPathDetailEntity.getGoodsNo()) ? TransportPathConstants.BLANK_STRING_CONSTANT : chickenRibsPathDetailEntity.getGoodsNo())
				+ TransportPathConstants.ROUTE_NO + chickenRibsPathDetailEntity.getRouteNo());
		
		return chickenRibsPathDetailEntity;
	}

	/** 
	* @Title: splicePathDetailList 
	* @Description: 拼接一段走货路径详细信息 
	* 新增流水号的时候，如果生成的走货路径只有一段，则需要前面在补一段（从开单部门，到当前库存部门，状态为RELEAVE）， 目的是，如果只有一段走货路径，无法打标签
	* @param pathDetailList
	* @param transportPathEntity
	* @param serialNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see splicePathDetailList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-7 下午2:23:33   
	* @throws 
	*/ 
	private List<PathDetailEntity> splicePathDetailList(List<PathDetailEntity> pathDetailList, TransportPathEntity transportPathEntity, String serialNo) {
	
		//获取唯一一段走货路径
		PathDetailEntity currentPathDetailEntity=pathDetailList.get(0);
		//要拼接的走货路径详细信息对象
		PathDetailEntity splicePathDetailEntity=new PathDetailEntity();
		//设置ID
		splicePathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
		//设置运单号
		splicePathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
		
		// modify by liangfuxiang 2013-7-11上午10:20:36 begin ISSUE-3095
		// 出发部门为开单部门
		// splicePathDetailEntity.setOrigOrgCode(transportPathEntity.getBillingOrgCode());
		WaybillEntity waybillEntity = queryWaybillEntityInfo(pathDetailList.get(0).getWaybillNo());

		// 当走货路由是从最初的开单部门出发的
		if (StringUtils.equalsIgnoreCase(pathDetailList.get(0).getOrigOrgCode(), waybillEntity.getReceiveOrgCode())) {
			splicePathDetailEntity.setOrigOrgCode(getCurrentOrgCodeFromWaybillEntity(waybillEntity));
		}
		// 当走货路由不是从最初的起始位置出发的，此时，最初部门应该是开单时候的出发部门
		else {
			splicePathDetailEntity.setOrigOrgCode(waybillEntity.getReceiveOrgCode());
		}
		// modify by liangfuxiang 2013-7-11上午10:20:44 end ISSUE-3095;
		
		//设置目标部门为当前部门
		splicePathDetailEntity.setObjectiveOrgCode(transportPathEntity.getCurrentOrgCode());
		//设置下以部门为原唯一走货路径的目标部门
		splicePathDetailEntity.setNextDestOrgCode(currentPathDetailEntity.getObjectiveOrgCode());
		//设置路段为1
		splicePathDetailEntity.setRouteNo(TransportPathConstants.SPLICEPATH_LAST_ROUTE_NO);
		//设置当前路段为2
		currentPathDetailEntity.setRouteNo(TransportPathConstants.SPLICEPATH_CURRENT_ROUTE_NO);
		//设置状态为已离开
		splicePathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
		//设置状态为入库
		currentPathDetailEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_INSTORE);
		//设置流水号
		splicePathDetailEntity.setGoodsNo(serialNo);
		//设置开单部门
		splicePathDetailEntity.setBillingOrgCode(transportPathEntity.getBillingOrgCode());
		//设置车牌号为空
		splicePathDetailEntity.setVehicleNo(null);
		//是否修改过计划出发时间为'N'
		splicePathDetailEntity.setIfChangeTime(TransportPathConstants.SPLICEPATH_IFCHANGETIME_NO);
		//设置实际出发时间
		splicePathDetailEntity.setActualStartTime(new Date());
		//设置实际到达时间
		splicePathDetailEntity.setActualArriveTime(new Date());
		//设置计划出发时间
		splicePathDetailEntity.setPlanStartTime(new Date());
		//设置计划到达时间
		splicePathDetailEntity.setPlanArriveTime(new Date());
		
		//重新初始化走货路径详细信息列表
		pathDetailList=new ArrayList<PathDetailEntity>();
		pathDetailList.add(splicePathDetailEntity);
		pathDetailList.add(currentPathDetailEntity);
		
		return pathDetailList;
	}

	/**
	 * @param waybillEntity 
	 * 
	* @Title: initSpecifyNewPathDetail 
	* @Description: 初始化指定的走货路径明细信息
	* @param freightRouteLineDtoList
	* @param transportPathEntity
	* @param serialNo
	* @return  设定文件 
	* @return List<PathDetailEntity>    返回类型 
	* @see initSpecifyNewPathDetail
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-7 下午2:10:48   
	* @throws
	 */
	private List<PathDetailEntity> initSpecifyNewPathDetail(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity, WaybillEntity waybillEntity, String serialNo) {
		
		List<PathDetailEntity> pathDetailList = new ArrayList<PathDetailEntity>();
		
		if(CollectionUtils.isEmpty(freightRouteLineDtoList)){
			return pathDetailList;
		}
		
		//第一段走货路径
		PathDetailEntity firstPathDetailEntity=null;
		
		for (int i = 0; i < freightRouteLineDtoList.size(); i++) {
			// 新建
			pathDetailList.add(new PathDetailEntity());
			
			//设置ID
			pathDetailList.get(i).setPathDetailId(UUIDUtils.getUUID());
			//设置运单号
			pathDetailList.get(i).setWaybillNo(transportPathEntity.getWaybillNo());

			// 如果出发部门code为空
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getSourceCode())) {
				// 抛异常
				logger.error("CalculateTransportPathService[initSpecifyNewPathDetail()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG);
				// modify by liangfuxiang 2013-7-1下午1:07:29 begin BUG-40000
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode())});
			}
			// 设置出发部门
			pathDetailList.get(i).setOrigOrgCode(freightRouteLineDtoList.get(i).getSourceCode());
			// 设置到达部门
			// 如果到达部门code为空
			if (StringUtils.isEmpty(freightRouteLineDtoList.get(i).getTargetCode())) {
				// 抛异常
				logger.error("CalculateTransportPathService[initSpecifyNewPathDetail()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG);
				// modify by liangfuxiang 2013-7-1下午1:07:29 begin BUG-40000
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(transportPathEntity.getDestOrgCode())});
			}
			pathDetailList.get(i).setObjectiveOrgCode(freightRouteLineDtoList.get(i).getTargetCode());
			// 设置下一到达部门&时间
			// 如果还有下一段
			if ((i + 1) < freightRouteLineDtoList.size()) {
				// 设置下一到达部门
				pathDetailList.get(i).setNextDestOrgCode(freightRouteLineDtoList.get(i + 1).getTargetCode());
				// 设置下一到达部门时间
				pathDetailList.get(i).setNextArriveTime(freightRouteLineDtoList.get(i + 1).getArriveDate());
			}
			// 设置开单部门
			pathDetailList.get(i).setBillingOrgCode(transportPathEntity.getBillingOrgCode());
			// 设置线路段号
			pathDetailList.get(i).setRouteNo(String.valueOf(i + 1));

			// 设置计划出发时间,如果为空，
			if (null == freightRouteLineDtoList.get(i).getLeaveDate()) {
				// 且非汽运偏线\精准空运\整车
				if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
								.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 则抛出异常
					logger.error("CalculateTransportPathService[initSpecifyNewPathDetail()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 如果有出发时间
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 则设置出发时间
						freightRouteLineDtoList.get(i).setLeaveDate(freightRouteLineDtoList.get(i - 1).getArriveDate());
					}
					else {
						// 否则new date赋值
						freightRouteLineDtoList.get(i).setLeaveDate(new Date());
					}
				}
			}
			// 设置出发时间
			pathDetailList.get(i).setPlanStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置计划到达时间,如果为空，
			if (null == freightRouteLineDtoList.get(i).getArriveDate()) {
				// 且非汽运偏线\精准空运\整车
				if (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
						|| StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
						|| (StringUtils.equals(freightRouteLineDtoList.get(i).getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(freightRouteLineDtoList.get(i)
								.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
					// 则抛出异常
					logger.error("CalculateTransportPathService[initSpecifyNewPathDetail()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME);
					// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(freightRouteLineDtoList.get(i).getSourceCode()),getOrgNameAndCode(freightRouteLineDtoList.get(i).getTargetCode()) });
				}
				else {
					// 设置new date为到达时间
					long beforeArrive = (new Date()).getTime();
					// 如果有到达时间
					if (i != 0 && null != freightRouteLineDtoList.get(i - 1) && null != freightRouteLineDtoList.get(i - 1).getArriveDate()) {
						// 设置为到达时间
						beforeArrive = freightRouteLineDtoList.get(i - 1).getArriveDate().getTime();
					}
					// 计算相差天数
					long min = freightRouteLineDtoList.get(i).getAging();
					// 计算最后到达的日期和时间
					Date arrive = new Date(sixtyThousand * min + beforeArrive);
					// 设置该段路的到达时间
					freightRouteLineDtoList.get(i).setArriveDate(arrive);
				}
			}
			// 设置到达时间
			pathDetailList.get(i).setPlanArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			// 设置是否调整时间
			pathDetailList.get(i).setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
			// 设置调整出发时间
			pathDetailList.get(i).setModifyStartTime(freightRouteLineDtoList.get(i).getLeaveDate());
			// 设置调整到达时间
			pathDetailList.get(i).setModifyArriveTime(freightRouteLineDtoList.get(i).getArriveDate());
			
			//若出发部门与当前部门相同
			if(freightRouteLineDtoList.get(i).getSourceCode().equalsIgnoreCase(transportPathEntity.getCurrentOrgCode())){
				
				//增加一段走货路径 ---解决散货入库时，目的部门为当前部门，而出发部门为开单部门。且当前部门不为开单部门
				// modify by liangfuxiang 2013-5-24下午5:29:32 begin BUG-12359 当前部门应该为收货部门，不应该为开单部门
				// if(!freightRouteLineDtoList.get(i).getSourceCode().equalsIgnoreCase(waybillEntity.getCreateOrgCode())){
				if(!freightRouteLineDtoList.get(i).getSourceCode().equalsIgnoreCase(waybillEntity.getReceiveOrgCode())){
					firstPathDetailEntity=new PathDetailEntity();
					firstPathDetailEntity.setPathDetailId(UUIDUtils.getUUID());
					firstPathDetailEntity.setWaybillNo(transportPathEntity.getWaybillNo());
					firstPathDetailEntity.setGoodsNo(serialNo);
					// modify by liangfuxiang 2013-5-24下午5:29:32 begin BUG-12359 当前部门应该为收货部门，不应该为开单部门
					//firstPathDetailEntity.setOrigOrgCode(waybillEntity.getCreateOrgCode());
					//forrest
					//firstPathDetailEntity.setOrigOrgCode(waybillEntity.getReceiveOrgCode());
					firstPathDetailEntity.setOrigOrgCode(getCurrentOrgCodeFromWaybillEntity(waybillEntity));
					firstPathDetailEntity.setObjectiveOrgCode(transportPathEntity.getCurrentOrgCode());
					//设置路段为1
					firstPathDetailEntity.setRouteNo(TransportPathConstants.CONSTONT_NUMBER_ONE);
					firstPathDetailEntity.setPlanStartTime(new Date());
					firstPathDetailEntity.setActualStartTime(new Date());
					//INSTORE
					firstPathDetailEntity.setArriveOrLeave(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
					firstPathDetailEntity.setPlanArriveTime(new Date());
					firstPathDetailEntity.setActualArriveTime(new Date());
					//firstPathDetailEntity.setBillingOrgCode(waybillEntity.getCreateOrgCode());
					//forrest
					firstPathDetailEntity.setBillingOrgCode(waybillEntity.getReceiveOrgCode());
					//下一目的地
					firstPathDetailEntity.setNextDestOrgCode(freightRouteLineDtoList.get(0).getTargetCode());
					firstPathDetailEntity.setVehicleNo(TransportPathConstants.SET_NULL_STRING);
					firstPathDetailEntity.setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);
					firstPathDetailEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
					firstPathDetailEntity.setModifyStartTime(new Date());
					firstPathDetailEntity.setModifyArriveTime(new Date());
					firstPathDetailEntity.setNextArriveTime(new Date());
				}

				// 若出发部门为当前部门
				pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
				//设置主表的下一部门为此条走货路径明细的目标部门。
				transportPathEntity.setNextOrgCode(freightRouteLineDtoList.get(i).getTargetCode());
			}
			else{
				// 状态为未离开
				pathDetailList.get(i).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
			}

			// 设置上一段车牌号为空
			pathDetailList.get(i).setBeforeVehicleNo(TransportPathConstants.SET_NULL_STRING);
			// 设置流水号
			pathDetailList.get(i).setGoodsNo(serialNo);
		}
		
		//说明更新了第一段的路径(firstPathDetailEntity!=null)
		if(null!=firstPathDetailEntity && pathDetailList.size()>0){
			//每个路段号加1
			for(int i=0;i<pathDetailList.size();i++){
				pathDetailList.get(i).setRouteNo(String.valueOf(Integer.parseInt(pathDetailList.get(i).getRouteNo())+1));
			}
			//将第一段路径加入走货路径
			pathDetailList.add(firstPathDetailEntity);
		}
		
		return pathDetailList;
	}

	/**
	 * @param serialNo  
	* @Title: deletePathDetailEntityList
	* @Description: 删除走货路径详细信息，判别当前流水号对应的走货路径
	* @param waybillNo
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see deletePathDetailEntityList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-7 上午11:06:01   
	* @throws 
	*/ 
	private void deletePathDetailEntityList(String waybillNo, String serialNo) {
		//构建走货路径详细信息对象
		PathDetailEntity pathDetailEntity=new PathDetailEntity();
		pathDetailEntity.setWaybillNo(waybillNo);
		pathDetailEntity.setGoodsNo(serialNo);
		List<PathDetailEntity> pathDetailList=new ArrayList<PathDetailEntity>();
		pathDetailList.add(pathDetailEntity);
		//删除走货路径信息
		pathDetailDao.deleteListPathDetail(pathDetailList);
	}

	/** 
	* @Title: updateTransportPathEntity 
	* @Description: 更新主表信息
	* @param transportPathEntity
	* @param currentOrgCode  设定文件 
	* @return void    返回类型 
	* @see updateTransportPathEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-7 上午10:58:55   
	* @throws 
	*/ 
	private void updateTransportPathEntity(TransportPathEntity transportPathEntity, String currentOrgCode) {
		//设置状态为库存中
		transportPathEntity.setAction(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
		//更新
		transportationPathDao.updateTransportPath(transportPathEntity);
	}

	/**
	 * @Title: createBrandNewTransportPath
	 * @Description: 创建全新的走货路径信息 3：完全生成新的走货路径的时候，如果新增失败，可以考虑在走货路径主表生成一条记录，这样可以通过重新生成走货路径界面去再次生成走货路径。
	 * @param waybillNo
	 * @param currentOrgCode 设定文件
	 * @return void 返回类型
	 * @see createBrandNewTransportPath
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-6 下午4:11:49
	 * @throws
	 */
	private void createBrandNewTransportPath(String waybillNo, String currentOrgCode) {

		// 获取运单信息
		WaybillEntity waybillEntity = queryWaybillEntityInfo(waybillNo);
		// 初始化走货路径信息
		TransportPathEntity transportPathEntity = initTransportPathEntity(waybillEntity, currentOrgCode);

		// 新建综合走货路径DTO
		List<FreightRouteLineDto> freightRouteLineDtoList = getFrightRouteLineDtoList(transportPathEntity);
		// 处理走货路径详细信息
		List<PathDetailEntity> pathDetailList = initSpecifyNewPathDetail(freightRouteLineDtoList, transportPathEntity, waybillEntity, null);
		// 处理走货路径主表信息
		dealTransportPath(pathDetailList, transportPathEntity);

	}
	
	/**
	* @Title: initTransportPathEntity 
	* @Description:初始化走货路径信息
	* @param waybillEntity
	* @return  设定文件 
	* @return TransportPathEntity    返回类型 
	* @see initTransportPathEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-6 下午4:27:27   
	* @throws 
	*/ 
	private TransportPathEntity initTransportPathEntity(WaybillEntity waybillEntity,String currentOrgCode) {
		
		TransportPathEntity transportPathEntity=new TransportPathEntity();

		//设置ID
		transportPathEntity.setTransportPathId(UUIDUtils.getUUID());
		//获取运单号
		String waybillNo=waybillEntity.getWaybillNo();
		transportPathEntity.setWaybillNo(waybillNo);

		//设置当前部门
		transportPathEntity.setCurrentOrgCode(currentOrgCode); 
		
		//设置到达部门
		String destOrgCode=StringUtils.trim(waybillEntity.getCustomerPickupOrgCode());
		if(StringUtils.isEmpty(destOrgCode)){
			logger.error("CalculateTransportPathService[initTransportPathEntity()]:"+TransportPathConstants.WAYBILL_PRKCUPORGCODE_NULL+waybillNo);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_PRKCUPORGCODE_NULL_GLOB, new Object[] { waybillNo });
		}
		transportPathEntity.setDestOrgCode(destOrgCode);
		
		//运输类型
		String transportModel=StringUtils.trim(waybillEntity.getProductCode());
		if (StringUtils.isEmpty(transportModel)) {
			logger.error("CalculateTransportPathService[initTransportPathEntity]:" + TransportPathConstants.WAYBILL_TRANPORTTYPE_NULL + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_TRANPORTTYPE_NULL_GLOB, new Object[] { waybillNo });
		}
		transportPathEntity.setTransportModel(transportModel);

		//开单部门
		//String billingOrgCode=StringUtils.trim(waybillEntity.getCreateOrgCode());
		//forrest
		String billingOrgCode=StringUtils.trim(waybillEntity.getReceiveOrgCode());
		if(StringUtils.isEmpty(billingOrgCode)){
			logger.error("CalculateTransportPathService[initTransportPathEntity]:" + TransportPathConstants.WAYBILL_BILLINGCODE_NULL + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_BILLINGCODE_NULL_GLOB, new Object[] { waybillNo });
		}
        transportPathEntity.setBillingOrgCode(billingOrgCode);

        //开单时间
        transportPathEntity.setBillingTime(waybillEntity.getBillTime());
        //重量
        transportPathEntity.setTotalWeight(waybillEntity.getGoodsWeightTotal());
        //体积
        transportPathEntity.setTotalVolume(waybillEntity.getGoodsVolumeTotal());
        //货物总件数
        transportPathEntity.setGoodsQtyTotal(waybillEntity.getGoodsQtyTotal());
		// 设置是否分批配载:NO
		transportPathEntity.setIfPartialStowage(TransportPathConstants.NOTPARTIALSTOWAGE);
		//设置走货路径状态
		transportPathEntity.setAction(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
		
		return transportPathEntity;
	}
	
	/**
	 * 
	 * @Title: queryWaybillEntityInfo
	 * @Description: 获取运单信息
	 * @param waybillNo
	 * @return 设定文件
	 * @return WaybillEntity 返回类型
	 * @see queryWaybillEntityInfo
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-6 下午4:32:48
	 * @throws
	 */
	private WaybillEntity queryWaybillEntityInfo(String waybillNo) {

		WaybillEntity waybillEntity = waybillManagerService.queryWaybillBasicByNo(waybillNo);
		// 运单entity非空性判断
		if (null == waybillEntity) {
			logger.error("CalculateTransportPathService[queryWaybillEntityInfo()]:" + TransportPathConstants.WAYBILL_INFO_NULL + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_INFO_NULL_GLOB, new Object[] { waybillNo });
		}
		return waybillEntity;
	}



	/**
	 * @Title: verifyParameters
	 * @Description: 验证输入的参数是否有效
	 * @param waybillNo
	 * @param currentOrgCode 设定文件
	 * @return void 返回类型
	 * @see verifyParameters
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-6 下午3:47:38
	 * @throws
	 */
	private void verifyParameters(String waybillNo, String currentOrgCode) {

		// 运单号非空
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[verifyParameters()]：" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		// 当前部门为空,抛出异常
		if (StringUtils.isEmpty(currentOrgCode)) {
			logger.error("CalculateTransportPathService[verifyParameters()]：" + TransportPathConstants.CURRENT_ORG_CODE_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.CURRENT_ORG_CODE_IS_NULL_GLOB);
		}
	}

	/**
	 * 
	* @Title: dealTransportPath 
	* @Description: 生成走货路径主表信息
	* @param pathDetailList
	* @param transportPathEntity  设定文件 
	* @return void    返回类型 
	* @see dealTransportPathEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-6 上午10:20:52   
	* @throws
	 */
	private void dealTransportPath(List<PathDetailEntity> pathDetailList, TransportPathEntity transportPathEntity) {

		// 走货路径详细信息非空
		if (CollectionUtils.isNotEmpty(pathDetailList)) {

			//若只有一段路径，则拼接一段路径，并置为RELEAVE状态
			if(pathDetailList.size()==1){
				pathDetailList = splicePathDetailList(pathDetailList, transportPathEntity,null);
			}
			// modify by liangfuxiang 2013-7-26上午9:46:00 begin BUG-47421
			else {
				// 若当前部门与目标部门相同会生成A-B,B-A的路径，这个时候，要将A-B置为"RELEAVE"
				if (StringUtils.equalsIgnoreCase(transportPathEntity.getCurrentOrgCode(), transportPathEntity.getDestOrgCode())) {
					pathDetailList = sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);
					// 置为RELEAVE
					pathDetailList.get(0).setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_RELEAVE);
					// 加一个标示
					pathDetailList.get(0).setTruckDetailId(TransportPathConstants.HIDDEN_RECREATE_SAMEORGOBJ);
				}
			}
			// modify by liangfuxiang 2013-7-26上午9:46:32 end;
			
			// 保存走货路径详细信息
			pathDetailDao.addListPathDetail(pathDetailList);

			StringBuffer path = new StringBuffer();
			// 获取走货路径详细信息第一段
			PathDetailEntity firstPathDetailEntity = getFirstPathDetailEntity(pathDetailList);

			// 若未查找到走货路径明细第一段，则异常
			if (firstPathDetailEntity == null) {
				logger.error("CalculateTransportPathService[dealTransportPathEntity()]:" + TransportPathConstants.TRANSPORTPATH_DETAIL_NO_FIRST_ROUTE);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_DETAIL_NO_FIRST_ROUTE_GLOB);
			}
			// 设置第一段出发部门
			path.append(getNameByCode(firstPathDetailEntity.getOrigOrgCode()));
			// 循环明细信息 添加基本字段
			for (int i = 0; i < pathDetailList.size(); i++) {
				// 拼接走货路径
				path.append("-");
				// 设置走货路径
				path.append(getNameByCode(pathDetailList.get(i).getObjectiveOrgCode()));
			}
			
			//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
			// 设置 其他数据
			/*if (path.length() == 0) {
				// 设置为空
				transportPathEntity.setTransportPath(TransportPathConstants.SET_NULL_STRING);
			}
			else {
				// 设置路径
				transportPathEntity.setTransportPath(path.toString());
			}*/
			// 走货路径设置现部门
			transportPathEntity.setCurrentOrgCode(firstPathDetailEntity.getOrigOrgCode());
			// 设置下一部门
			transportPathEntity.setNextOrgCode(firstPathDetailEntity.getObjectiveOrgCode());
			// 设置预计出发时间
			transportPathEntity.setPlanStartTime(firstPathDetailEntity.getModifyStartTime());
			// 设置预计到达时间
			transportPathEntity.setPlanArriveTime(firstPathDetailEntity.getModifyArriveTime());
			// 更新走货路径
			transportationPathDao.addTransportPathSelect(transportPathEntity);
		}
		// 完全生成新的走货路径的时候，如果新增失败，
		// 原要求：---------可以考虑在走货路径主表生成一条记录，这样可以通过重新生成走货路径界面去再次生成走货路径。
		// 现修改为：直接抛出异常
		else {
			logger.error("CalculateTransportPathService[dealTransportPath()]:" + TransportPathConstants.TRANSPORT_PATH_BRANDNEW);
			// transportationPathDao.addTransportPath(transportPathEntity);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORT_PATH_BRANDNEW_GLOB);
		}
	}
	
	/** 
	* @Title: getFirstPathDetailEntity 
	* @Description: 获取走货路径第一段信息
	* @param pathDetailList
	* @return  设定文件 
	* @return PathDetailEntity    返回类型 
	* @see getFirstPathDetailEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-16 下午1:15:47   
	* @throws 
	*/ 
	private PathDetailEntity getFirstPathDetailEntity(List<PathDetailEntity> pathDetailList) {

		// modify by liangfuxiang --如下代码有问题，把走货路径路段<1>,作为走货路径第一段。但是在数据迁移中，是将路段<0>作为第一段来处理的。
		// 虽然在目前的接口中，这种方法不会出现为题，但是为了防止将来有别的接口调用此接口。
		// for(int j=0;j<pathDetailList.size();j++){
		// if(TransportPathConstants.CONSTONT_NUMBER_ONE.equalsIgnoreCase(pathDetailList.get(j).getRouteNo())){
		// return pathDetailList.get(j);
		// }
		// }
		// return null;
		// 针对上述的不同，先修改获取第一段走货路径的方式：为了考虑到将来分批配载也可能也调用此接口，故在比较时，也将goods_no加入，作为比对元素
		// 其中路段号不会为空
		pathDetailList=sortPathDetailListByGoodsNoAndRouteNo(pathDetailList);
		return pathDetailList.get(0);
		// modify by liangfuxiang 2013-6-4下午8:28:43 end;
	}

	/**
	 * 
	* @Title: sortByGoodsNoAndRouteNo 
	* @Description: 根据流水号，路段号排序
	* @param pathDetailList  设定文件 
	* @return void    返回类型 
	* @see sortByGoodsNoAndRouteNo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-17 下午3:14:50   
	* @throws
	 */
	private List<PathDetailEntity> sortPathDetailListByGoodsNoAndRouteNo(List<PathDetailEntity> pathDetailList) {
		Collections.sort(pathDetailList, new Comparator<PathDetailEntity>() {
			public int compare(PathDetailEntity o1, PathDetailEntity o2) {
				if (StringUtils.isNotEmpty(StringUtils.trim(o1.getGoodsNo())) && StringUtils.isNotEmpty(StringUtils.trim(o2.getGoodsNo()))) {
					// 分批配载,比较流水号
					int flag = o1.getGoodsNo().compareTo(o2.getGoodsNo());
					if (flag == 0) {
						return routeNoCompare(o1, o2);
					}
					else {
						return flag;
					}
				}
				else {
					// 非分批配载---比较路段号
					return routeNoCompare(o1, o2);
				}
			}

			private int routeNoCompare(PathDetailEntity o1, PathDetailEntity o2) {
				// 流水号相等，比较路段号
				int routNo1=getIntRoutNo(o1.getRouteNo(),o1.getWaybillNo());
				int routNo2=getIntRoutNo(o2.getRouteNo(),o2.getWaybillNo());
				if(routNo1<=routNo2){
					return -1;
				}
				else{
					return 1;
				}
			}
		});
		
		return pathDetailList;
	}

	/**
	 * 
	 * @Title: getFrightRouteLineDto
	 * @Description: 从综合查询走货路线
	 * @param transportPathEntity
	 * @return 设定文件
	 * @return List<FreightRouteLineDto> 返回类型
	 * @see getFrightRouteLineDto
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-3 下午5:54:16
	 * @throws
	 */
	private List<FreightRouteLineDto> getFrightRouteLineDtoList(TransportPathEntity transportPathEntity) {

		// 路径信息列表
		List<FreightRouteLineDto> freightRouteLineDtoList = null;

		try {
			// 调用基础资料接口得到路径detail
			freightRouteLineDtoList = freightRouteService.queryFreightRouteBySourceTarget(transportPathEntity.getCurrentOrgCode(), transportPathEntity.getDestOrgCode(),
					transportPathEntity.getTransportModel(), new Date());
		}
		catch (Exception e) {
			// 抛异常
			logger.error("CalculateTransportPathService[getFrightRouteLineDtoList]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH_FREIGHTROUTELINEDTO
					+ queryFreightRouteBySourceTarget + origOrgCode + ": " + transportPathEntity.getCurrentOrgCode() + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());

		}

		// 判断freightRouteLineDtoList是否为空，为空，则做如下操作
		// 1.若运输性质为空运，偏线,则直接抛出异常
		// 2.若为精准卡航，精准城运，精准汽运长途/短途，查不到走货路线，则按照顺序依次再查一遍,都查不到，则抛出异常
		freightRouteLineDtoList = queryFreightRouteLineDtoByOtherTrasportModel(freightRouteLineDtoList, transportPathEntity);

		// 如果得到的dto为空
		if (CollectionUtils.isEmpty(freightRouteLineDtoList)) {
			// 抛出异常
			logger.error("CalculateTransportPathService[getFrightRouteLineDtoList]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH_FREIGHTROUTELINEDTO + queryFreightRouteBySourceTarget
					+ origOrgCode + ": " + transportPathEntity.getCurrentOrgCode() + " " + destOrg + " : " + transportPathEntity.getDestOrgCode());

			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME
					+ getNameByCode(transportPathEntity.getCurrentOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getCurrentOrgCode() + TransportPathConstants.RIGHTBRACKET
					+ TransportPathConstants.COMMA + getNameByCode(transportPathEntity.getDestOrgCode()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getDestOrgCode()
					+ TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
					+ getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()) + TransportPathConstants.LEFTBRACKET + transportPathEntity.getTransportModel()
					+ TransportPathConstants.RIGHTBRACKET });
		}

		return freightRouteLineDtoList;
	}

	/**
	 * @param freightRouteLineDtoList
	 * @Title: queryFreightRouteLineDtoByOtherTrasportModel
	 * @Description:若为精准卡航，精准城运，精准汽运长途/短途，查不到走货路线，则按照顺序依次再查一遍,都查不到，则抛出异常 若运输性质为空运，偏线,则直接抛出异常
	 * @param transportPathEntity
	 * @return 设定文件
	 * @return List<FreightRouteLineDto> 返回类型
	 * @see queryFreightRouteLineDtoByOtherTrasportModel
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-10 上午10:11:42
	 * @throws
	 */
	private List<FreightRouteLineDto> queryFreightRouteLineDtoByOtherTrasportModel(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity) {

		// 走货路线非空，则直接返回
		if (CollectionUtils.isNotEmpty(freightRouteLineDtoList)) {
			return freightRouteLineDtoList;
		}
		else {
			// 获取运输性质
			String transportModel = transportPathEntity.getTransportModel();
			// 获取运输性质列表：精准卡航，精准城运，精准汽运长途/短途
			Map<String, String> transportModelMap = getTransportModelMap();
			// 遍历
			Set<Map.Entry<String, String>> transportModelSet = transportModelMap.entrySet();
			for (Iterator<Map.Entry<String, String>> it = transportModelSet.iterator(); it.hasNext();) {
				Map.Entry<String, String> entry = (Map.Entry<String, String>) it.next();
				// 若不为当期运输性质(使用其它运输类型)
				if (!entry.getValue().equalsIgnoreCase(transportModel)) {
					// 查询走货路径
					freightRouteLineDtoList = queryFreightRouteLineDtoList(transportPathEntity.getCurrentOrgCode(), transportPathEntity.getDestOrgCode(), entry.getValue(), new Date());
					// 查询到以后，直接返回
					if (CollectionUtils.isNotEmpty(freightRouteLineDtoList)) {
						return freightRouteLineDtoList;
					}
				}
			}
		}
		return null;
	}

	/**
	 * 
	* @Title: queryFreightRouteLineDtoList 
	* @Description: 查询走货路径
	* @param currentOrgCode
	* @param destOrgCode
	* @param transportModel
	* @param currentDate
	* @return
	* @throws TfrBusinessException  设定文件 
	* @return List<FreightRouteLineDto>    返回类型 
	* @see queryFreightRouteLineDtoList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-5-10 上午10:51:32   
	* @throws
	 */
	private List<FreightRouteLineDto> queryFreightRouteLineDtoList(String currentOrgCode, String destOrgCode, String transportModel, Date currentDate) throws TfrBusinessException {

		// 走货路线集合
		List<FreightRouteLineDto> freightRouteLineDtoList = null;

		try {
			// 调用基础资料接口得到路径detail
			freightRouteLineDtoList = freightRouteService.queryFreightRouteBySourceTarget(currentOrgCode, destOrgCode, transportModel, currentDate);
		}
		catch (Exception e) {
			// 抛异常
			logger.error("CalculateTransportPathService[queryFreightRouteLineDtoList]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH_FREIGHTROUTELINEDTO
					+ queryFreightRouteBySourceTarget + origOrgCode + ": " + currentOrgCode + " " + destOrg + " : " + destOrgCode);

		}
		return freightRouteLineDtoList;
	}

	/**
	 * @Title: getTransportModelMap
	 * @Description: 获取保存运输性质的MAP 精准卡航，精准城运，精准汽运长途/短途 (查找的优先级按照左侧所列的顺序)
	 * @return 设定文件
	 * @return Map<String,String> 返回类型
	 * @see getTransportModelMap
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-5-10 上午10:22:33
	 * @throws
	 */
	private Map<String, String> getTransportModelMap() {
		Map<String, String> transportModelMap = new LinkedHashMap<String, String>();
		// 精准卡航
		transportModelMap.put(ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT, ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT);
		// 精准城运
		transportModelMap.put(ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT, ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT);
		// 精准汽运(长途)
		transportModelMap.put(ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_ROAD_FREIGHT, ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_ROAD_FREIGHT);
		// 精准汽运(短途)
		transportModelMap.put(ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_ROAD_FREIGHT, ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_ROAD_FREIGHT);
		return transportModelMap;
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#getTransportModelNameByTransportModelCode()
	 */
	/**
	 * 根据运输性质编码获取运输
	 */
	@Override
	public String getTransportModelNameByTransportModelCode(String transportModelCode) throws TfrBusinessException {
		
		// 若入参为空，则直接返回
		if (StringUtils.isEmpty(transportModelCode)) {
			return transportModelCode;
		}

		// 获取所有的运输性质
		Map<String, String> transportModelMap = TransportPathConstants.getTransportModelMap();
		// 根据运输性质编码查询对应的名称
		String transportModelName = transportModelMap.get(transportModelCode);
		// 若未查询到,直接返回编码
		if (StringUtils.isEmpty(transportModelName)) {
			return transportModelCode;
		}
		else {
			// 返回名称
			return transportModelName;
		}
	}

	/**
	 * 
	* @Title: getCurrentOrgCodeFromWaybillEntity 
	* @Description: 从运单获取外场信息
	* @return void    返回类型 
	* @see getCurrentOrgCodeFromWaybillEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-5 下午8:44:01   
	* @throws
	 */
	private String getCurrentOrgCodeFromWaybillEntity(WaybillEntity waybillEntity){
		
		// 当前部门
		String currentOrgCode = null;
		// 获取开单部门
		String createOrgCode = StringUtils.trim(waybillEntity.getCreateOrgCode());
		if (StringUtils.isEmpty(createOrgCode)) {
			logger.error("CalculateTransportPathService[getCurrentOrgCodeFromWaybillEntity()]:" + TransportPathConstants.CREATE_ORG_CODE_IS_NULL + waybillEntity.getWaybillNo());
			throw new TfrBusinessException(TransportPathConstants.CREATE_ORG_CODE_IS_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo() });
		}

		// 判断是否集中开单
		if (FossConstants.YES.equals(waybillEntity.getPickupCentralized())) {
			// 根据集中接送货部门编码查询其对应的外场编码
			BillingGroupTransFerEntity entity = billingGroupTransFerService.queryTransFerListByBillingGroupCode(createOrgCode);
			// 判断对象是否为空
			if (null != entity) {
				// 外场编码
				currentOrgCode = StringUtils.trim(entity.getTransFerCode());
				// 非空判断
				if (StringUtil.isEmpty(currentOrgCode)) {
					// 若外场编码为空，则抛出异常信息（"集中接送货部门对应的外场编码为空！"）
					logger.error("CalculateTransportPathService[getCurrentOrgCodeFromWaybillEntity()]:" + TransportPathConstants.BILLINGGROUPTRANSFERENTITY_OUTORGNO_IS_NULL
							+ waybillEntity.getWaybillNo() + TransportPathConstants.COMMA + createOrgCode);
					throw new TfrBusinessException(TransportPathConstants.BILLINGGROUPTRANSFERENTITY_OUTORGNO_IS_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo(), createOrgCode });
				}
			}
			else {
				// 若没有查询到外场编码，则抛出异常信息
				logger.error("CalculateTransportPathService[getCurrentOrgCodeFromWaybillEntity()]:" + TransportPathConstants.BILLINGGROUPTRANSFERENTITY_IS_NULL + waybillEntity.getWaybillNo()
						+ TransportPathConstants.COMMA + createOrgCode);
				throw new TfrBusinessException(TransportPathConstants.BILLINGGROUPTRANSFERENTITY_IS_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo(), createOrgCode });
			}
		}
		else {
			SaleDepartmentEntity salesDept = saleDepartmentService.querySaleDepartmentByCode(createOrgCode);
			// 是否驻地部门
			if (null != salesDept && Boolean.parseBoolean(salesDept.getStation())) {

				// 获取运输性质
				String transType = StringUtils.trim(waybillEntity.getProductCode());
				if (StringUtils.isEmpty(StringUtils.trim(transType))) {
					logger.error("CalculateTransportPathService[getCurrentOrgCodeFromWaybillEntity()]:" + TransportPathConstants.TRANSTYPE_IS_NULL + waybillEntity.getWaybillNo());
					throw new TfrBusinessException(TransportPathConstants.TRANSTYPE_IS_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo() });
				}

				// 获取外场orgCode
				currentOrgCode = StringUtils.trim(lineService.queryDefaultTransCode(createOrgCode, transType, DictionaryValueConstants.BSE_LINE_SORT_SOURCE));
				if (StringUtils.isEmpty(currentOrgCode)) {
					if (StringUtils.isEmpty(StringUtils.trim(transType))) {
						logger.error("CalculateTransportPathService[getCurrentOrgCodeFromWaybillEntity()]:" + TransportPathConstants.CURRENTORGCODE_BY_DEFAULTTRANSCODE_IS_NULL
								+ waybillEntity.getWaybillNo() + TransportPathConstants.COMMA + createOrgCode + TransportPathConstants.COMMA + transType);
						throw new TfrBusinessException(TransportPathConstants.CURRENTORGCODE_BY_DEFAULTTRANSCODE_IS_NULL_GLOB, new Object[] { waybillEntity.getWaybillNo(), createOrgCode, transType });
					}
				}
			}
			else {
				currentOrgCode = createOrgCode;
			}
		}

		return currentOrgCode;
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#queryTransportPath()
	 */

	@Override
	public TransportPathEntity queryTransportPath(String waybillNo) throws TfrBusinessException {

		waybillNo = StringUtils.trim(waybillNo);
		// 运单号为空
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[queryTransportPath()]:" + TransportPathConstants.WAYBILL_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_IS_NULL_GLOB);
		}
		// 根据运单号，查询走货路径信息
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);

		// modify by liangfuxiang 2013-6-13下午4:35:49 begin BUG-30644 根据此单要求，注释掉如下 代码
		
		// if (null == transportPathEntity) {
		// // 查询数据迁移表
		// transportPathEntity = queryTransportPathMigrationNoRecover(waybillNo);
		// }
		// modify by liangfuxiang 2013-6-13下午4:35:54 end;
		
		return transportPathEntity;
	}

	/**
	 * @Title: queryTransportPathMigrationNoRecover
	 * @Description: 从走货路径数据迁移主表查询数据
	 * @return 设定文件
	 * @return TransportPathEntity 返回类型
	 * @see queryTransportPathMigrationNoRecover
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-6-8 上午12:29:20
	 * @throws
	 */
	private TransportPathEntity queryTransportPathMigrationNoRecover(String waybillNo) {

		// 查询数据迁移表
		List<TransportPathEntity> transportPathEntityList = transportationPathDao.queryTransportPathMigration(waybillNo);

		if (CollectionUtils.isEmpty(transportPathEntityList)) {
			// 未查询到走货路径
			logger.info("CalculateTransportPathService[queryTransportPathMigrationNoRecover()]:" + TransportPathConstants.QUERY_TRANSPORT_PATH_FROM_MIGRATION_NORESULT + waybillNo);
			return null;
		}
		// 查询到多条，异常
		else if (transportPathEntityList.size() > 1) {
			logger.info("CalculateTransportPathService[queryTransportPathMigrationNoRecover()]:" + TransportPathConstants.MULTY_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.MULTY_TRANSPORT_PATH_FROM_MIGRATION_EXCEPTION_GLOB, new Object[] { waybillNo });
		}
		else {
			return transportPathEntityList.get(0);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#listQueryGoodsNo(java.lang.String)
	 */
	@Override
	public List<String> listQueryGoodsNo(String waybillNo) throws TfrBusinessException {
		waybillNo = StringUtils.trim(waybillNo);
		// 运单号为空
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[listQueryGoodsNo()]:" + TransportPathConstants.LISTQUERYGOODSNO_WAYBILL_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.LISTQUERYGOODSNO_WAYBILL_IS_NULL_GLOB);
		}
		// 获取流水号信息
		List<String> listQueryGoodsNo = pathDetailDao.listQueryGoodsNo(waybillNo);

		return listQueryGoodsNo;
	}

	  
	/*
	 * (non-Javadoc) 查询实际的走货路径
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#queryActualTransportPath(java.lang.String)
	 */

	@Override
	public String queryActualTransportPath(String waybillNo) throws TfrBusinessException {

		// 去空
		waybillNo = StringUtils.trim(waybillNo);

		// 若为空
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[queryActualTransportPath()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}

		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);

		// 查询的走货路径为空
		if (null == transportPathEntity) {
			logger.warn("CalculateTransportPathService[queryActualTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
			return null;
		}
		else {
			// 返回走货路径
			return transportPathEntity.getTransportPath();
		}
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#updateTransportPathActionForInstore(java.lang.String, java.lang.String, java.lang.String)
	 */

	@Override
	public void updateTransportPathActionForInstore(String waybillNo, String goodsNo, String currentOrgCode) {
		
		waybillNo=StringUtils.trim(waybillNo);
		if(StringUtils.isEmpty(waybillNo)){
			logger.error("CalculateTransportPathService[updateTransportPathActionForInstore()]:"+TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		//当前部门
		currentOrgCode = StringUtils.trim(currentOrgCode);
		if(StringUtils.isEmpty(currentOrgCode)){
			logger.error("CalculateTransportPathService[updateTransportPathActionForInstore()]:"+TransportPathConstants.CURRENT_ORG_CODE_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.CURRENT_ORG_CODE_IS_NULL_GLOB);
		}
		
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		if(null!=transportPathEntity){
			//判断是否分批配载--分批
			if(StringUtils.equalsIgnoreCase(transportPathEntity.getIfPartialStowage(), TransportPathConstants.PARTIALSTOWAGE)){
				goodsNo =  StringUtils.trim(goodsNo);
				if(StringUtils.isEmpty(goodsNo)){
					logger.error("CalculateTransportPathService[updateTransportPathActionForInstore()]:"+TransportPathConstants.SERIALNO_IS_NULL);
					throw new TfrBusinessException(TransportPathConstants.SERIALNO_IS_NULL_GLOB);
				}
			}
			else{
				//非分批配载,将流水号置空
				goodsNo = null;
			}
			
			transportPathEntity.setAction(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
			//更新走货路径主表信息
			transportationPathDao.updateTransportPath(transportPathEntity);
			
			//更新走货路径明细信息
			updatePathDetailEntityMaxRouteNo(waybillNo,goodsNo,currentOrgCode);
		}
		else{
			logger.error("CalculateTransportPathService[updateTransportPathActionForInstore()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTDELETE + TransportPathConstants.WAYBILL_NO + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTDELETE, new Object[] { waybillNo });
		}
		
	}

	/** 
	* @Title: updatePathDetailEntity 
	* @Description: 更新当前走货路径明细信息
	* @param waybillNo
	* @param goodsNo
	* @param currentOrgCode  设定文件 
	* @return void    返回类型 
	* @see updatePathDetailEntity
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-26 上午10:20:13   
	* @throws 
	*/ 
	private void updatePathDetailEntityMaxRouteNo(String waybillNo, String goodsNo, String currentOrgCode) {
		
		PathDetailEntity pathDetailEntity=new PathDetailEntity();
		pathDetailEntity.setActualArriveTime(new Date());
		pathDetailEntity.setArriveOrLeave(TransportPathConstants.TRANSPORTPATH_STATUS_INSTORE);
		pathDetailEntity.setGoodsNo(goodsNo);
		pathDetailEntity.setObjectiveOrgCode(currentOrgCode);
		pathDetailEntity.setWaybillNo(waybillNo);
		//更新最大路段的目标部门----只所以考虑到选择最大路段,是因为前面走过的路段，状态不准确，只能加入最大路段作为过滤条件。
		pathDetailDao.updatePathDetailMaxRouteNo(pathDetailEntity);
		
		//将之前的路径，全部更新为RELEAVE----主要原因是：前面的状态不一定正确，会给其他业务带来异常。
		updateBeforePathDetailEntityForReleave(pathDetailEntity);
	}

	/** 
	* @Title: updateBeforePathDetailEntityForReleave 
	* @Description: 将之前的路径，全部更新为RELEAVE----主要原因是：前面的状态不一定正确，会给其他业务带来异常。
	* @param pathDetailEntity  设定文件 
	* @return void    返回类型 
	* @see updateBeforePathDetailEntityForReleave
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-6-26 下午1:38:49   
	* @throws 
	*/ 
	private void updateBeforePathDetailEntityForReleave(PathDetailEntity pathDetailEntity) {
		pathDetailDao.updateBeforePathDetailEntityForReleave(pathDetailEntity);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#getOrgNameAndCode()
	 */

	@Override
	public String getOrgNameAndCode(String orgCode) {
		
		//输入的orgCode为空
		if(StringUtils.isEmpty(orgCode)){
			logger.warn("CalculateTransportPathService[getOrgNameAndCode()]:"+TransportPathConstants.ORGCODE_IS_NULL);
			return TransportPathConstants.BLANK_STRING_CONSTANT;
		}
		
		StringBuffer stringBuffer = new StringBuffer();
		String orgName = getNameByCode(orgCode);
		stringBuffer.append(orgName).append(TransportPathConstants.LEFTBRACKET).append(orgCode).append(TransportPathConstants.RIGHTBRACKET);
		return stringBuffer.toString();
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#getNextOrgAndTimeTransactionalNested(java.lang.String, java.lang.String, java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.NESTED)
	public FeedbackDto getNextOrgAndTimeTransactionalNested(String waybillNo, String goodsNo, String correntOrgCode) throws TfrBusinessException {
		return getNextOrgAndTime(waybillNo, goodsNo, correntOrgCode);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#arriveMistakeTransactionalNested(java.lang.String, java.lang.String, java.lang.String,
	 * java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.NESTED)
	public void arriveMistakeTransactionalNested(String waybillNo, String serialNo, String arriveOrgCode, String beforeOrgCode) throws TfrBusinessException {
		arriveMistake(waybillNo, serialNo, arriveOrgCode, beforeOrgCode);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#notJoinCarModifyTransactionalNested(java.lang.String, java.lang.String, java.lang.String,
	 * java.util.Date, java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.NESTED)
	public void notJoinCarModifyTransactionalNested(String waybillNo, String serialNo, String origGoodsAreaCode, Date modifyTime, String nowOrgCode) throws TfrBusinessException {
		notJoinCarModify(waybillNo, serialNo, origGoodsAreaCode, modifyTime, nowOrgCode);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#inStorageTransactionalNested(java.lang.String, java.lang.String, java.lang.String,
	 * java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.NESTED)
	public void inStorageTransactionalNested(String waybillNo, String goodsNo, String orgCode, String action) throws TfrBusinessException {
		inStorage(waybillNo, goodsNo, orgCode, action);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#updateTransportPathActionForInstoreTransactionalNested(java.lang.String, java.lang.String,
	 * java.lang.String)
	 */

	@Override
	@Transactional(propagation = Propagation.NESTED)
	public void updateTransportPathActionForInstoreTransactionalNested(String waybillNo, String goodsNo, String currentOrgCode) {
		updateTransportPathActionForInstore(waybillNo, goodsNo, currentOrgCode);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#getNextOrgAndTimeForDetailResultInstoreTransactionalNested(java.lang.String, java.lang.String,
	 * java.lang.String)
	 */
	@Override
	@Transactional(propagation = Propagation.NESTED)
	public FeedbackDto getNextOrgAndTimeForDetailResultInstoreTransactionalNested(String waybillNo, String goodsNo, String correntOrgCode) throws TfrBusinessException {
		return getNextOrgAndTimeForDetailResult(waybillNo, goodsNo, correntOrgCode);
	}

	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#queryPathDetailEntityListForPrintLabel(java.lang.String, java.lang.String, java.lang.String,
	 * java.lang.String)
	 */
	@Override
	public List<PathDetailEntity> queryPathDetailEntityListForPrintLabel(String origCode, String currentCode, String objCode, String transModel) {
		// 验证输入参数的有效性
		origCode = verifyOrigCode(origCode);
		currentCode = verifyCurrentCode(currentCode);
		objCode = verifyObjCode(objCode);
		transModel = verifyTransModel(transModel);

		logger.info("CalculateTransportPathService[queryPathDetailEntityListForPrintLabel()]:" + TransportPathConstants.PRINTLABEL_INPUT_PARAMETERS + TransportPathConstants.ORIGORGNAME + origCode
				+ TransportPathConstants.DESTORGNAME + objCode + TransportPathConstants.CURRENT_ORGCODE + currentCode + TransportPathConstants.TRANSPORTMODELNAME + transModel);

		List<PathDetailEntity> pathDetailEntityList = new ArrayList<PathDetailEntity>();

		// 出发部门和当前部门相同，而与目的站不同 A=B && A!=C
		// 出发部门和当前部门相同，与目的站相同 ----营业部 A=B=C
		// 出发部门和当前部门不同，而当前部门与目的站相同 A!=B && B=C
		if ((StringUtils.equalsIgnoreCase(origCode, currentCode) && !StringUtils.equalsIgnoreCase(origCode, objCode))
				|| (StringUtils.equalsIgnoreCase(origCode, currentCode) && StringUtils.equalsIgnoreCase(origCode, objCode))
				|| (!StringUtils.equalsIgnoreCase(origCode, currentCode) && StringUtils.equalsIgnoreCase(currentCode, objCode))) {
			pathDetailEntityList = queryPurePathDetailEnityList(origCode, objCode, transModel);
		}
		// 出发部门和当前部门不同，而出发部门与目的站相同 A!=B && A=C !StringUtils.equalsIgnoreCase(origCode, currentCode) && StringUtils.equalsIgnoreCase(origCode, objCode)
		// 出发部门和当前部门不同，而出发部门与目的站不同,当前部门和目的站也不相同 A!=B!=C
		else {
			List<PathDetailEntity> beforePathDetailEntityList = queryPurePathDetailEnityList(origCode, currentCode, transModel);
			List<PathDetailEntity> afterPathDetailEntityList = queryPurePathDetailEnityList(currentCode, objCode, transModel);
			// 走货路由拼接
			pathDetailEntityList = combilePathDetailEntityList(beforePathDetailEntityList, afterPathDetailEntityList);
		}

		// 只有一段走货路径，需要拼接一段
		if (pathDetailEntityList.size() == 1) {
			List<PathDetailEntity> splicePathDetailEntityList = null;
			// 拼接
			return spliceFirstPathDetail(pathDetailEntityList, null, splicePathDetailEntityList);
		}
		else {
			return pathDetailEntityList;
		}
	}

	/**
	 * @Title: combilePathDetailEntityList
	 * @Description: 走货路由拼接
	 * @param beforePathDetailEntityList
	 * @param afterPathDetailEntityList
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see combilePathDetailEntityList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午6:18:11
	 * @throws
	 */
	private List<PathDetailEntity> combilePathDetailEntityList(List<PathDetailEntity> beforePathDetailEntityList, List<PathDetailEntity> afterPathDetailEntityList) {
		for (PathDetailEntity pathDetailEntity : afterPathDetailEntityList) {
			beforePathDetailEntityList.add(pathDetailEntity);
		}
		return beforePathDetailEntityList;
	}

	/**
	 * @Title: queryPurePathDetailEnityList
	 * @Description: 从综合查询走货路径
	 * @param origCode
	 * @param objCode
	 * @param transModel
	 * @param i
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see queryPurePathDetailEnityList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午6:05:04
	 * @throws
	 */
	private List<PathDetailEntity> queryPurePathDetailEnityList(String origCode, String objCode, String transModel) {

		// 组装走货路由主表对象
		TransportPathEntity transportPathEntity = assemblingTransportPathEntity(origCode, objCode, transModel);
		// 新建综合走货路径DTO
		List<FreightRouteLineDto> freightRouteLineDtoList = getFrightRouteLineDtoList(transportPathEntity);

		return splicePathDetailEntityList(freightRouteLineDtoList, transportPathEntity);
	}

	/**
	 * @param transportPathEntity
	 * @Title: splicePathDetailEntityList
	 * @Description: 拼接走货路径信息 ---打印标签只需要两个字段 ---出发部门&到达部门
	 * @param freightRouteLineDtoList
	 * @return 设定文件
	 * @return List<PathDetailEntity> 返回类型
	 * @see splicePathDetailEntityList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午6:38:59
	 * @throws
	 */
	private List<PathDetailEntity> splicePathDetailEntityList(List<FreightRouteLineDto> freightRouteLineDtoList, TransportPathEntity transportPathEntity) {

		List<PathDetailEntity> pathDetailEntityList = new ArrayList<PathDetailEntity>();

		FreightRouteLineDto freightRouteLineDto = null;
		PathDetailEntity pathDetailEntity = null;
		for (int i = 0; i < freightRouteLineDtoList.size(); i++) {

			pathDetailEntity = new PathDetailEntity();
			freightRouteLineDto = freightRouteLineDtoList.get(i);

			// 如果出发部门code为空
			if (StringUtils.isEmpty(freightRouteLineDto.getSourceCode())) {
				logger.error("CalculateTransportPathService[splicePathDetailEntityList()]:" + TransportPathConstants.FREIGHTROUTELINEDTO_CANTFINDSOURCEORG
						+ getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + getOrgNameAndCode(transportPathEntity.getDestOrgCode())
						+ getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()));
				throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTELINEDTO_CANTFINDSOURCEORG_GLOB, new Object[] { getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()),
						getOrgNameAndCode(transportPathEntity.getDestOrgCode()), getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()) });
			}
			// 设置出发部门
			pathDetailEntity.setOrigOrgCode(freightRouteLineDto.getSourceCode());
			// 如果到达部门code为空
			if (StringUtils.isEmpty(freightRouteLineDto.getTargetCode())) {
				logger.error("CalculateTransportPathService[splicePathDetailEntityList()]:" + TransportPathConstants.FREIGHTROUTELINEDTO_CANTFINDTARGETORG
						+ getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()) + getOrgNameAndCode(transportPathEntity.getDestOrgCode())
						+ getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()));
				throw new TfrBusinessException(TransportPathConstants.FREIGHTROUTELINEDTO_CANTFINDTARGETORG_GLOB, new Object[] { getOrgNameAndCode(transportPathEntity.getCurrentOrgCode()),
						getOrgNameAndCode(transportPathEntity.getDestOrgCode()), getTransportModelNameByTransportModelCode(transportPathEntity.getTransportModel()) });
			}

			pathDetailEntity.setObjectiveOrgCode(freightRouteLineDto.getTargetCode());

			pathDetailEntityList.add(pathDetailEntity);
		}

		return pathDetailEntityList;
	}

	/**
	 * @Title: assemblingTransportPathEntity
	 * @Description: 组装走货路由主表对象
	 * @param origCode
	 * @param objCode
	 * @param transModel
	 * @return 设定文件
	 * @return TransportPathEntity 返回类型
	 * @see assemblingTransportPathEntity
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午6:34:12
	 * @throws
	 */
	private TransportPathEntity assemblingTransportPathEntity(String origCode, String objCode, String transModel) {

		TransportPathEntity transportPathEntity = new TransportPathEntity();
		transportPathEntity.setCurrentOrgCode(origCode);
		transportPathEntity.setDestOrgCode(objCode);
		transportPathEntity.setTransportModel(transModel);
		return transportPathEntity;
	}

	/**
	 * @Title: verifyTransModel
	 * @Description: 判断输入的运输性质是否为空
	 * @param transModel
	 * @return 设定文件
	 * @return String 返回类型
	 * @see verifyTransModel
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午5:25:34
	 * @throws
	 */
	private String verifyTransModel(String transModel) {
		transModel = StringUtils.trim(transModel);
		if (StringUtils.isEmpty(transModel)) {
			logger.error("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.TRANS_MODEL_NULL);
			throw new TfrBusinessException("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.TRANS_MODEL_NULL_GLOB);
		}
		return transModel;
	}

	/**
	 * @Title: verifyObjCode
	 * @Description:判断输入的目标部门是否为空
	 * @param objCode
	 * @return 设定文件
	 * @return String 返回类型
	 * @see verifyObjCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午5:22:46
	 * @throws
	 */
	private String verifyObjCode(String objCode) {
		objCode = StringUtils.trim(objCode);
		if (StringUtils.isEmpty(objCode)) {
			logger.error("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.ARRIVEORGCODE_IS_NULL);
			throw new TfrBusinessException("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.ARRIVEORGCODE_IS_NULL_GLOB);
		}
		return objCode;
	}

	/**
	 * @param currentCode
	 * @Title: verifyCurrentCode
	 * @Description: 判断输入的当前部门是否为空
	 * @return 设定文件
	 * @return String 返回类型
	 * @see verifyCurrentCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午5:21:16
	 * @throws
	 */
	private String verifyCurrentCode(String currentCode) {
		currentCode = StringUtils.trim(currentCode);
		if (StringUtils.isEmpty(currentCode)) {
			logger.error("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.CURRENT_ORG_CODE_IS_NULL);
			throw new TfrBusinessException("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.CURRENT_ORG_CODE_IS_NULL_GLOB);
		}
		return currentCode;
	}

	/**
	 * @Title: verifyOrigCode
	 * @Description: 判断输入的出发部门是否为空
	 * @param origCode
	 * @return 设定文件
	 * @return String 返回类型
	 * @see verifyOrigCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-10 下午5:18:03
	 * @throws
	 */
	private String verifyOrigCode(String origCode) {
		origCode = StringUtils.trim(origCode);
		if (StringUtils.isEmpty(origCode)) {
			logger.error("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.ORGINAL_ORG_CODE_NULL);
			throw new TfrBusinessException("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.ORGINAL_ORG_CODE_NULL_GLOB);
		}
		return origCode;
	}

	/** 
	* @Title: verifyWaybillNo 
	* @Description:判断输入的运单号是否为空
	* @param waybillNo
	* @return  设定文件 
	* @return String    返回类型 
	* @see verifyWaybillNo
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-22 上午11:08:38   
	* @throws 
	*/ 
	private String verifyWaybillNo(String waybillNo) {
		waybillNo = StringUtils.trim(waybillNo);
		if (StringUtils.isEmpty(waybillNo)) {
			logger.error("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException("CalculateTransportPathService[verifyOrigCode()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		return waybillNo;
	}
	
	  
	/*
	 * (non-Javadoc)
	 * 
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.ICalculateTransportPathService#changeDestinationPathForExpress(java.lang.String, java.lang.String)
	 */
	@Deprecated
	@Override
	public void changeDestinationPathForExpress(String waybillNo, String destOrgCode) {

		waybillNo = verifyWaybillNo(waybillNo);
		destOrgCode = verifyObjCode(destOrgCode);

		// 根据老运单号查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 若走货路径非空
		if (null != transportPathEntity) {

			// 判断走货路径明细信息是否存在
			List<String> goodsNoList = getDistinctGoodsNoList(waybillNo);

			// 是否分批配载
			boolean isPartialStowage = StringUtils.equalsIgnoreCase(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage());

			// 判断是否分批配载---是
			if (isPartialStowage) {

				// 判断流水号集合的有效性
				verifyGoodsNoList(waybillNo, goodsNoList);

				// 修改各个流水号对应的最终目的地
				changePathDetailEntityInfoByGoodsNoList(waybillNo, destOrgCode, goodsNoList);
			}
			// 否
			else {
				// 修改走货路径明细相应的信息
				changePathDetailEntityInfo(waybillNo, destOrgCode, null);
			}

			// 修改主表的目的站和路径信息
			changeTransportPathEntityDestOrg(transportPathEntity, isPartialStowage, destOrgCode, goodsNoList);
			
			/**
			 * BUGKD-340
			 * mod by songjie on 2013-08-19  begin
			 */
			//入库前的准备begin
			PathDetailEntity pathDetailEntity = new PathDetailEntity();
			pathDetailEntity.setObjectiveOrgCode(destOrgCode);
			pathDetailEntity.setWaybillNo(waybillNo);
			List<PathDetailEntity> tempList = pathDetailDao.queryPathDetailList(pathDetailEntity);
			if(tempList!=null && tempList.size()>0){
				// 获取最大路段的信息
				PathDetailEntity maxRouteNoPathDetailEntity = new ArrayList<PathDetailEntity>(tempList.subList(tempList.size() - 1, tempList.size())).get(0);
				//当前部门
				String nowOrgCode = maxRouteNoPathDetailEntity.getOrigOrgCode();
				//入库前的准备end
	
				//有效流水号不为空
				//最后一段的时候重新入库  ---begin
				WaybillStockEntity waybillStockEntity = new WaybillStockEntity();
				waybillStockEntity.setWaybillNO(waybillNo);
				waybillStockEntity.setOrgCode(nowOrgCode);
				List<StockEntity> dbQueryList = stockService.queryStock(waybillStockEntity);
				//查询库存结果集大于0 再次入库 主要目的是为了修正 错误的库区。
				if(dbQueryList!=null && dbQueryList.size()>0 ){
					// 入库 begin
					for (int s = 0; s < dbQueryList.size(); s++) {
						// 新建入库实例
						InOutStockEntity inOutStockEntity = new InOutStockEntity();
						// 设置运载单号
						inOutStockEntity.setWaybillNO(waybillNo);
						// 设置序列号
						inOutStockEntity.setSerialNO(dbQueryList.get(s).getSerialNO());
						// 设置当前部门
						inOutStockEntity.setOrgCode(nowOrgCode);
						// 设置操作部门
						inOutStockEntity.setOperatorCode("XJBM");
						// 设置操作部门名称
						inOutStockEntity.setOperatorName("小件补码");
						// 设置入库类型类型
						inOutStockEntity.setInOutStockType(StockConstants.CHANGE_DESTORG_PATH_FOR_EXPRESS_IN_STOCK_TYPE);
						// 入库
						stockService.inStockPC(inOutStockEntity);
					}
					// 入库 end
				}else{
					//不在最后外场库存里就不用重新入库了。
				}
				//最后一段的时候重新入库  ---end
				// 入库 end
			}
			/**
			 * BUGKD-340
			 * mod by songjie on 2013-08-19  end
			 */
		}
		else {
			logger.error("CalculateTransportPathService[changeDestinationPathForExpress()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO
					+ waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
		}

	}
	
	

	/**
	 * 用于小件 补码
	* @description
	* 与changeDestinationPathForExpress的区别是：不是直接修改目的站，而是根据当前最大路由的当前部门与目的部门(destOrgCode) 
	*  查询基础数据，调整走货路径
	* @param waybillNo
	* @param destOrgCode
	* @version 1.0
	* @author 14022-foss-songjie
	* @update 2013年10月25日 下午3:18:10
	*/
	@Override
	public void changeDestinationPathForAlterDetail(String waybillNo,String destOrgCode) {
		//校验传入的参数waybillNo、destOrgCode
		waybillNo = verifyWaybillNo(waybillNo);
		destOrgCode = verifyObjCode(destOrgCode);
		
		// 根据老运单号查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
		// 若走货路径非空
		if (null != transportPathEntity) {
			// 判断走货路径明细信息是否存在
			List<String> goodsNoList = getDistinctGoodsNoList(waybillNo);
			
			//查找运单对应的库存
			WaybillStockEntity waybillStockEntity = new WaybillStockEntity();
			waybillStockEntity.setWaybillNO(waybillNo);
			List<StockEntity> dbQueryList = stockService.queryStockByWaybillNo(waybillStockEntity);

			// 是否分批配载
			boolean isPartialStowage = StringUtils.equalsIgnoreCase(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage());
			
			// 判断是否分批配载---是
			if (isPartialStowage) {
				// 判断流水号集合的有效性
				verifyGoodsNoList(waybillNo, goodsNoList);
				
				for (String serialNo : goodsNoList) {
					PathDetailEntity pathDetailEntity = new PathDetailEntity();
					//pathDetailEntity.setObjectiveOrgCode(destOrgCode);
					pathDetailEntity.setWaybillNo(waybillNo);
					pathDetailEntity.setGoodsNo(serialNo);
					List<PathDetailEntity> tempList = pathDetailDao.queryPathDetailList(pathDetailEntity);
					// 获取最大路段的信息
					PathDetailEntity alterPathDetailEntityBefore = new ArrayList<PathDetailEntity>(tempList.subList(tempList.size() - 1, tempList.size())).get(0);
					//获取当前部门
					String nowOrgCode = alterPathDetailEntityBefore.getOrigOrgCode();
					//实际走货路径里的目的站部门code
					String lineDestOrgCode = alterPathDetailEntityBefore.getObjectiveOrgCode();
					
					//快递分部判断
					nowOrgCode = changePathAgainForExpressComm(nowOrgCode,lineDestOrgCode,waybillNo,serialNo,tempList);
					
					//更改走货路径
					alterDetail(waybillNo, serialNo, nowOrgCode, destOrgCode, transportPathEntity.getBillingOrgCode(),transportPathEntity.getTransportModel());
					
					
					//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表 begin
					PathDetailEntity pathDetailEntity3 = new PathDetailEntity();
					pathDetailEntity.setOrigOrgCode(nowOrgCode);//出发部门
					pathDetailEntity3.setWaybillNo(waybillNo);
					pathDetailEntity3.setGoodsNo(serialNo);
					List<PathDetailEntity> temp2List = pathDetailDao.queryPathDetailList(pathDetailEntity3);
					PathDetailEntity alterPathDetailEntityAfter = new ArrayList<PathDetailEntity>(temp2List.subList(temp2List.size() - 1, temp2List.size())).get(0);
					transportPathEntity.setNextOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
					//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表  end
					
					//根据出发部门修改查询的最大路由的前一段明细的nextOrgCode begin
					PathDetailEntity pathDetailEntity2 = new PathDetailEntity();
					pathDetailEntity2.setWaybillNo(waybillNo);
					pathDetailEntity2.setNextDestOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
					pathDetailEntity2.setOrigOrgCode(nowOrgCode);
					pathDetailEntity2.setGoodsNo(serialNo);
					// 标识：标识小件那面直接修改目的地
					pathDetailEntity2.setTruckDetailId(TransportPathConstants.CHANGE_DEST_FOR_EXPRESS);
					pathDetailDao.changePathDetailPojoNextOrgCode(pathDetailEntity2);
					//根据出发部门修改查询的最大路由的前一段明细的nextOrgCode end
					
				
					//主表信息
					transportPathEntity.setCurrentOrgCode(nowOrgCode);
				}
				
			}else{
				PathDetailEntity pathDetailEntity = new PathDetailEntity();
				//pathDetailEntity.setObjectiveOrgCode(destOrgCode);
				pathDetailEntity.setWaybillNo(waybillNo);
				List<PathDetailEntity> tempList = pathDetailDao.queryPathDetailList(pathDetailEntity);
				// 获取最大路段的信息
				PathDetailEntity alterPathDetailEntityBefore = new ArrayList<PathDetailEntity>(tempList.subList(tempList.size() - 1, tempList.size())).get(0);
				//补码前的最终外场(出发部门)
				String nowOrgCode = alterPathDetailEntityBefore.getOrigOrgCode();
				//实际走货路径里的目的站部门code
				String lineDestOrgCode = alterPathDetailEntityBefore.getObjectiveOrgCode();
				
				//取任意一条库存对应的流水号
				if(dbQueryList!=null && dbQueryList.size()>0){
					StockEntity tempPojo = dbQueryList.get(0);
					//快递分部判断(流水号从库存里取)
					nowOrgCode = changePathAgainForExpressComm(nowOrgCode,lineDestOrgCode,waybillNo,tempPojo.getSerialNO(),tempList);
				}else{
					//快递分部判断(流水号从库存里取)
					List<String> listGoodsNo = pathDetailDao.listQueryGoodsNo(waybillNo);
					if(listGoodsNo!=null && listGoodsNo.size()>0){
						nowOrgCode = changePathAgainForExpressComm(nowOrgCode,lineDestOrgCode,waybillNo,listGoodsNo.get(0),tempList);
					}
					
				}
				
				
				//更改走货路径
				 alterDetail(waybillNo, null, nowOrgCode, destOrgCode, transportPathEntity.getBillingOrgCode(),transportPathEntity.getTransportModel());
				 
				//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表 begin
					PathDetailEntity pathDetailEntity3 = new PathDetailEntity();
					pathDetailEntity.setOrigOrgCode(nowOrgCode);//出发部门
					pathDetailEntity3.setWaybillNo(waybillNo);
					List<PathDetailEntity> temp2List = pathDetailDao.queryPathDetailList(pathDetailEntity3);
					PathDetailEntity alterPathDetailEntityAfter = new ArrayList<PathDetailEntity>(temp2List.subList(temp2List.size() - 1, temp2List.size())).get(0);
					transportPathEntity.setNextOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
					//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表  end
				 
				 //根据出发部门修改查询的最大路由的前一段明细的nextOrgCode begin
					PathDetailEntity pathDetailEntity2 = new PathDetailEntity();
					pathDetailEntity2.setWaybillNo(waybillNo);
					//pathDetailEntity2.setObjectiveOrgCode(nowOrgCode);
					pathDetailEntity2.setNextDestOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
					pathDetailEntity2.setOrigOrgCode(nowOrgCode);
					// 标识：标识小件那面直接修改目的地
					pathDetailEntity2.setTruckDetailId(TransportPathConstants.CHANGE_DEST_FOR_EXPRESS);
					pathDetailDao.changePathDetailPojoNextOrgCode(pathDetailEntity2);
					//根据出发部门修改查询的最大路由的前一段明细的nextOrgCode end
					
					
					//主表信息
					transportPathEntity.setCurrentOrgCode(nowOrgCode);
			}
			
			// 修改目的站
			transportPathEntity.setDestOrgCode(destOrgCode);
			// 更新主表走货路径信息
			transportationPathDao.updateTransportPath(transportPathEntity);
			
			/**
			 * BUGKD-340
			 * mod by songjie on 2013-08-19  begin
			 */
//			//入库前的准备begin
//			PathDetailEntity pathDetailEntity = new PathDetailEntity();
//			pathDetailEntity.setObjectiveOrgCode(destOrgCode);
//			pathDetailEntity.setWaybillNo(waybillNo);
//			List<PathDetailEntity> tempList = pathDetailDao.queryPathDetailList(pathDetailEntity);
//			if(tempList!=null && tempList.size()>0){
//				// 获取最大路段的信息
//				PathDetailEntity maxRouteNoPathDetailEntity = new ArrayList<PathDetailEntity>(tempList.subList(tempList.size() - 1, tempList.size())).get(0);
//				//当前部门
//				String nowOrgCode = maxRouteNoPathDetailEntity.getOrigOrgCode();
//				//入库前的准备end
//	
//				//有效流水号不为空
//				//最后一段的时候重新入库  ---begin
//				WaybillStockEntity waybillStockEntity = new WaybillStockEntity();
//				waybillStockEntity.setWaybillNO(waybillNo);
//				waybillStockEntity.setOrgCode(nowOrgCode);
//				List<StockEntity> dbQueryList = stockService.queryStock(waybillStockEntity);
//				//查询库存结果集大于0 再次入库 主要目的是为了修正 错误的库区。
//				if(dbQueryList!=null && dbQueryList.size()>0 ){
//					// 入库 begin
//					for (int s = 0; s < dbQueryList.size(); s++) {
//						// 新建入库实例
//						InOutStockEntity inOutStockEntity = new InOutStockEntity();
//						// 设置运载单号
//						inOutStockEntity.setWaybillNO(waybillNo);
//						// 设置序列号
//						inOutStockEntity.setSerialNO(dbQueryList.get(s).getSerialNO());
//						// 设置当前部门
//						inOutStockEntity.setOrgCode(nowOrgCode);
//						// 设置操作部门
//						inOutStockEntity.setOperatorCode("XJBM");
//						// 设置操作部门名称
//						inOutStockEntity.setOperatorName("小件补码");
//						// 设置入库类型类型
//						inOutStockEntity.setInOutStockType(StockConstants.CHANGE_DESTORG_PATH_FOR_EXPRESS_IN_STOCK_TYPE);
//						// 入库
//						stockService.inStockPC(inOutStockEntity);
//					}
//					// 入库 end
//				}else{
//					//不在最后外场库存里就不用重新入库了。
//				}
//				//最后一段的时候重新入库  ---end
//				// 入库 end
//			}
			/**
			 * BUGKD-340
			 * mod by songjie on 2013-08-19  end
			 */
			
			/**
			 * BUGKD-1716
			 * mod by songjie on 2013-11-07  begin
			 */
			
			//查询库存结果集大于0 再次入库 主要目的是为了修正 错误的库区。
			if(dbQueryList!=null && dbQueryList.size()>0 ){
				// 入库 begin
				for (int s = 0; s < dbQueryList.size(); s++) {
					// 新建入库实例
					InOutStockEntity inOutStockEntity = new InOutStockEntity();
					// 设置运载单号
					inOutStockEntity.setWaybillNO(waybillNo);
					// 设置序列号
					inOutStockEntity.setSerialNO(dbQueryList.get(s).getSerialNO());
					// 设置当前部门
					inOutStockEntity.setOrgCode(dbQueryList.get(s).getOrgCode());
					// 设置操作部门
					inOutStockEntity.setOperatorCode("XJBM");
					// 设置操作部门名称
					inOutStockEntity.setOperatorName("小件补码");
					// 设置入库类型类型
					inOutStockEntity.setInOutStockType(StockConstants.CHANGE_DESTORG_PATH_FOR_EXPRESS_IN_STOCK_TYPE);
					// 入库
					stockService.inStockPC(inOutStockEntity);
				}
				// 入库 end
			}else{
				//不在库存里就不用重新入库了。
			}
			/**
			 * BUGKD-1716
			 * mod by songjie on 2013-11-07  end
			 */
			
		}else {
			logger.error("CalculateTransportPathService[changeDestinationPathForExpress()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO
					+ waybillNo);
			throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
		}
	}

	/**
	* @description 快递补码优化，针对快递分部无法补码  oneto-20
	* @param nowOrgCode 最后一个外场
	* @param lineDestOrgCode 原路径的目的站
	* @param waybillNo 运单号
	* @param serialNo 流水号
	* @param tempList 走货路径的集合
	* @return
	* @version 1.0
	* @author 14022-foss-songjie
	* @update 2014年11月18日 下午3:12:05
	*/
	private String changePathAgainForExpressComm(String nowOrgCode,String lineDestOrgCode,String waybillNo,String serialNo,List<PathDetailEntity> tempList){
		//当前部门是快递分部时
		OrgAdministrativeInfoEntity oaie = orgAdministrativeInfoService.queryOrgAdministrativeInfoByCodeClean(nowOrgCode);
		if(oaie!=null && oaie.getExpressBranch()!=null){
			//如果对应的部门是快递分部，则重新赋值当前部门；则当前部门为走货路径里快递分部的前一部门code
			if(FossConstants.YES.equals(oaie.getExpressBranch())){
				if(tempList.size()>=2){
					PathDetailEntity alterPathDetailEntityBefore = new ArrayList<PathDetailEntity>(tempList.subList(tempList.size() -2, tempList.size()-1)).get(0);
					//重新获取当前部门
					String tempNowOrgCode = alterPathDetailEntityBefore.getOrigOrgCode();
					
					Date outDate = new Date();
					//运单信息查询
					WaybillEntity waybillEntity = queryWaybillEntityInfo(waybillNo);
					if(waybillEntity!=null&&waybillEntity.getBillTime()!=null){
						//开单时间
						outDate = waybillEntity.getBillTime();
					}
					List<InOutStockEntity> outLogList = stockService.queryOutStockInfo(waybillNo,serialNo,tempNowOrgCode,outDate);
					
					//查出库记录如果有出库记录当前部门为 原路径的目的部门
					if(outLogList!=null && outLogList.size()>0){
						//当前部门 赋值为原路径的目的站
						nowOrgCode = lineDestOrgCode;
					}else{//如果没有出库记录则拿tempNowOrgCode做为部门的出发部门
						//快递分部的上一部门
						nowOrgCode = tempNowOrgCode;
					}
				}
			}
		}
		return nowOrgCode;
	}
	
	/**
	 *  用于小件 补录 ISSUE-4480
	 *  删除老的走货路径，重新生成新的走货路径的功能
	 * @param waybillEntity 运单号、开单部门不能为空
	 * @param destOrgCode 目标部门
	 *  @version 1.0
	 * @author 14022-foss-songjie
	 * @update 2013年11月19日 上午08:18:10
	 */
	@Transactional
	@Override
	public void changeDestinationPathForRecordAgain(String waybillNo,String destOrgCode) throws TfrBusinessException{
		WaybillEntity waybillEntity= queryWaybillEntityInfo(waybillNo);
		
		// 运单号为空抛出异常
		if (waybillEntity==null || StringUtils.isEmpty(waybillEntity.getWaybillNo())) {
			logger.error("CalculateTransportPathService[changeDestinationPathForRecordAgain()]:" + TransportPathConstants.WAYBILL_NO_IS_NULL);
			throw new TfrBusinessException(TransportPathConstants.WAYBILL_NO_IS_NULL_GLOB);
		}
		// 查询走货路径
		TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillEntity.getWaybillNo());
		// 新建走货路径详情实例
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		// 设置单号
		pathDetailEntity.setWaybillNo(waybillEntity.getWaybillNo());
		if (null != transportPathEntity) {
				// 查询走货路径详情信息列表
				List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
				// 批量删除明细信息
				pathDetailDao.deleteListPathDetail(pathDetailList);
				// 删除走货路径主表信息
				transportationPathDao.deleteTransportPath(transportPathEntity);
		}
		else {
			// 查询走货路径详情信息列表
			List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailList(pathDetailEntity);
			if(pathDetailList!=null&& pathDetailList.size()>0){
				// 批量删除明细信息
				pathDetailDao.deleteListPathDetail(pathDetailList);
			}
		}
		
		//重新生成走货路径
		TransportPathEntity tpPojo = initTransportPathEntity(waybillEntity,waybillEntity.getReceiveOrgCode());
		//补录的最终部门
		tpPojo.setDestOrgCode(destOrgCode);
		createTransportPathForComm(tpPojo,"insertList");
		//重新入库
		WaybillStockEntity waybillStockEntity = new WaybillStockEntity();
		waybillStockEntity.setWaybillNO(waybillEntity.getWaybillNo());
		List<StockEntity> dbQueryList = stockService.queryStockByWaybillNo(waybillStockEntity);
		//查询库存结果集大于0 再次入库 主要目的是为了修正 错误的库区。
		if(dbQueryList!=null && dbQueryList.size()>0 ){
			// 入库 begin
			for (int s = 0; s < dbQueryList.size(); s++) {
				// 新建入库实例
				InOutStockEntity inOutStockEntity = new InOutStockEntity();
				// 设置运载单号
				inOutStockEntity.setWaybillNO(waybillEntity.getWaybillNo());
				// 设置序列号
				inOutStockEntity.setSerialNO(dbQueryList.get(s).getSerialNO());
				// 设置当前部门
				inOutStockEntity.setOrgCode(dbQueryList.get(s).getOrgCode());
				// 设置操作部门
				inOutStockEntity.setOperatorCode("XJBl");
				// 设置操作部门名称
				inOutStockEntity.setOperatorName("小件补录");
				// 设置入库类型类型
				inOutStockEntity.setInOutStockType(StockConstants.CHANGE_DESTORG_PATH_FOR_RECORDAGAIN_IN_STOCK_TYPE);
				// 入库
				stockService.inStockPC(inOutStockEntity);
			}
			// 入库 end
		}else{
			//不在库存里就不用重新入库了。
		}
	}
	
	
	/**
	* @description 更新出发时间
	* @param waybillNo
	* @param goodsNoList
	* @param currentOrgCode
	* @param destOrgCode
	* @param productType
	* @throws TfrBusinessException
	* @version 1.0
	* @author 14022-foss-songjie
	* @update 2014年6月26日 下午5:21:22
	*/
	@Transactional(propagation=Propagation.REQUIRES_NEW)
	@Override
	public void changeModifyStartTime(String waybillNo, List<String> goodsNoList,
			String currentOrgCode, String destOrgCode, String productType)
			throws TfrBusinessException {
			if(StringUtils.isBlank(waybillNo)) {
				throw new TfrBusinessException("运单号不能为空");
			}
			if(CollectionUtils.isEmpty(goodsNoList)) {
				throw new TfrBusinessException("流水号不能为空");
			}
			if(StringUtils.isBlank(currentOrgCode)) {
				throw new TfrBusinessException("当前部门不能为空");
			}
			if(StringUtils.isBlank(destOrgCode)) {
				throw new TfrBusinessException("到达部门不能为空");
			}
			if(StringUtils.isBlank(productType)) {
				throw new TfrBusinessException("运输性质不能为空");
			}
			
			TransportPathEntity nowTransportPath = transportationPathDao.queryTransportPath(waybillNo);
			// 若走货路径非空
			if (null != nowTransportPath) {
				// 新建综合走货路径DTO
				List<FreightRouteLineDto> freightRouteLineDto = null;
				try {
					// 调用基础资料接口得到路径detail
					freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(currentOrgCode, destOrgCode,productType, new Date());
				}
				catch (Exception e) {
					// modify by liangfuxiang 2013-5-23下午7:53:01 begin 增加日志
					logger.error("CalculateTransportPathService[createTransportPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH + queryFreightRouteBySourceTarget + ","
							+ origOrgCode + currentOrgCode + "," + destOrg + destOrgCode + "," + TransportPathConstants.TRANS_MODEL
							+ productType);
					// modify by liangfuxiang 2013-5-23下午7:53:05 end;
					
					// 抛异常
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME
							+ getNameByCode(currentOrgCode) + TransportPathConstants.LEFTBRACKET + currentOrgCode + TransportPathConstants.RIGHTBRACKET
							+ TransportPathConstants.COMMA + getNameByCode(destOrgCode) + TransportPathConstants.LEFTBRACKET + destOrgCode
							+ TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
							+ getTransportModelNameByTransportModelCode(productType) + TransportPathConstants.LEFTBRACKET + productType
							+ TransportPathConstants.RIGHTBRACKET });
				}
				
				if(freightRouteLineDto!=null){
					for (FreightRouteLineDto rlDto : freightRouteLineDto) {
						//已分批
						if(StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, nowTransportPath.getIfPartialStowage())){
							//按流水号好循环更新
							for (String goodsNo : goodsNoList) {
								// 新建走货路径详细信息对象
								PathDetailEntity pathDetailEntity = new PathDetailEntity();
								// 设置运载单号
								pathDetailEntity.setWaybillNo(waybillNo);
								// 设置流水号
								pathDetailEntity.setGoodsNo(goodsNo);
								// 出发部门 origOrgCode
								pathDetailEntity.setOrigOrgCode(rlDto.getSourceCode());
								//到达部门 objectiveOrgCode
								pathDetailEntity.setObjectiveOrgCode(rlDto.getTargetCode());
								// 查询走货路径详细信息列表
								List<PathDetailEntity> listPathDetailEntity = pathDetailDao.queryPathDetailList(pathDetailEntity);
								if(listPathDetailEntity!=null){
									for (PathDetailEntity pathDetailDto : listPathDetailEntity) {
											// 设置调整出发时间
											pathDetailDto.setModifyStartTime(rlDto.getLeaveDate());
											pathDetailDao.updatePathDetail(pathDetailDto);
									}
								}
							}
						}
						//未分批
						else{
							// 新建走货路径详细信息对象
							PathDetailEntity pathDetailEntity = new PathDetailEntity();
							// 设置运载单号
							pathDetailEntity.setWaybillNo(waybillNo);
							// 出发部门 origOrgCode
							pathDetailEntity.setOrigOrgCode(rlDto.getSourceCode());
							//到达部门 objectiveOrgCode
							pathDetailEntity.setObjectiveOrgCode(rlDto.getTargetCode());
							// 查询走货路径详细信息列表
							List<PathDetailEntity> listPathDetailEntity = pathDetailDao.queryPathDetailList(pathDetailEntity);
							if(listPathDetailEntity!=null){
								for (PathDetailEntity pathDetailDto : listPathDetailEntity) {
										// 设置调整出发时间
										pathDetailDto.setModifyStartTime(rlDto.getLeaveDate());
										pathDetailDao.updatePathDetail(pathDetailDto);
								}
							}
						}
					}
				}else{
					throw new TfrBusinessException("无匹配的记录调整出发时间");
				}
			}
			else {
				// 抛异常 没有查询到相应运单走货路径
				logger.error("CalculateTransportPathService[modifyWaybillNo()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA + TransportPathConstants.WAYBILL_NO + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDDATA, new Object[] { waybillNo });
			}
		
	}

	/** 
	* @Title: getDistinctGoodsNoList 
	* @Description: 获取唯一的走货路径明细信息
	* @param waybillNo
	* @return  设定文件 
	* @return List<String>    返回类型 
	* @see getDistinctGoodsNoList
	* @author: liangfuxiang liangfux@cn.ibm.com  
	* @version: 2013-7-22 下午5:41:13   
	* @throws 
	*/ 
	private List<String> getDistinctGoodsNoList(String waybillNo) {
		
		List<PathDetailEntity> pathDetailEntityList = (List<PathDetailEntity>) pathDetailDao.queryGoodsNoList(waybillNo);
		
		Set<String> goodsNoSet = new HashSet<String>();
		
		if(CollectionUtils.isEmpty(pathDetailEntityList)){
			logger.error("CalculateTransportPathService[getDistinctGoodsNoList()]:" + TransportPathConstants.PATH_DETAIL_NULL + waybillNo);
			throw new TfrBusinessException(TransportPathConstants.PATH_DETAIL_NULL_GLOB, new Object[] { waybillNo });
		}
		else{
			//获取唯一的流水号
			for(PathDetailEntity pathDetailEntity:pathDetailEntityList){
				goodsNoSet.add(pathDetailEntity.getGoodsNo());
			}
		}
		return new ArrayList<String>(goodsNoSet);
	}

	/**
	 * @param waybillNo
	 * @Title: verifyGoodsNoList
	 * @Description: 判断流水号的有效性
	 * @param goodsNoList 设定文件
	 * @return void 返回类型
	 * @see verifyGoodsNoList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午2:35:17
	 * @throws
	 */
	private void verifyGoodsNoList(String waybillNo, List<String> goodsNoList) {
		for (String goodsNo : goodsNoList) {
			if (StringUtils.isEmpty(StringUtils.trim(goodsNo))) {
				logger.error("CalculateTransportPathService[verifyGoodsNoList()]:" + TransportPathConstants.GOODSNO_IS_NULL + waybillNo);
				throw new TfrBusinessException(TransportPathConstants.GOODSNO_IS_NULL_GLOB, new Object[] { waybillNo });
			}
		}
	}

	/**
	 * @Title: changePathDetailEntityInfo
	 * @Description: 修改走货路径明细相应的信息
	 * @param waybillNo
	 * @param destOrgCode
	 * @param object 设定文件
	 * @return void 返回类型
	 * @see changePathDetailEntityInfo
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午1:46:50
	 * @throws
	 */
	private void changePathDetailEntityInfo(String waybillNo, String destOrgCode, String goodsNo) {
		// 目的站修改---最后一段路径修改
		changePathDetailEntityDestOrgCode(waybillNo, destOrgCode, goodsNo);
		// 倒数第二段的nextOrgCode也需要做相应的修改
		changePathDetailEntityNextOrgCode(waybillNo, destOrgCode, goodsNo);
	}

	/**
	 * @Title: changePathDetailEntityNextOrgCode
	 * @Description: 倒数第二段的nextOrgCode也需要做相应的修改
	 * @param waybillNo
	 * @param nextOrgCode
	 * @param goodsNo 设定文件
	 * @return void 返回类型
	 * @see changePathDetailEntityNextOrgCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午1:59:54
	 * @throws
	 */
	private void changePathDetailEntityNextOrgCode(String waybillNo, String nextOrgCode, String goodsNo) {
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		pathDetailEntity.setWaybillNo(waybillNo);
		pathDetailEntity.setNextDestOrgCode(nextOrgCode);
		pathDetailEntity.setGoodsNo(goodsNo);
		// 标识：标识小件那面直接修改目的地
		pathDetailEntity.setTruckDetailId(TransportPathConstants.CHANGE_NEXT_FOR_EXPRESS);
		pathDetailDao.changePathDetailEntityNextOrgCode(pathDetailEntity);
	}

	/**
	 * @param isPartialStowage
	 * @param goodsNoList
	 * @param transportPathEntity
	 * @Title: changeTransportPathEntityDestOrg
	 * @Description: 修改主表的目的站和路径信息
	 * @param destOrgCode 设定文件
	 * @return void 返回类型
	 * @see changeTransportPathEntityDestOrg
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午12:12:40
	 * @throws
	 */
	private void changeTransportPathEntityDestOrg(TransportPathEntity transportPathEntity, boolean isPartialStowage, String destOrgCode, List<String> goodsNoList) {

		// 当前部门与目的站相等目的站了。
		if (StringUtils.equalsIgnoreCase(transportPathEntity.getDestOrgCode(), transportPathEntity.getCurrentOrgCode())) {
			// 修改当前部门为新的目的站
			transportPathEntity.setCurrentOrgCode(destOrgCode);
		}
		else
			// 当前部门不与目的站相等
			{
				//判断当前部门 如果为空不用修改走货路径主表NEXTORGCODE
				if(null!= transportPathEntity.getCurrentOrgCode()){
					// 当前部门是走货路径倒数第二段路径,则NEXTORGCODE要修改为新的目的站
					if (isCurrentOrgCodeEqualsLastSecondOrgCode(transportPathEntity.getWaybillNo(), transportPathEntity.getCurrentOrgCode(), isPartialStowage, goodsNoList)) {
						transportPathEntity.setNextOrgCode(destOrgCode);
					}
				}
			}

		// 修改目的站
		transportPathEntity.setDestOrgCode(destOrgCode);
		
		//BUG-50951 只显示开单时生成的走货路径 modify by songjie on 2013-08-14
		// 修改path
		//transportPathEntity.setTransportPath(reSpliceTransportPath(transportPathEntity.getTransportPath(), destOrgCode));
		// 更新走货路径信息
		transportationPathDao.updateTransportPath(transportPathEntity);
	}

	/**
	 * @Title: isCurrentOrgCodeEqualsLastSecondOrgCode
	 * @Description: 当前部门是走货路径倒数第二段路径,则NEXTORGCODE要修改为新的目的站 ---有一个相等，则返回TRUE
	 * @param waybillNo
	 * @param currentOrgCode
	 * @param isPartialStowage
	 * @param goodsNoList
	 * @return 设定文件
	 * @return boolean 返回类型
	 * @see isCurrentOrgCodeEqualsLastSecondOrgCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午2:31:33
	 * @throws
	 */
	private boolean isCurrentOrgCodeEqualsLastSecondOrgCode(String waybillNo, String currentOrgCode, boolean isPartialStowage, List<String> goodsNoList) {

		// 非分批配载
		if (!isPartialStowage) {
			goodsNoList = null;
		}

		// 分批查询
		if (CollectionUtils.isNotEmpty(goodsNoList)) {
			for (String goodsNo : goodsNoList) {
				if (hasResult(waybillNo, currentOrgCode, goodsNo)) {
					return true;
				}
			}
		}
		else {
			if (hasResult(waybillNo, currentOrgCode, null)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * 
	 * @Title: hasResult
	 * @Description: 判断是否有与倒数第二段路径相同部门的代码
	 * @param waybillNo
	 * @param currentOrgCode
	 * @param goodsNoList
	 * @return 设定文件
	 * @return boolean 返回类型
	 * @see hasResult
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午3:09:35
	 * @throws
	 */
	private boolean hasResult(String waybillNo, String currentOrgCode, String goodsNo) {

		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		pathDetailEntity.setWaybillNo(waybillNo);
		pathDetailEntity.setObjectiveOrgCode(currentOrgCode);
		pathDetailEntity.setGoodsNo(goodsNo);
		// 查询
		int resultCount = pathDetailDao.queryEqualsLastSecondPathDetailCount(pathDetailEntity);

		if (resultCount > 0) {
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * @deprecated
	 * @param destOrgCode
	 * @Title: reSpliceTransportPath
	 * @Description: 重新拼接走货路径信息
	 * @param transportPath
	 * @param destOrgCode
	 * @return 设定文件
	 * @return String 返回类型
	 * @see reSpliceTransportPath
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午2:12:58
	 * @throws
	 */
	private String reSpliceTransportPath(String transportPath, String destOrgCode) {
		// 获取目的站名称
		String destOrgName = getNameByCode(destOrgCode);

		// 按照反斜线来分割字符串
		String[] transportPathArray = transportPath.split(TransportPathConstants.BACKSLASH);

		if (transportPathArray.length > 0) {
			StringBuffer stringBuffer = new StringBuffer();
			// 路径段
			String pathSegment = null;
			String[] tempOrgNames = null;
			StringBuffer tempStringBuffer = null;
			for (int i = 0; i < transportPathArray.length; i++) {
				tempStringBuffer = new StringBuffer();
				pathSegment = transportPathArray[i];
				// 将最后一段路径替换为destOrgName
				tempOrgNames = pathSegment.split("\\-");
				if (tempOrgNames.length > 0) {
					tempOrgNames[tempOrgNames.length - 1] = destOrgName;
					// 重新拼接走货路径
					tempStringBuffer.append(reConnectOrgNames(tempOrgNames));
					stringBuffer.append(tempStringBuffer.toString());
				}
				else {
					stringBuffer.append(destOrgName);
				}

				if (i < transportPathArray.length - 1) {
					stringBuffer.append(TransportPathConstants.BACKSLASH);
				}
			}
			return stringBuffer.toString();
		}
		else {
			return destOrgName;
		}
	}

	/**
	 * @Title: reConnectOrgNames
	 * @Description: 拼接数组
	 * @param tempOrgNames
	 * @return 设定文件
	 * @return Object 返回类型
	 * @see reConnectOrgNames
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 下午4:08:19
	 * @throws
	 */
	private Object reConnectOrgNames(String[] tempOrgNames) {
		
		StringBuffer sb = new StringBuffer();
		// 拼接数组
		for (int k = 0; k < tempOrgNames.length; k++) {
			sb.append(tempOrgNames[k]);
			if (k < tempOrgNames.length - 1) {
				sb.append(TransportPathConstants.HORIZONTAL_LINE);
			}
		}

		return sb.toString();
	}

	/**
	 * @Title: changePathDetailEntityDestOrgCode
	 * @Description: 修改目的地
	 * @param waybillNo
	 * @param destOrgCode
	 * @param object 设定文件
	 * @return void 返回类型
	 * @see changePathDetailEntityDestOrgCode
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 上午11:51:31
	 * @throws
	 */
	private void changePathDetailEntityDestOrgCode(String waybillNo, String destOrgCode, String goodsNo) {
		PathDetailEntity pathDetailEntity = new PathDetailEntity();
		pathDetailEntity.setWaybillNo(waybillNo);
		pathDetailEntity.setObjectiveOrgCode(destOrgCode);
		pathDetailEntity.setGoodsNo(goodsNo);
		// 标识：标识小件那面直接修改目的地
		pathDetailEntity.setTruckDetailId(TransportPathConstants.CHANGE_DEST_FOR_EXPRESS);
		pathDetailDao.changePathDetailDestOrgCode(pathDetailEntity);
	}

	/**
	 * @Title: changePathDetailEntityDestOrgCodeByGoodsNoList
	 * @Description: 修改各个流水号对应的最终目的地
	 * @param waybillNo
	 * @param destOrgCode
	 * @param goodsNoList 设定文件
	 * @return void 返回类型
	 * @see changePathDetailEntityDestOrgCodeByGoodsNoList
	 * @author: liangfuxiang liangfux@cn.ibm.com
	 * @version: 2013-7-22 上午11:50:40
	 * @throws
	 */
	private void changePathDetailEntityInfoByGoodsNoList(String waybillNo, String destOrgCode, List<String> goodsNoList) {
		// 循环
		for (String goodsNo : goodsNoList) {
			changePathDetailEntityInfo(waybillNo, destOrgCode, goodsNo);
		}
	}
	
	/**
	 * 不在库存时返回最近的交接单号，在库存时返回null
	 * @param waybillNo
	 * @param goodsNo
	 * @return
	 */
	public String queryNewHandoverNoByWaybillNo(String waybillNo,String goodsNo) throws TfrBusinessException{
		StockEntity dbQueryDto = stockService.queryUniqueStock(waybillNo,goodsNo);
		if(dbQueryDto!=null){//在库存
			return null;
		}else{//不在库存
			PathDetailEntity queryDto = new PathDetailEntity();
			queryDto.setWaybillNo(waybillNo);
			queryDto.setGoodsNo(goodsNo);
			//根据运单号查询最新的交接单  返回交接单号
			return pathDetailDao.queryNewHandoverNoByWaybillNo(queryDto);
		}
	}
	
	/**
	 * 在途中修改对应的走货路径
	 * @param waybillNo
	 * @param serialNo
	 * @param nowOrgCode
	 * @param destOrgCode
	 * @param billingOrgCode
	 * @param model
	 * @throws TfrBusinessException
	 */
	public void alterPathDetailForNOStore(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String billingOrgCode, String model) throws TfrBusinessException {
		//查询库存情况
		StockEntity dbQueryDto = stockService.queryUniqueStock(waybillNo,serialNo);
		if(dbQueryDto!=null){
			//不做任何处理
		}else{
			// 根据货运单号查询走货路径信息
			TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
			
			if(transportPathEntity!=null){
				//已分批
				if(StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage())){
					if(StringUtils.isBlank(serialNo)){
						throw new TfrBusinessException("运单:"+waybillNo+"已分批 流水号不能为空");
					}
				}else{//未 分批
					//未 分批
				}
			}else{
				// 找不到走货路径
				throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
						+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
						+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
						+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
			}
			//先更新当前部门作为起始部门的最大路段的走货路径之前的路段状态为RELEAVE 后删除当前部门作为起始部门的最大路段的走货路径(含当前)之后的所有路段信息;
			dealCantfindBeforeDetailData(waybillNo,serialNo,nowOrgCode);
			PathDetailEntity queryDto = new PathDetailEntity();
			queryDto.setWaybillNo(waybillNo);
			queryDto.setGoodsNo(serialNo);
			List<PathDetailEntity> queryPathDetailList = pathDetailDao.queryPathDetailList(queryDto);
			//清理后的最大路由
			int routeNo = 0;
			if(CollectionUtils.isNotEmpty(queryPathDetailList) && queryPathDetailList.size()>1){
				queryPathDetailList = sortPathDetailListByGoodsNoAndRouteNo(queryPathDetailList);
				PathDetailEntity maxPathDetailEntity = queryPathDetailList.get(queryPathDetailList.size() - 1);
				routeNo = getIntRoutNo(maxPathDetailEntity.getRouteNo(),maxPathDetailEntity.getWaybillNo());
			}
			// 新建走货路径详细信息列表
			List<PathDetailEntity> newPathDetailList = newPahDetailcomm(waybillNo,serialNo,nowOrgCode,destOrgCode,model,billingOrgCode,routeNo);
			//如果list大于0 
			if (CollectionUtils.isNotEmpty(newPathDetailList) && newPathDetailList.size() > 0) { 
				// 更新明细list 
				pathDetailDao.addListPathDetail(newPathDetailList);
				
			}
		}
	}
	
	/**
	 * 根据基础资料生成的走过路径明细
	 * @param waybillNo
	 * @param serialNo
	 * @param nowOrgCode
	 * @param destOrgCode
	 * @param model
	 * @param billingOrgCode 开单部门
	 * @param routeNo 路由好的开启路段号
	 * @return
	 */
	private List<PathDetailEntity> newPahDetailcomm(String waybillNo, String serialNo, String nowOrgCode, String destOrgCode, String model,String billingOrgCode,int routeNo){
		// 新建走货路径详细信息列表
		List<PathDetailEntity> newPathDetailList = new ArrayList<PathDetailEntity>();
		// 走货路径线路列表
				List<FreightRouteLineDto> freightRouteLineDto = null;
				try {
					// 调用基础资料接口得到路径detail 从现部门之后
					freightRouteLineDto = freightRouteService.queryFreightRouteBySourceTarget(nowOrgCode, destOrgCode, model, new Date());
				}
				catch (Exception e) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH
							+ queryFreightRouteBySourceTarget + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
							+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
							+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
							+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
				}
				// 走货路径线路为空
				if (CollectionUtils.isEmpty(freightRouteLineDto)) {
					// modify by liangfuxiang 2013-5-24下午12:56:57 begin
					logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" + TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH
							+ queryFreightRouteBySourceTarget + origOrgCode + ": " + nowOrgCode + " " + destOrg + " : " + destOrgCode);
					// modify by liangfuxiang 2013-5-24下午12:57:08 end;
					// 异常：
					// 找不到走货路径
					throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTRANSPORTPATH, new Object[] { TransportPathConstants.ORIGORGNAME + getNameByCode(nowOrgCode)
							+ TransportPathConstants.LEFTBRACKET + nowOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + getNameByCode(destOrgCode)
							+ TransportPathConstants.LEFTBRACKET + destOrgCode + TransportPathConstants.RIGHTBRACKET + TransportPathConstants.COMMA + TransportPathConstants.TRANSPORTMODELNAME
							+ getTransportModelNameByTransportModelCode(model) + TransportPathConstants.LEFTBRACKET + model + TransportPathConstants.RIGHTBRACKET });
				}
				else {
					// 赋值
					int i = 0;
					for (FreightRouteLineDto baseRouteLineDto : freightRouteLineDto) {
						// 新建
						PathDetailEntity pdEntity = new PathDetailEntity();
						// 设置出发部门
						if (StringUtils.isEmpty(baseRouteLineDto.getSourceCode())) {
							// modify by liangfuxiang 2013-5-24下午12:56:57 begin
							logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG+ queryFreightRouteBySourceTarget);
							// modify by liangfuxiang 2013-5-24下午12:57:08 end;
							// 异常：
							// 找不到走货路径
							// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDSOURCEORG, new Object[] { queryFreightRouteBySourceTarget, TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode)  });
						}
						// 设置出发部门
						pdEntity.setOrigOrgCode(baseRouteLineDto.getSourceCode());
						// 设置到达部门
						if (StringUtils.isEmpty(baseRouteLineDto.getTargetCode())) {
							// modify by liangfuxiang 2013-5-24下午12:56:57 begin
							logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG+ queryFreightRouteBySourceTarget);
							// modify by liangfuxiang 2013-5-24下午12:57:08 end;
							// 异常：
							// 找不到走货路径目的地
							// modify by liangfuxiang 2013-7-1下午12:58:23 begin BUG-40000
							throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDTARGETORG, new Object[] { queryFreightRouteBySourceTarget,
									TransportPathConstants.ORIGORGNAME + getOrgNameAndCode(nowOrgCode) + TransportPathConstants.COMMA + TransportPathConstants.DESTORGNAME + getOrgNameAndCode(destOrgCode) });
						}
						pdEntity.setObjectiveOrgCode(baseRouteLineDto.getTargetCode());
						// 设置下一到达部门
						if ((i + 1) < freightRouteLineDto.size()) {
							// 设置下一目的地
							pdEntity.setNextDestOrgCode(freightRouteLineDto.get(i + 1).getTargetCode());
							// 设置到达时间
							pdEntity.setNextArriveTime(freightRouteLineDto.get(i + 1).getArriveDate());
						}
						// 设置开单部门
						pdEntity.setBillingOrgCode(billingOrgCode);
						// 重新确定ourteNo
						pdEntity.setRouteNo(String.valueOf(routeNo + i + 1));
						// 设置计划出发时间
						if (null == baseRouteLineDto.getLeaveDate()) {
							// 综合管理-线路-始发线路
							// 综合管理-线路-到达线路
							// 综合管理-线路-中转到中转线路-专线
							if (StringUtils.equals(baseRouteLineDto.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
									|| StringUtils.equals(baseRouteLineDto.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
									|| (StringUtils.equals(baseRouteLineDto.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(baseRouteLineDto
											.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
								// modify by liangfuxiang 2013-5-24下午12:56:57 begin
								logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME+ queryFreightRouteBySourceTarget);
								// modify by liangfuxiang 2013-5-24下午12:57:08 end;
								// 异常：
								// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
								throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDLEAVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(baseRouteLineDto.getSourceCode()),getOrgNameAndCode(baseRouteLineDto.getTargetCode()) });
							}
							else {
								// 根据条件设置出发时间
								if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
									// 设置出发时间
									baseRouteLineDto.setLeaveDate(freightRouteLineDto.get(i - 1).getArriveDate());
								}
								else {
									// 设置出发时间
									baseRouteLineDto.setLeaveDate(new Date());
								}
							}
						}
						// 设置计划出发时间
						pdEntity.setPlanStartTime(baseRouteLineDto.getLeaveDate());
						// 设置计划到达时间
						if (null == baseRouteLineDto.getArriveDate()) {
							// 综合管理-线路-始发线路
							// 综合管理-线路-到达线路
							// 综合管理-线路-中转到中转线路-专线
							if (StringUtils.equals(baseRouteLineDto.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_SOURCE)
									|| StringUtils.equals(baseRouteLineDto.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TARGET)
									|| (StringUtils.equals(baseRouteLineDto.getLineSort(), DictionaryValueConstants.BSE_LINE_SORT_TRANSFER) && StringUtils.equals(baseRouteLineDto
											.getLineType(), DictionaryValueConstants.BSE_LINE_TYPE_ZHUANXIAN))) {
								// modify by liangfuxiang 2013-5-24下午12:56:57 begin
								logger.error("CalculateTransportPathService[alterDetailForRecreateTransportaionPath()]:" +TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME+ queryFreightRouteBySourceTarget);
								// modify by liangfuxiang 2013-5-24下午12:57:08 end;
								// 异常：
								// 找不到到达时间
								// modify by liangfuxiang 2013-7-1上午11:11:51 begin BUG-40000
								throw new TfrBusinessException(TransportPathConstants.TRANSPORTPATH_CALCULATE_CANTFINDARRIVETIME, new Object[] { queryFreightRouteBySourceTarget,getOrgNameAndCode(baseRouteLineDto.getSourceCode()),getOrgNameAndCode(baseRouteLineDto.getTargetCode()) });
							}
							else {
								// 上一路段到达时间
								long beforeArrive = (new Date()).getTime();
								// 到达时间非空
								if (i != 0 && null != freightRouteLineDto.get(i - 1) && null != freightRouteLineDto.get(i - 1).getArriveDate()) {
									// 上一路段到达时间
									beforeArrive = freightRouteLineDto.get(i - 1).getArriveDate().getTime();
								}
								// 分钟
								long min = baseRouteLineDto.getAging();
								// 到达日期
								Date arrive = new Date(sixtyThousand * min + beforeArrive);
								// 设置到达日期
								baseRouteLineDto.setArriveDate(arrive);
							}
						}
						pdEntity.setPlanArriveTime(baseRouteLineDto.getArriveDate());
						// 设置调整出发时间
						pdEntity.setModifyStartTime(baseRouteLineDto.getLeaveDate());
						// 设置调整到达时间
						pdEntity.setModifyArriveTime(baseRouteLineDto.getArriveDate());
						// 设置是否调整时间
						pdEntity.setIfChangeTime(TransportPathConstants.NOTCHANGETIME);
						// 设置其他基本信息
						pdEntity.setPathDetailId(UUIDUtils.getUUID());
						// 设置单号
						pdEntity.setWaybillNo(waybillNo);
						if(StringUtil.isNotBlank(serialNo)){
							// 设置流水号
							pdEntity.setGoodsNo(serialNo);
						}
						// 更新状态
						pdEntity.setArriveOrLeave(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
						newPathDetailList.add(pdEntity);
						i++;
					}
					return newPathDetailList;
				}
	}


	/**
	* @description 根据运单号和当前部门重新调整走货路径(目的站是开单时对应的提货物网点虚拟营业部)
	* @param waybillNo
	* @param nowOrgCode
	* @version 1.0
	* @author 14022-foss-songjie
	* @update 2015年3月18日 下午4:33:05
	*/
	@Override
	public void changePathForExpressToArrivalFirstOrg(String waybillNo,
			String nowOrgCode) {
		//校验传入的参数waybillNo、destOrgCode
				waybillNo = verifyWaybillNo(waybillNo);
				nowOrgCode = verifyObjCode(nowOrgCode);
				String destOrgCode=pathDetailDao.queryBeforeOrgCodeByWaybillNO(waybillNo);
				if(StringUtil.isNotBlank(destOrgCode)){
					// 根据老运单号查询走货路径
					TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(waybillNo);
					// 若走货路径非空
					if (null != transportPathEntity) {
						// 判断走货路径明细信息是否存在
						List<String> goodsNoList = getDistinctGoodsNoList(waybillNo);
						
						// 是否分批配载
						boolean isPartialStowage = StringUtils.equalsIgnoreCase(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage());
						
						// 判断是否分批配载---是
						if (isPartialStowage) {
							// 判断流水号集合的有效性
							verifyGoodsNoList(waybillNo, goodsNoList);
							
							for (String serialNo : goodsNoList) {
								PathDetailEntity pathDetailEntity = new PathDetailEntity();
								//pathDetailEntity.setObjectiveOrgCode(destOrgCode);
								pathDetailEntity.setWaybillNo(waybillNo);
								pathDetailEntity.setGoodsNo(serialNo);
								
								//更改走货路径
								alterDetail(waybillNo, serialNo, nowOrgCode, destOrgCode, transportPathEntity.getBillingOrgCode(),transportPathEntity.getTransportModel());
								
								
								//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表 begin
								PathDetailEntity pathDetailEntity3 = new PathDetailEntity();
								pathDetailEntity.setOrigOrgCode(nowOrgCode);//出发部门
								pathDetailEntity3.setWaybillNo(waybillNo);
								pathDetailEntity3.setGoodsNo(serialNo);
								List<PathDetailEntity> temp2List = pathDetailDao.queryPathDetailList(pathDetailEntity3);
								PathDetailEntity alterPathDetailEntityAfter = new ArrayList<PathDetailEntity>(temp2List.subList(temp2List.size() - 1, temp2List.size())).get(0);
								transportPathEntity.setNextOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
								//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表  end
								
								//根据出发部门修改查询的最大路由的前一段明细的nextOrgCode begin
								PathDetailEntity pathDetailEntity2 = new PathDetailEntity();
								pathDetailEntity2.setWaybillNo(waybillNo);
								pathDetailEntity2.setNextDestOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
								pathDetailEntity2.setOrigOrgCode(nowOrgCode);
								pathDetailEntity2.setGoodsNo(serialNo);
								// 标识：标识小件那面直接修改目的地
								pathDetailEntity2.setTruckDetailId(TransportPathConstants.CHANGE_DEST_FOR_EXPRESS);
								pathDetailDao.changePathDetailPojoNextOrgCode(pathDetailEntity2);
								//根据出发部门修改查询的最大路由的前一段明细的nextOrgCode end
								
							
								//主表信息
								transportPathEntity.setCurrentOrgCode(nowOrgCode);
							}
							
						}else{
							PathDetailEntity pathDetailEntity = new PathDetailEntity();
							//pathDetailEntity.setObjectiveOrgCode(destOrgCode);
							pathDetailEntity.setWaybillNo(waybillNo);
							//更改走货路径
							 alterDetail(waybillNo, null, nowOrgCode, destOrgCode, transportPathEntity.getBillingOrgCode(),transportPathEntity.getTransportModel());
							 
							//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表 begin
								PathDetailEntity pathDetailEntity3 = new PathDetailEntity();
								pathDetailEntity.setOrigOrgCode(nowOrgCode);//出发部门
								pathDetailEntity3.setWaybillNo(waybillNo);
								List<PathDetailEntity> temp2List = pathDetailDao.queryPathDetailList(pathDetailEntity3);
								PathDetailEntity alterPathDetailEntityAfter = new ArrayList<PathDetailEntity>(temp2List.subList(temp2List.size() - 1, temp2List.size())).get(0);
								transportPathEntity.setNextOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
								//根据出发部门查询出最大路由的明细 取值下一部门 并赋值给对应的路径主表  end
							 
							 //根据出发部门修改查询的最大路由的前一段明细的nextOrgCode begin
								PathDetailEntity pathDetailEntity2 = new PathDetailEntity();
								pathDetailEntity2.setWaybillNo(waybillNo);
								//pathDetailEntity2.setObjectiveOrgCode(nowOrgCode);
								pathDetailEntity2.setNextDestOrgCode(alterPathDetailEntityAfter.getObjectiveOrgCode());
								pathDetailEntity2.setOrigOrgCode(nowOrgCode);
								// 标识：标识小件那面直接修改目的地
								pathDetailEntity2.setTruckDetailId(TransportPathConstants.CHANGE_DEST_FOR_EXPRESS);
								pathDetailDao.changePathDetailPojoNextOrgCode(pathDetailEntity2);
								//根据出发部门修改查询的最大路由的前一段明细的nextOrgCode end
								
								
								//主表信息
								transportPathEntity.setCurrentOrgCode(nowOrgCode);
						}
						
						// 修改目的站
						transportPathEntity.setDestOrgCode(destOrgCode);
						// 更新主表走货路径信息
						transportationPathDao.updateTransportPath(transportPathEntity);
					}
					//查找运单对应的库存
					WaybillStockEntity waybillStockEntity = new WaybillStockEntity();
					waybillStockEntity.setWaybillNO(waybillNo);
					List<StockEntity> dbQueryList = stockService.queryStockByWaybillNo(waybillStockEntity);
					
					//查询库存结果集大于0 再次入库 主要目的是为了修正 错误的库区。
					if(dbQueryList!=null && dbQueryList.size()>0 ){
						// 入库 begin
						for (int s = 0; s < dbQueryList.size(); s++) {
							// 新建入库实例
							InOutStockEntity inOutStockEntity = new InOutStockEntity();
							// 设置运载单号
							inOutStockEntity.setWaybillNO(waybillNo);
							// 设置序列号
							inOutStockEntity.setSerialNO(dbQueryList.get(s).getSerialNO());
							// 设置当前部门
							inOutStockEntity.setOrgCode(dbQueryList.get(s).getOrgCode());
							// 设置操作部门
							inOutStockEntity.setOperatorCode("XJBM");
							// 设置操作部门名称
							inOutStockEntity.setOperatorName("小件补码");
							// 设置入库类型类型
							inOutStockEntity.setInOutStockType(StockConstants.CHANGE_DESTORG_PATH_FOR_EXPRESS_IN_STOCK_TYPE);
							// 入库
							stockService.inStockPC(inOutStockEntity);
						}
						// 入库 end
					}else{
						//不在库存里就不用重新入库了。
					}
				}else{
					logger.error("changePathForExpressToArrivalFirstOrg 获取运单第一补码记录为空,运单号为:" + waybillNo);
					throw new TfrBusinessException("changePathForExpressToArrivalFirstOrg获取运单第一补码记录为空,运单号为:" + waybillNo);
				}
	}
	
	/**
	 * @author nly
	 * @date 2015年5月9日 下午2:39:48
	 * @function 根据运单号或运单号流水号查询走货路径明细
	 * @param waybillNo
	 * @param serialNoList
	 * @return
	 */
	@Override
	public List<PathDetailEntity>  queryPathDetailByNos(String waybillNo,List<String> serialNoList) {
		List<PathDetailEntity> pathDetailList = pathDetailDao.queryPathDetailByNos(waybillNo,serialNoList);
		return pathDetailList;
	}
	
	/**
	 * @author nly
	 * @date 2015年5月9日 下午2:22:26
	 * @function 获取实际走货路径上所有部门
	 * @param waybillNo
	 * @param serialNo
	 * @return
	 */
	@Override
	public List<String> queryPassDeptCodes(String waybillNo,List<String> serialNoList) {
		if(StringUtils.isEmpty(waybillNo)) {
			return null;
		}
		List<PathDetailEntity> pathDetailList = this.queryPathDetailByNos(waybillNo, serialNoList);
		if(CollectionUtils.isEmpty(pathDetailList)) {
			return null;
		}
		Set<String> deptCodes = new TreeSet<String>();
		for(PathDetailEntity pathDetail : pathDetailList) {
			deptCodes.add(pathDetail.getOrigOrgCode());
			deptCodes.add(pathDetail.getObjectiveOrgCode());
		}
		List<String> deptList = new ArrayList<String>(deptCodes);
		return deptList;
	}

	/**
	 * @author 106162
	 * @date 2017年3月24日 下午2:39:48
	 * @function 根据运单号、运单号流水号、当前操作部门 三个参数查询走货路径明细对应的下一站部门
	 * @param waybillNo、goodsNo、origOrgCode
	 * @return nextOrgName
	 * @note   1、业务要求当流水号为空的时候，直接返回空，这个在中转那边做了限制，所以这边的流水号一定不能
	 *         为空。具体找业务（赵景阳咨询）
	 *         2、当流水不为空的时候查询锁定不了单一数据，后台根据路段号倒叙取最大的默认返回
	 */
	@Override
	public String queryPathByWgoService(String waybillNo, String goodsNo,
			String origOrgCode) {
		return transportationPathDao.queryPathByWgoDao(waybillNo, goodsNo, origOrgCode);
	}

}
