/**
 *  initial comments.
 */
/*******************************************************************************
 * Copyright 2013 TFR TEAM
 *  
 *  
 *  Licensed under the DEPPON License, Version 2.0 (the "License");
 *  
 *  
 *  you may not use this file except in compliance with the License.
 *  
 *  
 *  You may obtain a copy of the License at
 *  
 *  
 *  
 *     http://www.deppon.com/licenses/LICENSE-2.0
 *  
 *  
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  
 *  
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  
 *  
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  
 *  See the License for the specific language governing permissions and
 *  
 *  
 *  limitations under the License.
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  PROJECT NAME  : tfr-scheduling
 *  
 *  
 *  
 *  PACKAGE NAME  : 
 * 
 * 
 * 
 *  DESCRIPTION   : 调度、发车计划、排班、月台、车辆管理等
 *  
 *  
 *  
 *  FILE PATH     :src/main/java/com/deppon/foss/module/transfer/scheduling/server/service/impl/ForecastService.java
 * 
 * 
 * 
 *  FILE NAME     :ForecastService.java
 *  
 *  
 *  
 *  AUTHOR        : FOSS中转开发组
 *  
 *  
 *  
 *  TIME          : 
 *  
 *  
 *  
 *  HOME PAGE     :  http://www.deppon.com
 *  
 *  
 *  
 *  COPYRIGHT     : Copyright (c) 2013  Deppon All Rights Reserved.
 * 
 * 
 * 
 *  VERSION       :0.1
 * 
 * 
 * 
 *  LAST MODIFY TIME:
 *  
 *  
 *  
  *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和. *  
 *  1.1	相关业务用例
 *  
 *  BUC_FOSS_5.10.20_010  预测货量
 *  
 *  1.2	用例描述
 *  
 *  系统通过后台job，
 *  
 *  每隔X小时（可配置）定时更新一次预测的货量信息，
 *  
 *  预测各调度区域内分线路未来Y小时（可配置）
 *  当天区域内营业部或开单组已开单未入库、
 *  已出发预计到达以及库存中的货量信息。
 *  
 *  
 *  
 *  1.3	用例条件
 *  
 *  条件类型	描述	引用用例
 *  
 *  
 *  
 *  前置条件	
 *  
 *  1.	营业部或开单组已开单；
 *  
 *  2.	车辆已做出发；
 *  
 *  3.	当天余货有库存信息；
 *  
 *  4.	Job启动参数已经设置	
 *  
 *  
 *  
 *  后置条件
 *  
 *  1.	生成到达货量预测数据；
 *  
 *  2.	生成出发货量预测数据；
 *  
 *  
 *  
 *  1.6	操作步骤
 *  
 *  序号	基本步骤	补充步骤
 *  
 *  1	系统每X小时启动任务,
 *  
 *  进行预测货量计算.	
 *  
 *  每小时做一次货量预测结果的快照，精确到线路，分出发和到达货量
 *  
 * 每天做一次实际货量的统计，
 *  
 *  精确到线路，
 *  
 *  分出发和到达货量
 *  
 *  
 *  
 *  2	按线路分组,
 *  
 *  根据开单后生成的走货路径统计预计到达时间的各段线路开单未交接的货量信息
 *  
 *  查询时,
 *  
 *  针对某一段时间进行信息截取.获得预计到达时间在预测范围内的信息.
 *  
 *  
 *  3	按线路分组,
 *  
 *  统计触发时间点为止的库存货量	
 *  
 *  
 *  4
 * 
 *  按线路分组,
 *  
 *  统计预计到达时间在预测范围内的在途货量.	
 *  
 *  
 *  5	统计2,3,4步骤中被重复统计的货量,
 *  
 *  加以剔除.	
 *  
 *  3类数据有分别小计,
 *  
 *  出现重叠后,
 *  
 *  剔除的优先级为,
 *  
 *  库存>在途>开单. 
 *  
 *  在库又在途的,算至在库中.依此类推
 *  
 *  6	按线路分组统计出发货量	
 *  
 *  在预测时间内,
 *  
 *  考虑货物是否能及时卸完,
 *  
 *  考虑库存量.见SR-1
 *  
 *  
 *  7	
 *  
 *  按线路分组统计到达货量	
 *  
 *  
 *  在预测时间内,计算预计到达的货量.
 *  
 *  
 *  
 *  
 *  1.7	业务规则
 *  
 *  
 *  序号	描述
 *  
 *  
 *  SR-1	
 *  
 *  A:触发时间点为止当天服务区域内所有的开单未交接的货量
 *  
 *  B:触发时间点为止的库存货量
 *  
 *  
 *  C:预计到达时间在预测范围内的在途货量.
 *  
 *  
 *  D:将要在本中转场的驻地派送部进行派送的货物
 *  
 *  出发货量统计=A+B+C1-D
 *  
 *  到达货量统计=A+C2
 *  
 *  说明：
 *  
 *  1、	Y=（预测范围终止时间-预计到达时间）*平均吞吐能力
 *  
 *  X= 车辆载重
 *  
 *  如果Y> X，C1 = X,否则 C1 = Y ,
 *  
 *  表示有可能车辆在预定时间内到达,但无法全部卸完,则该部分货物不能被算在当前时段内的货量中.
 *  
 *  2、	C2 = X, 到达货量不考虑吞吐能力.全部到达货物都计算在到达货量中.
 *  
 *  3、	B的计算方法:
 *  
 *  本周期为当前库存量.
 *  
 *  计算时需要考虑当天清仓的操作,在清仓操作完成后,使用清仓后的数据进行预测计算.
 *  
 *  之后第1周期的出发货量 减 第1周期的发车计划总量, 为负则当作0.
 *  
 *  依此类推, 如果之后的第N周期无发车计划, 则当作库存为0, 出发货量等于到达货量.
 *  
 *  
 *  
 *  SR-2	
 *  
 *  线路上运行的车辆预计到达时间由GPS提供；如果无GPS，计算时取车辆跟踪的预计到达时间
 *  
 *  SR-3	
 *  
 *  考虑外场平均吞吐能力 : Z吨/小时,不单独考虑人数,装卸速率.
 *  
 *  整车的货物按照吞吐能力考虑后，需要确定能否赶上计划的离开时间，赶不上则刷新计划的离开时间到下个时间节点.
 *  
 *  
 *  SR-4	
 *  
 *  统计总货量预测中卡货货量信息, 
 *  
 *  卡货为开单时运输类型开单为精准卡航的货物.
 *  
 *  统计总货量预测中城运货量信息, 
 *  
 *  城运为开单时运输类型开单为精准城运的货物.
 *  
 *  
 *  
 *  
 *  
 *  1.8.1	货量报表信息
 *  
 *  字段名称 	说明 	输入限制	提示输入本文	长度	是否必填	备注
 *  
 *  调度名称	中转调度所在的部门	文本		20	是	
 *  
 *  线路	包含走货流程中的出发地和目的地的组合	文本		20	是	
 *  
 *  总重量	货物的总重量，单位：公斤	数字		20	是	
 *  
 *  总体积	货物的总体积，单位：方	数字		20	是	
 *  
 *  总票数	货物的总票数，单位：票	数字		20	是	
 *  
 *  卡货总重量/总体积/总票数	运输类型开单为精准卡航的货物重量/体积/票数	数字			是	
 *  
 *  城货总重量/总体积/总票数	运输类型开单为精准城运的货物重量/体积/票数	数字			是	
 *  
 *  开单未交接总重量/总体积/总票数	预测时间点服务区域内已开单未交接的货物重量/体积/票数	数字			是	
 *  
 *  预计到达总重量/总体积/总票数	预测时间范围内预计到达的货物重量/体积/票数	数字			是	
 *  
 *  卸货中总重量/总体积/总票数	预测时间范围内卸货中的货物重量/体积/票数	数字			是	
 *  
 *  余货总重量/总体积/总票数	预测时间点库存余货的货物重量/体积/票数	数字			是	
 *  
 *  
 *  
 *  
 * 1.8	数据元素
 * 
 * 字段名称 	说明 	输入限制	输入项提示文本	长度	是否必填	备注
 * 
 * 货物运单号	该批货物的运单号					由运单信息提供
 * 
 * 
 * 货物流水号	该货物的流水号					由运单信息提供
 * 
 * 
 * 货物出发地	该货物的出发营业部					由运单信息提供/多货和手工修改时为当前操作外场驻地营业部
 * 
 * 
 * 货物到达地	货物的到达营业部/虚拟营业部					由运单信息提供
 * 
 * 运输方式	该段线路所选择的运输方式					
 * 
 * 线路段号	同一货物可能有多段线路,该字段代表了它们的排列顺序.		
 * 
 * 
 * 
 * 
 * 
 * 
 * 功能性需求
 * 
 * 单位时间使用量	每1小时执行一次预测,每1天执行一次实际统计,可配置.
 * 
 * 线路数量,按目前70+外场,2000+营业部门计算,有6000-8000条支干线线路.
 * 
 * 2012年全网估计用户数	1
 * 
 * 响应要求（如果与全系统要求 不一致的话）	预测统计执行时长不超过10分钟
 * 
 * 使用时间段	全天
 * 
 * 
 * 
 * 高峰使用时间段	晚上8-12点
 *
 * 
 * 
 * 			
 *1.	SUC-63查询预测货量
 *
 *1.1	相关业务用例
 *
 *
 *BUC_FOSS_5.10.20_010 预测货量
 *
 *
 *
 *1.2	用例描述
 *
 *
 *本用例根据系统后台计算统计出的预测货量信息，
 *
 *用于各外场和车队查询本外场的出发或到达预测货量信息，
 *
 *及营业部或派送部查询到达预测货量信息。
 *
 *
 *1.3	用例条件
 *
 *条件类型	描述	引用用例
 *
 *
 *前置条件	
 *
 *已有货量预测结果	货量预测
 *
 *
 *后置条件	
 *
 *根据查询出的预测货量信息做长途发车计划、短途发车计划
 *
 *或
 *
 *根据查询出的预测货量信息对比历史货量
 *
 *或
 *
 *根据查询出的货量进行合车调整	录入发车计划（长途）、录入发车计划（短途）
 *
 *
 *对比历史货量
 *
 *1.4	操作用户角色
 *
 *操作用户	描述
 *
 *外场调度	查询本外场的预测出发货量或到达货量信息
 *
 *外场管理人员	（经理级以上人员）查询本外场的预测出发货量或到达货量信息
 *
 *车队调度	查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *车队管理人员	（经理级以上人员）查询本车队对应外场的预测出发货量或到达货量信息
 *
 *
 *
 *
 *1.5.3	界面描述
 *
 *
 *一、	查询预测货量界面：
 *
 *
 *本界面主要包括2部分：
 *
 *预测货量查询条件、
 *
 *预测货量结果列表
 *
 *
 *1、查询条件包含：
 *
 *预测类型、预测线路、时间范围；
 *
 *预测类型：分为出发和到达两种类型
 *
 *预测线路：选择某一线路进行显示，过滤出与本部门有关的线路，如出发时，线路出发部门是本部门，到达时，线路到达部门是本部门的线路信息，且预测线路可以多选。
 *
 *时间范围：根据各外场的灵活配置，选择从某一时间点开始未来24小时内的时间段；
 *
 *2、列表信息包含：
 *
 *区域、
 *
 *目的地、
 *
 *总重量/总体积/总票数、
 *
 *卡货总重量/总体积/总票数、
 *
 *城货总重量/总体积/总票数、
 *
 *开单未交接总重量/体积/票数、
 *
 *在途总重量/总体积/总票数、
 *
 *库存总重量/总体积/总票数。
 *
 *具体说明见数据元素【预测货量列表信息】
 *
 *
 *3、列表上面，
 *
 *应显示查询结果对应的时间范围标签
 *
 *
 *4、线路前面有复选框可勾选，
 *
 *进入合发调整界面，
 *
 *合发之后调货的货量显示在”重量差”列.
 *
 *
 *5、按钮：
 *
 *查询、路径调整、查看总量统计图表、查看图表、发车计划、导出货量预测、导出货量预测明细；
 *
 *查询：
 *
 *普通按钮，根据查询条件显示出满足条件的结果信息；
 *
 * 
 * 路径调整：
 * 
 * 图片按钮，根据选择条目，弹出路径调整页面，若为多选，则进入合车调整页，若为单选。则进入路径调整页。
 * 
 * 
 * 总量统计图表：
 * 
 * 图片按钮，显示本部门总的货量出发或到达货量信息图形表示形
 * 
 * 
 * 查看图表：
 * 
 * 图片按钮，显示本部门分线路总的货量出发活到达货量信息图形表示形式
 * 
 * 
 * 发车计划：
 * 
 * 点击后可进入发车计划界面
 * 
 * 
 * 导出货量预测：
 * 
 * 图片按钮，根据查询项导出货量预测信息
 * 
 * 
 * 导出货量预测明细：
 * 
 * 图片按钮，根据某一特定条目，导出到达该目的地的开单及在途明细货量信息
 * 
 * 
 * 6、列表排列方式见业务规则SR-4
 * 
 * 
 * 
 * 二、	查询分线路预测货量明细界面：
 * 
 * 以预测来源分组显示结果，
 * 
 * 如果为如果预测类型为出发，
 * 
 * 分为开单未交接、在途、库存；
 * 
 * 如果预测类型为到达，
 * 
 * 分为开单未交接、在途，
 * 
 * 明细列表显示信息参见【预测货量线路明细】
 * 
 * 
 * 三、	合车调整页面
 * 
 * 进入后，
 * 
 * 按照走货路径调整的实际情况，
 * 
 * 将某条路径的货物调整至另一路径，
 * 
 * 保存以进行记录.
 * 
 * 
 * 
 * 四、	查询预测货量界面
 * 
 * 合成修改后，合车重量项会显示调整的货物重量值，以正负来表示增加或减少.
 * 
 * 
 * 
 * 五、	合车明细页面
 * 
 * 合车修改后,
 * 
 * 点击合车重量项中的数字,
 * 
 * 会弹出小窗明细该线路合车货物来源及去向明细信息.
 *
 *
 *
 *
 *1.6	操作步骤
 *
 *
 *
 *1、查询预测货量：
 *
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *
 *1	调度或外场点击菜单进入查询预测货量界面	
 *
 *
 *	默认预测类型为出发，时间范围为各外场配置的时间段
 *
 *2	选择预测类型		当选择到达类型时，
 *
 *预测来源：有开单未交接、在途、库存三种来源.
 *
 *
 *出发货量预测三者都选取,并且需要排除最后到达站为本外场的部分.
 *
 *到达货量预测只取开单未交接及在途, 库存被抛除。
 *
 *
 *4	选择预测的目的地信息		
 *
 *默认展示本部门对应的所有目的地的条目信息，
 *
 *如果需要选择目的地，
 *
 *弹出公共选择器，
 *
 *根据选择的预测类型进行过滤线路，参见【业务规则3】
 *
 *
 *5	选择需要预测的时间范围		
 *
 *下拉框格式为20120612-X～20120613-X, X为时间点,各外场可以设置这个周期起止时间点.查询最多支持7个预测周期.
 *
 *
 *6	点击查询按钮，
 *
 *显示满足条件的出发或到达货量信息	
 *
 *【预测货量列表信息】	
 *
 *结果信息根据各目的地对应区域的关系，
 *
 *聚合显示在一起
 *
 *2、查看预测货量各线路明细
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，点击某一条线路信息		弹出线路货量明细查看窗口，以预测来源分组显示结果：
 *
 *1、	如果预测类型为出发，分为三类：
 *
 *开单未交接、在途、库存，显示明细参见界面描述部分；
 *
 *2、	如果预测类型为到达，分为两类：
 *
 *开单未交接、在途，显示明细参见界面描述部分。
 *
 *
 *序号	扩展事件	相关数据	备注
 *
 *
 *
 *3、合车调整:
 *
 *序号	基本步骤	相关数据	补充步骤
 *
 *1	根据查询出的结果，
 *
 *勾选某两条线路信息,
 *
 *点击合车调整按钮.		
 *
 *弹出合车调整子页面.
 *
 *2	填写需要调整的货物重量,
 *
 *选择调整方向.
 *
 *A至B或B至A.
 *
 *点击保存进行调整.
 *
 *调整后的结果会显示在主查询页面中的重量差一列中.		
 *
 *点击确定提交调整,取消则回到原状态.
 *
 *
 *
 *
 *1.7	业务规则
 *
 *序号	描述
 *
 *
 *SR-1	
 *
 *
 *当预测到达类型货量时，列
 *
 *表中的库存余货货量为空
 *
 *
 *SR-2	
 *
 *货量分线路，
 *
 *线路可按照区域(如华南、华东)聚合显示在一起，
 *
 *区域名称以及区域和目的地的关系可维护
 *
 *
 *SR-3	
 *
 *当预测类型为出发时，
 *应只有对应线路为本部门出发的可供选择；
 *当预测类型为到达时，
 *应只有对应线路信息为到达本部门的可选择
 *
 *
 *SR-4	
 *
 *列表的排列方式:
 *
 *由提供线路信息的基础数据组提供每条线路的权重值,
 *
 *按照权重进行展示排列.
 *
 *该权重值只针对货量预测部分进行配置.
 *
 *SR-5	货量预测结果可以导出，
 *
 *列表不展开到明细时，按照列表结果导出
 *
 *列表展开到明细，明细提供一个单独的导出，
 *
 *只导出当前条目的明细到营业区的货量，
 *
 *导出结果要求细分到具体营业部的货量,营业区货量取所有管辖营业部之和.
 *
 *
 *
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 ***
 ****************************************************************************/
package com.deppon.foss.module.transfer.scheduling.server.service.impl;
/**
 * 导入包
 */
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.struts2.ServletActionContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.deppon.foss.base.util.define.BizTypeConstants;
import com.deppon.foss.framework.server.components.export.excel.ExcelExporter;
import com.deppon.foss.framework.server.components.export.excel.ExportResource;
import com.deppon.foss.framework.server.components.export.excel.ExportSetting;
import com.deppon.foss.framework.shared.util.classes.BeanUtils;
import com.deppon.foss.framework.shared.util.string.StringUtil;
import com.deppon.foss.module.base.baseinfo.api.server.service.IGoodsAreaService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IHeavyBubbleRatioService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ILineService;
import com.deppon.foss.module.base.baseinfo.api.server.service.IOrgAdministrativeInfoService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ISaleDepartmentService;
import com.deppon.foss.module.base.baseinfo.api.server.service.ISiteGroupService;
import com.deppon.foss.module.base.baseinfo.api.server.service.complex.IOrgAdministrativeInfoComplexService;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.GoodsAreaEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.LineEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.OrgAdministrativeInfoEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.SaleDepartmentEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.domain.SiteGroupEntity;
import com.deppon.foss.module.base.baseinfo.api.shared.dto.NetGroupSiteDto;
import com.deppon.foss.module.base.dict.api.server.service.IConfigurationParamsService;
import com.deppon.foss.module.base.dict.api.shared.define.ConfigurationParamsConstants;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryConstants;
import com.deppon.foss.module.base.dict.api.shared.define.DictionaryValueConstants;
import com.deppon.foss.module.base.dict.api.shared.domain.ConfigurationParamsEntity;
import com.deppon.foss.module.transfer.common.api.server.service.ITfrCommonService;
import com.deppon.foss.module.transfer.common.api.shared.define.PricingConstants;
import com.deppon.foss.module.transfer.common.api.shared.exception.TfrBusinessException;
import com.deppon.foss.module.transfer.load.api.shared.define.LoadConstants;
import com.deppon.foss.module.transfer.load.api.shared.define.TaskTruckConstant;
import com.deppon.foss.module.transfer.scheduling.api.define.ForecastConstants;
import com.deppon.foss.module.transfer.scheduling.api.define.TransportPathConstants;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IAverageCalculateDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IBillingDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IChangeQuantityDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IForecastQuantityDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IInTransitDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.IPathDetailDao;
import com.deppon.foss.module.transfer.scheduling.api.server.dao.ITransportationPathDao;
import com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService;
import com.deppon.foss.module.transfer.scheduling.api.server.service.IRealWeightAndVolumeDao;
import com.deppon.foss.module.transfer.scheduling.api.server.service.IStowagePlansService;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.AverageCalculateEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.BillingEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.ChangeQuantityEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.ForecastQuantityEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.InTransitEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.PathDetailEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.StatisticalInquiriesEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.domain.TransportPathEntity;
import com.deppon.foss.module.transfer.scheduling.api.shared.dto.ForecastDto;
import com.deppon.foss.module.transfer.scheduling.api.shared.dto.RealWeightAndVolumeDto;
import com.deppon.foss.module.transfer.scheduling.api.shared.dto.StatisticalInquiriesDto;
import com.deppon.foss.module.transfer.scheduling.api.shared.util.ConstantsNumberSonar;
import com.deppon.foss.module.transfer.scheduling.api.shared.util.TimeUtils;
import com.deppon.foss.module.transfer.scheduling.api.shared.vo.ForecastVO;
import com.deppon.foss.module.transfer.stock.api.shared.exception.StockException;
import com.deppon.foss.util.DateUtils;
import com.deppon.foss.util.UUIDUtils;
import com.deppon.foss.util.define.FossConstants;

/**
 * 预测货量service实现类
 * 
 * 
 * 
 * @author huyue
 * @date 2012-10-31 下午5:23:40
 */
public class ForecastService implements IForecastService {
	/**
	 * logger
	 */
	protected final Logger logger = LoggerFactory.getLogger(getClass());
	/**
	 * 货量预测dao
	 */
	private IForecastQuantityDao forecastQuantityDao;
	/**
	 * 货量预测开单量dao
	 */
	private IBillingDao billingDao;
	/**
	 * 货量预测在途量dao
	 */
	private IInTransitDao inTransitDao;
	/**
	 * 货量预测改变dao
	 */
	private IChangeQuantityDao changeQuantityDao;
	/**
	 * 走货路径dao
	 */
	private ITransportationPathDao transportationPathDao;
	/**
	 * 走货路径明细dao
	 */
	private IPathDetailDao pathDetailDao;
	/**
	 * 实际重量和体积dao
	 */
	private IRealWeightAndVolumeDao realWeightAndVolumeDao;
	/**
	 * 平均重量体积dao
	 */
	private IAverageCalculateDao averageCalculateDao;
	/**
	 * 货量预测service
	 */
	private IForecastService forecastService;
	/**
	 * 中转公共service
	 */
	private ITfrCommonService tfrCommonService;
	/**
	 * 货区service
	 */
	private IGoodsAreaService goodsAreaService;
	/**
	 * 营业部门service
	 */
	private ISaleDepartmentService saleDepartmentService;
	/**
	 * 组织相关service
	 */
	private IOrgAdministrativeInfoService orgAdministrativeInfoService;
	/**
	 * 组织相关service
	 */
	private IOrgAdministrativeInfoComplexService orgAdministrativeInfoComplexService;
	/**
	 * 线路service
	 */
	private ILineService lineService;
	/**
	 * 配置参数service
	 */
	private IConfigurationParamsService configurationParamsService;
	/**
	 * 网点组service
	 */
	private ISiteGroupService siteGroupService;
	/**
	 * 配载方案配置
	 */
	private IStowagePlansService stowagePlansService;
	/**
	 * 重泡比 zwd
	 */
		private IHeavyBubbleRatioService heavyBubbleRatioService;
	/**
	 * 重泡比 zwd
	 */
	public void setHeavyBubbleRatioService(
			IHeavyBubbleRatioService heavyBubbleRatioService) {
		this.heavyBubbleRatioService = heavyBubbleRatioService;
	}

	/**
	 * 常量
	 */
	private static final int three = 3;
	private static final int four = 4;
	
	/**
	 * 为了防止BigDecimal除出来的小数为无穷大 所以 在非汇总(为指定精度)的时候截取10位小数
	 * PS : 截取高的精度是为了减小计算误差
	 */
	private static final int ten = 10;
	/**
	 * 常量
	 */
	private int day1 = 1;
	/**
	 * 常量
	 */
	private int day2 = ConstantsNumberSonar.SONAR_NUMBER_30;
	/**
	 * 常量
	 */
	private String start1 = "0300";
	/**
	 * 常量
	 */
	private String start2 = "0000";
	/**
	 * 常量
	 */
	private static final int ton = 1000;
	/**
	 * 出发部门
	 */
	private static final String origOrg = "origOrgCode";
	/**
	 * 目的部门
	 */
	private static final String objective = "objectiveOrgCode";
	/**
	 * countStartTime 小于等于  MODIFY_START_TIME(调整出发时间)
	 */
	private static final String countStartTime = "countStartTime";
	/**
	 * countEndTime 大于   MODIFY_START_TIME(调整出发时间)
	 */
	private static final String countEndTime = "countEndTime";
	/**
	 * 抵达/离开
	 */
	private static final String arriveOrLeave = "arriveOrLeave";
	/**
	 * 设置
	 */
	public void setRealWeightAndVolumeDao(IRealWeightAndVolumeDao realWeightAndVolumeDao) {
		this.realWeightAndVolumeDao = realWeightAndVolumeDao;
	}
	/**
	 * 设置
	 */
	public void setSaleDepartmentService(ISaleDepartmentService saleDepartmentService) {
		this.saleDepartmentService = saleDepartmentService;
	}
	/**
	 * 设置
	 */
	public void setOrgAdministrativeInfoComplexService(IOrgAdministrativeInfoComplexService orgAdministrativeInfoComplexService) {
		this.orgAdministrativeInfoComplexService = orgAdministrativeInfoComplexService;
	}
	/**
	 * 设置
	 */
	public void setLineService(ILineService lineService) {
		this.lineService = lineService;
	}
	/**
	 * 设置
	 */
	public void setConfigurationParamsService(IConfigurationParamsService configurationParamsService) {
		this.configurationParamsService = configurationParamsService;
	}
	/**
	 * 获取
	 */
	public IForecastQuantityDao getForecastQuantityDao() {
		return forecastQuantityDao;
	}
	/**
	 * 设置
	 */
	public void setForecastQuantityDao(IForecastQuantityDao forecastQuantityDao) {
		this.forecastQuantityDao = forecastQuantityDao;
	}
	/**
	 * 获取
	 */
	public IBillingDao getBillingDao() {
		return billingDao;
	}
	/**
	 * 设置
	 */
	public void setBillingDao(IBillingDao billingDao) {
		this.billingDao = billingDao;
	}
	/**
	 * 获取
	 */
	public IInTransitDao getInTransitDao() {
		return inTransitDao;
	}
	/**
	 * 设置
	 */
	public void setInTransitDao(IInTransitDao inTransitDao) {
		this.inTransitDao = inTransitDao;
	}
	/**
	 * 获取
	 */
	public IPathDetailDao getPathDetailDao() {
		return pathDetailDao;
	}
	/**
	 * 设置
	 */
	public void setPathDetailDao(IPathDetailDao pathDetailDao) {
		this.pathDetailDao = pathDetailDao;
	}
	/**
	 * 获取
	 */
	public IChangeQuantityDao getChangeQuantityDao() {
		return changeQuantityDao;
	}
	/**
	 * 设置
	 */
	public void setChangeQuantityDao(IChangeQuantityDao changeQuantityDao) {
		this.changeQuantityDao = changeQuantityDao;
	}
	/**
	 * 获取
	 */
	public ITransportationPathDao getTransportationPathDao() {
		return transportationPathDao;
	}
	/**
	 * 设置
	 */
	public void setTransportationPathDao(ITransportationPathDao transportationPathDao) {
		this.transportationPathDao = transportationPathDao;
	}
	/**
	 * 获取
	 */
	public IForecastService getForecastService() {
		return forecastService;
	}
	/**
	 * 获取
	 */
	public ITfrCommonService getTfrCommonService() {
		return tfrCommonService;
	}
	/**
	 * 设置
	 */
	public void setForecastService(IForecastService forecastService) {
		this.forecastService = forecastService;
	}
	/**
	 * 设置
	 */
	public void setTfrCommonService(ITfrCommonService tfrCommonService) {
		this.tfrCommonService = tfrCommonService;
	}
	/**
	 * 获取
	 */
	public IGoodsAreaService getGoodsAreaService() {
		return goodsAreaService;
	}
	/**
	 * 设置
	 */
	public void setGoodsAreaService(IGoodsAreaService goodsAreaService) {
		this.goodsAreaService = goodsAreaService;
	}
	/**
	 * 获取
	 */
	public IOrgAdministrativeInfoService getOrgAdministrativeInfoService() {
		return orgAdministrativeInfoService;
	}
	/**
	 * 设置
	 */
	public void setOrgAdministrativeInfoService(IOrgAdministrativeInfoService orgAdministrativeInfoService) {
		this.orgAdministrativeInfoService = orgAdministrativeInfoService;
	}
	/**
	 * 获取
	 */
	public IAverageCalculateDao getAverageCalculateDao() {
		return averageCalculateDao;
	}
	/**
	 * 设置
	 */
	public void setAverageCalculateDao(IAverageCalculateDao averageCalculateDao) {
		this.averageCalculateDao = averageCalculateDao;
	}
	/**
	 * 设置
	 */
	public void setSiteGroupService(ISiteGroupService siteGroupService) {
		this.siteGroupService = siteGroupService;
	}

	/**
	 * @param stowagePlansService the stowagePlansService to set
	 */
	public void setStowagePlansService(IStowagePlansService stowagePlansService) {
		this.stowagePlansService = stowagePlansService;
	}
	
	
	/**
	 * 查询数据字典，查出快递货物体积的比率
	 * @author 200978-foss-xiaobingcheng
	 * 2014-8-8
	 * @return
	 */
	public BigDecimal queryForecastParameter(String orgCode){

		// zwd 调用综合接口，根据部门编码去查询重泡比，如果存在则使用查询到的重泡比，如果不存在则使用公用的重量体积转换参数。
		BigDecimal converParameter=BigDecimal.ZERO;
		String  stringValue = "";
		try{
			if(StringUtils.isNotEmpty(orgCode)){
				// zwd 调用综合接口，根据部门编码去查询重泡比，如果存在则使用查询到的重泡比，如果不存在则使用公用的重量体积转换参数。
				stringValue = heavyBubbleRatioService.queryHeavyBubbleParamByOutfield(orgCode);
			}
		}catch(Exception e){
			throw new TfrBusinessException("调综合接口根据外场编码来查询重泡比参数异常"+e.toString());
		}
		if(stringValue!=null && StringUtils.isNotEmpty(stringValue)){
			double doubleValue = Double.valueOf(stringValue.toString());
			converParameter = new BigDecimal(doubleValue);
			BigDecimal a =new BigDecimal("1.000");
			//重泡比为重量体积转换参数分之一
			 converParameter = a.divide(converParameter,ConstantsNumberSonar.SONAR_NUMBER_3);
			 return converParameter;
		}else{
			ConfigurationParamsEntity paramEntity = configurationParamsService.queryConfigurationParamsByOrgCode(
					DictionaryConstants.SYSTEM_CONFIG_PARM__TFR , 
					ConfigurationParamsConstants.TFR_PARM_EXPRESS_CONVERTVOLUME_PARAMETERS, 
					"DIP");
			if(paramEntity!=null){
				String value=paramEntity.getConfValue();
				try {
					double dvalue = Double.parseDouble(value);
					converParameter = new BigDecimal(dvalue);
				} catch (Exception e) {
					throw new TfrBusinessException("快递转换体积参数转换错误："+e.toString());
				}
				return converParameter;
				
			}else{
				throw new TfrBusinessException("请配置快递转换体积参数！");
			}
		}
		}
	
	
	
	/**
	 * 分页查询 并且根据数据进行统计
	 * 
	 * @author huyue
	 * @date 2012-11-22 上午10:47:16
	 */
	public List<ForecastQuantityEntity> queryByPage(ForecastQuantityEntity forecastQuantityEntity, int page, int count) throws TfrBusinessException {
		// 根据组织号获取地区list
		List<ForecastQuantityEntity> regionList = forecastQuantityDao.queryByRegionList(forecastQuantityEntity);
		//新建list
		List<ForecastQuantityEntity> forecastQuantityList = new ArrayList<ForecastQuantityEntity>();
		//循环
		for (int i = 0; i < count; i++) {
			//计算行值
			int row = page * count + i;
			if (row < regionList.size()) {
				// 获取地区LIST时过滤掉了到达部门,在查询条件中加入
				if (StringUtils.isNotEmpty(forecastQuantityEntity.getRelevantOrgCode())) {
					//设置相关部门
					regionList.get(row).setRelevantOrgCode(forecastQuantityEntity.getRelevantOrgCode());
				}
				//查询list
				List<ForecastQuantityEntity> list = forecastQuantityDao.queryforecastQuantityList(regionList.get(row));
				//循环
				for (int q = 0; q < list.size(); q++) {
					//设置所属部门名称
					list.get(q).setBelongOrgCodeName(getNameByCode(list.get(q).getBelongOrgCode()));
					//设置相关部门名称
					list.get(q).setRelevantOrgCodeName(getNameByCode(list.get(q).getRelevantOrgCode()));
					//如果网点组不为空
					if (StringUtils.isNotEmpty(list.get(q).getRegion()) && null != siteGroupService.querySiteGroupByCode(list.get(q).getRegion())) {
						//设置名称
						list.get(q).setRegionName(siteGroupService.querySiteGroupByCode(list.get(q).getRegion()).getName());
					}
					
					//xiaobc   start ..............................
					//快递
				 //zwd 调用综合接口，根据部门编码去查询重泡比，如果存在则使用查询到的重泡比，如果不存在则使用公用的重量体积转换参数。
					    String orgCode = list.get(q).getBelongOrgCode();
						BigDecimal volumeRatio =  this.queryForecastParameter(orgCode);//拿到快递体积比率
						BigDecimal weight = list.get(q).getExpressWeightTotal();//拿到快递重量
						BigDecimal srcVolume = list.get(q).getExpressVolumeTotal();//记录原始快递总体积
						BigDecimal volume = weight.multiply(volumeRatio);//快递总体积=快递总重量*快递体积比率
						volume = volume.setScale(four,BigDecimal.ROUND_HALF_DOWN);//保留三位小数		
						list.get(q).setExpressVolumeTotal(volume);
					//总数
						BigDecimal volumeTotal = list.get(q).getVolumeTotal();//拿到总体积
						volumeTotal = volumeTotal.subtract(srcVolume).add(volume);//总体积减去快递原始体积，加上转换后的体积
						volumeTotal = volumeTotal.setScale(four,BigDecimal.ROUND_HALF_DOWN);//保留三位小数
						list.get(q).setVolumeTotal(volumeTotal);
					
					//xiaobc   end ..............................
						
				}
				//添加到list
				forecastQuantityList.addAll(list);
			}
		}
		//返回
		return forecastQuantityList;
	}
	
	/**
	 * 根据地区分页获取全部地区count
	 * @author huyue
	 * @date 2013-3-15 上午10:29:52
	 */
	public int queryByPageCount(ForecastQuantityEntity forecastQuantityEntity){
		// 根据组织号获取地区list
		List<ForecastQuantityEntity> regionList = forecastQuantityDao.queryByRegionList(forecastQuantityEntity);
		//返回
		return regionList.size();
	}
	

	/**
	 * 分页getCount
	 * 
	 * @author huyue
	 * @date 2012-11-22 下午5:24:42
	 */
	@Override
	public Long getCount(ForecastQuantityEntity forecastQuantityEntity) {
		//返回
		return forecastQuantityDao.getCount(forecastQuantityEntity);
	}

	/**
	 * 查询某外场最新一批货量预测的预测天数LIST
	 * 
	 * @author huyue
	 * @date 2012-11-30 下午2:43:20
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#queryForecastTimeList(com.deppon.foss.module.transfer.scheduling.api.shared.domain.ForecastQuantityEntity)
	 */
	@Override
	public List<Date> queryForecastTimeList(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		//返回
		return forecastQuantityDao.queryForecastTimeList(forecastQuantityEntity);
	}

	/**
	 * 查询某外场最新一批货量预测的预测时间
	 * 
	 * @author huyue
	 * @date 2012-12-14 下午9:51:08
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#selectMaxStatisticsTime(com.deppon.foss.module.transfer.scheduling.api.shared.domain.ForecastQuantityEntity)
	 */
	@Override
	public Date selectMaxStatisticsTime(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		//返回
		return forecastQuantityDao.selectMaxStatisticsTime(forecastQuantityEntity);
	}

	/**
	 * 查询外场某线路总货量预测
	 * 
	 * @author huyue
	 * @date 2012-11-15 下午5:43:21
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#queryForecastQuantityList()
	 */
	@Override
	public List<ForecastQuantityEntity> queryForecastQuantityList(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		//根据周期和其他参数查询总表信息 返回list
		List<ForecastQuantityEntity> forecastQuantityList = forecastQuantityDao.selectByPeriod(forecastQuantityEntity);
		//循环
		for (int q = 0; q < forecastQuantityList.size(); q++) {
			//设置所属部门
			forecastQuantityList.get(q).setBelongOrgCodeName(getNameByCode(forecastQuantityList.get(q).getBelongOrgCode()));
			//设置相关部门
			forecastQuantityList.get(q).setRelevantOrgCodeName(getNameByCode(forecastQuantityList.get(q).getRelevantOrgCode()));
			//如果地区不为空
			if (StringUtils.isNotEmpty(forecastQuantityList.get(q).getRegion()) && null != siteGroupService.querySiteGroupByCode(forecastQuantityList.get(q).getRegion())) {
				//设置地区名称
				forecastQuantityList.get(q).setRegionName(siteGroupService.querySiteGroupByCode(forecastQuantityList.get(q).getRegion()).getName());
			}
		}
		//返回
		return forecastQuantityList;
	}

	/**
	 * 查询外场所有线路总货量预测
	 * 
	 * @author huyue
	 * @date 2012-12-4 下午3:41:06
	 */
	public List<ForecastQuantityEntity> queryTotalList(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		//新建list
		List<ForecastQuantityEntity> totalList = new ArrayList<ForecastQuantityEntity>();
		//根据周期和其他参数查询总表信息 返回list
		List<ForecastQuantityEntity> forecastQuantityList = forecastQuantityDao.selectByPeriod(forecastQuantityEntity);
		//循环
		if (forecastQuantityList.size() > 0) {
			//循环
			for (int q = 0; q < forecastQuantityList.size(); q++) {
				//设置所属部门
				forecastQuantityList.get(q).setBelongOrgCodeName(getNameByCode(forecastQuantityList.get(q).getBelongOrgCode()));
				//设置相关部门
				forecastQuantityList.get(q).setRelevantOrgCodeName(getNameByCode(forecastQuantityList.get(q).getRelevantOrgCode()));
				//如果不为空
				if (StringUtils.isNotEmpty(forecastQuantityList.get(q).getRegion()) && null != siteGroupService.querySiteGroupByCode(forecastQuantityList.get(q).getRegion())) {
					//设置地区
					forecastQuantityList.get(q).setRegionName(siteGroupService.querySiteGroupByCode(forecastQuantityList.get(q).getRegion()).getName());
				}
			}
			// 创建有序set
			Set<String> setStatisticsHHMM = new LinkedHashSet<String>();
			//循环
			for (int i = 0; i < forecastQuantityList.size(); i++) {
				// 把24小时都加进LIST中.便于后面分时间点统计
				setStatisticsHHMM.add(forecastQuantityList.get(i).getStatisticsHHMM());
			}
			// 复制模版
			//新建entity
			ForecastQuantityEntity modelEntity = new ForecastQuantityEntity();
			//复制
			BeanUtils.copyProperties(forecastQuantityList.get(0), modelEntity);
			
			modelEntity.setRelevantOrgCode(null);
			modelEntity.setWeightTotal(null);
			modelEntity.setVolumeTotal(null);
			modelEntity.setWaybillQtyTotal(null);
			modelEntity.setStatisticsHHMM(null);
			
			Object statisticsHHMM[] = setStatisticsHHMM.toArray();
			//循环
			for (int i = 0; i < statisticsHHMM.length; i++) {
				// 设置统计字段
				//设置重量为0
				BigDecimal weightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
				//设置体积为0
				BigDecimal volumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
				//设置件数为0
				Integer waybillQtyTotal = 0;
				//循环
				for (int j = 0; j < forecastQuantityList.size(); j++) {
					// 如果相等则累计
					if (StringUtils.equals(statisticsHHMM[i].toString(), forecastQuantityList.get(j).getStatisticsHHMM())) {
						//重量累计
						weightTotal = weightTotal.add(forecastQuantityList.get(j).getWeightTotal());
						//体积累计
						volumeTotal = volumeTotal.add(forecastQuantityList.get(j).getVolumeTotal());
						//件数累计
						waybillQtyTotal += forecastQuantityList.get(j).getWaybillQtyTotal();
					}
				}
				//设置新entity
				ForecastQuantityEntity newEntity = new ForecastQuantityEntity();
				//复制
				BeanUtils.copyProperties(modelEntity, newEntity);
				//设置重量
				newEntity.setWeightTotal(weightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
				//设置体积
				newEntity.setVolumeTotal(volumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
				//设置件数字
				newEntity.setWaybillQtyTotal(waybillQtyTotal);
				//设置时间
				newEntity.setStatisticsHHMM(statisticsHHMM[i].toString());
				//添加到list
				totalList.add(newEntity);
			}
		}
		//返回list
		return totalList;

	}

	/**
	 * 根据特定时间点查询货量预测.如果为总量则进行统计
	 * 
	 * @author huyue
	 * @date 2012-12-4 下午5:12:18
	 */
	public ForecastQuantityEntity querySpecHourList(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		// 判断是否总量
		if (StringUtils.isNotEmpty(forecastQuantityEntity.getRelevantOrgCode())) {
			// 不是总量
			List<ForecastQuantityEntity> forecastQuantityList = queryForecastQuantityList(forecastQuantityEntity);
			//如果是一条
			if (forecastQuantityList.size() == 1) {
				//设置所属部门
				forecastQuantityList.get(0).setBelongOrgCodeName(getNameByCode(forecastQuantityList.get(0).getBelongOrgCode()));
				//设置相关部门
				forecastQuantityList.get(0).setRelevantOrgCodeName(getNameByCode(forecastQuantityList.get(0).getRelevantOrgCode()));
				//如果区域不为空
				if (StringUtils.isNotEmpty(forecastQuantityList.get(0).getRegion()) && null != siteGroupService.querySiteGroupByCode(forecastQuantityList.get(0).getRegion())) {
					//设置地区
					forecastQuantityList.get(0).setRegionName(siteGroupService.querySiteGroupByCode(forecastQuantityList.get(0).getRegion()).getName());
				}
				//返回
				return forecastQuantityList.get(0);
			//如果大于1条
			} else if (forecastQuantityList.size() > 1) {
				//报异常
				throw new TfrBusinessException(ForecastConstants.FORECAST_TIMEPOINT_MORETHANONE, "");
			//如果小于1条
			} else {
				//返回空
				return null;
			}
		} else {
			// 总量 需要合并
			//查询外场某线路总货量预测
			List<ForecastQuantityEntity> forecastQuantityList = queryForecastQuantityList(forecastQuantityEntity);
			//如不为空
			if (CollectionUtils.isNotEmpty(forecastQuantityList)) {
				//新建entity
				ForecastQuantityEntity newEntity = new ForecastQuantityEntity();
				//复制
				BeanUtils.copyProperties(forecastQuantityList.get(0), newEntity);
				//设置所属部门
				newEntity.setBelongOrgCodeName(getNameByCode(newEntity.getBelongOrgCode()));
				//如果地区不为空
				if (StringUtils.isNotEmpty(forecastQuantityList.get(0).getRegion()) && null != siteGroupService.querySiteGroupByCode(forecastQuantityList.get(0).getRegion())) {
					//设置地区名称
					newEntity.setRegionName(siteGroupService.querySiteGroupByCode(forecastQuantityList.get(0).getRegion()).getName());
				}
				
				newEntity.setRelevantOrgCode(null);
				newEntity.setWeightTotal(null);
				newEntity.setVolumeTotal(null);
				newEntity.setWaybillQtyTotal(null);
				
				//设置重量为0
				BigDecimal weightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
				//设置体积为0
				BigDecimal volumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
				//设置件数为0
				Integer waybillQtyTotal = 0;
				//循环
				for (int i = 0; i < forecastQuantityList.size(); i++) {
					//重量累计
					weightTotal = weightTotal.add(forecastQuantityList.get(i).getWeightTotal());
					//体积累计
					volumeTotal = volumeTotal.add(forecastQuantityList.get(i).getVolumeTotal());
					//件数累计
					waybillQtyTotal += forecastQuantityList.get(i).getWaybillQtyTotal();
				}
				//设置总重量
				newEntity.setWeightTotal(weightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
				//设置总体积
				newEntity.setVolumeTotal(volumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
				//设置总件数
				newEntity.setWaybillQtyTotal(waybillQtyTotal);
				//返回
				return newEntity;
			} else {
				//新建entity
				ForecastQuantityEntity newEntity = new ForecastQuantityEntity();
				//设置重量为0
				BigDecimal weightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
				//设置体积为0
				BigDecimal volumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
				//设置重量
				newEntity.setWeightTotal(weightTotal);
				//设置体积
				newEntity.setVolumeTotal(volumeTotal);
				//设置预测日期
				newEntity.setStatisticsDate(forecastQuantityEntity.getStatisticsDate());
				//设置预测HHMM
				newEntity.setStatisticsHHMM(forecastQuantityEntity.getStatisticsHHMM());
				//返回
				return newEntity;
			}
		}
	}

	/**
	 * 查询某外场,某线路/全部,出发或到达货物实际重量&体积
	 * 
	 * @author huyue
	 * @date 2012-12-4 下午9:19:24
	 */
	public RealWeightAndVolumeDto countRealWeightAndVolume(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		//新建map
		Map<String, Object> map = new HashMap<String, Object>();
		// 根据预测时间点 ,组织code 查询预测时间段
		// 获取开始时间点
		ConfigurationParamsEntity entityStart = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_START, forecastQuantityEntity.getBelongOrgCode());
		//如果不为空
		if (entityStart != null && StringUtils.isNotEmpty(entityStart.getConfValue())) {
			start1 = entityStart.getConfValue();
		}
		// 获取持续天数
		ConfigurationParamsEntity entityDuration = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_DURATION, forecastQuantityEntity.getBelongOrgCode());
		//如果不为空
		if (entityDuration != null && StringUtils.isNotEmpty(entityDuration.getConfValue())) {
			day1 = Integer.valueOf(entityDuration.getConfValue());
		}
		//计算开始时间
		Date startTime = TimeUtils.createStartTime(forecastQuantityEntity.getForecastTime(), start1);
		//计算结束时间
		Date endTime = TimeUtils.convertStringToDate(forecastQuantityEntity.getForecastTime(), start1, day1);
		//如果为空
		if (null == startTime || null == endTime) {
			//抛异常
			throw new TfrBusinessException(ForecastConstants.FORECAST_TRANSFORTIME_ERROR, "");
		}
		// 首先判断出发或到达
		//如果出发
		if (StringUtils.equals(forecastQuantityEntity.getType(), ForecastConstants.FORECAST_DEPART)) {// 出发
			//查询出发实际货量
			map.put("status", LoadConstants.LOAD_TASK_STATE_CANCELED);
			map.put("billType", TaskTruckConstant.BILL_TYPE_HANDOVER);
			map.put(origOrg, forecastQuantityEntity.getBelongOrgCode());
			map.put("destOrgCode", forecastQuantityEntity.getRelevantOrgCode());
			map.put("StartTime", startTime);
			map.put("EndTime", endTime);
			//返回
			return realWeightAndVolumeDao.queryRealDepart(map);
			//如果到达
		} else if (StringUtils.equals(forecastQuantityEntity.getType(), ForecastConstants.FORECAST_ARRIVE)) {// 到达
			//查询到达实际货量
			map.put("status", LoadConstants.LOAD_TASK_STATE_CANCELED);
			map.put("billType", TaskTruckConstant.BILL_TYPE_HANDOVER);
			map.put(origOrg, forecastQuantityEntity.getRelevantOrgCode());
			map.put("destOrgCode", forecastQuantityEntity.getBelongOrgCode());
			map.put("StartTime", startTime);
			map.put("EndTime", endTime);
			//返回
			return realWeightAndVolumeDao.queryRealArrive(map);
		} else {
			//抛异常
			throw new TfrBusinessException(ForecastConstants.FORECAST_TYPE_ERROR, "");
		}
	}

	/**
	 * 计算营业部平均重量体积 JOB
	 * 
	 * 
	 * 货量预测需要根据本中转场的货物信息进行,
	 * 
	 * 
	 * 包括货物重量及体积.
	 * 
	 * 但是在开单时会有一些货物并没有录入重量及体积,
	 * 
	 * 为了计算方便,
	 * 
	 * 则需要根据该外场辐射营业部开单的全部重量&体积计算得出平均值,
	 * 
	 * 赋予没有录入重量及体积的货物便于计算.
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 需要进行货量预测
	 * 
	 * 部分货开单时没有录入重量&体积,
	 * 
	 * 无法满足货量预测要求.
	 * 
	 * 获得该中转场的平均货物重量&体积,
	 * 
	 * 将该平均重量&体积用于填补开单未录入重量&体积信息的货物.
	 * 
	 * 
	 *
	 * 
	 * g --总重量, 
	 * 
	 * v --总体积,
	 * 
	 * p --总票数, 
	 * 
	 * j --总件数 
	 * 
	 * gav(平均重量) = g/p
	 * 
	 * vav(平均体积) = v/p
	 * 
	 * 每票件数 = j/p
	 * 
	 * 每月计算一次，间隔计算日期可以进行设置。
	 * 
	 * 根据各营业部门,分别统计,分别计算.
	 * 
	 * @author huyue
	 * @date 2012-12-6 下午3:20:15
	 */
	public void calculateAverageWeightAndVolume(Date time) throws TfrBusinessException {
		// 查询所有可以作为出发的营业部LIST
		//新建entity
		SaleDepartmentEntity saleDepartmentEntity = new SaleDepartmentEntity();
		//设置为yse
		saleDepartmentEntity.setLeave(FossConstants.YES);
		//查询所有营业部门
		List<SaleDepartmentEntity> saleDepartmentList = saleDepartmentService.querySaleDepartmentExactByEntity(saleDepartmentEntity, 0, Integer.MAX_VALUE);
		//如果为空
		if (CollectionUtils.isEmpty(saleDepartmentList)) {
			//记日志
			logger.error("调用综合接口查询所有可以作为出发的营业部LIST为空!");
			//返回
			return;
		}
		// 循环获取时间范围内所有开单重量体积票数件数
		//循环营业部门
		for (int i = 0; i < saleDepartmentList.size(); i++) {
			//新建map
			Map<String, Object> map = new HashMap<String, Object>();
			// 根据预测时间点 ,组织code 查询预测时间段
			// 获取开始时间点
			ConfigurationParamsEntity entityStart = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__AVERAGE_CALCULATE_START, saleDepartmentList.get(i).getCode());
			//不为空
			if (entityStart != null && StringUtils.isNotEmpty(entityStart.getConfValue())) {
				/** 
				 * 赋值 
				 */
				start2 = entityStart.getConfValue();
			}
			// 获取持续天数
			ConfigurationParamsEntity entityDuration = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__AVERAGE_CALCULATE_DURATION, saleDepartmentList.get(i).getCode());
			//不为空
			if (entityDuration != null && StringUtils.isNotEmpty(entityDuration.getConfValue())) {
				/** 
				 * 赋值 
				 */
				day2 = Integer.valueOf(entityDuration.getConfValue());
			}
			// 修改时间格式
			Date calculateTime = DateUtils.convert(DateUtils.convert(time, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
			// 开始日期是N天前
			Date startTime = TimeUtils.convertStringToDate(calculateTime, start2, (-day2));
			// 结束日期是今天
			Date endTime = TimeUtils.createStartTime(calculateTime, start2);
			//如为空
			if (null == startTime || null == endTime) {
				//记录异常
				logger.error("转换时间出错!方法: calculateAverageWeightAndVolume");
				//返回
				return;
			}
			//设置信息
			map.put(origOrg, saleDepartmentList.get(i).getCode());
			// 90状态为作废 BY 交接单配载单
			map.put("state", LoadConstants.HANDOVERBILL_STATE_ALREADY_CANCEL);
			map.put("StartTime", startTime);
			map.put("EndTime", endTime);
			//查询实际货量
			RealWeightAndVolumeDto realWeightAndVolumeDto = realWeightAndVolumeDao.queryAverage(map);
			//如果为空
			if (null == realWeightAndVolumeDto) {
				//记日志
				logger.error("查询实际重量体积票数件数为空!方法: calculateAverageWeightAndVolume 调用类: " + realWeightAndVolumeDao + " 调用方法: queryAverage" + " 参数:" + map);
				//返回
				return;
			} else {
				//计算平均重量
				BigDecimal averageWeight = realWeightAndVolumeDto.getTotalWeight().divide(BigDecimal.valueOf((double) realWeightAndVolumeDto.getWaybillQtyTotal()));
				//计算平均体积
				BigDecimal averageVolume = realWeightAndVolumeDto.getTotalVolume().divide(BigDecimal.valueOf((double) realWeightAndVolumeDto.getWaybillQtyTotal()));
				//计算平均件数
				int averageGoodsPerWaybill = Math.round(((float) realWeightAndVolumeDto.getGoodsQtyTotal()) / ((float) realWeightAndVolumeDto.getWaybillQtyTotal()));
				//新建entity
				AverageCalculateEntity averageCalculateEntity = new AverageCalculateEntity();
				//设置部门
				averageCalculateEntity.setOrgCode(saleDepartmentList.get(i).getCode());
				//查询平均重量体积
				averageCalculateEntity = averageCalculateDao.queryAverageCalculate(averageCalculateEntity);
				// 计算并判断是否存在数据,存在则更新,否则新增
				if (null == averageCalculateEntity) {
					averageCalculateEntity = new AverageCalculateEntity();
					// 如果为空则新增
					//UUID
					averageCalculateEntity.setAverageCalculateId(UUIDUtils.getUUID());
					//重量
					averageCalculateEntity.setTotalWeight(realWeightAndVolumeDto.getTotalWeight());
					//体积
					averageCalculateEntity.setTotalVolume(realWeightAndVolumeDto.getTotalVolume());
					//票数
					averageCalculateEntity.setTotalWaybillQty(realWeightAndVolumeDto.getWaybillQtyTotal());
					//件数
					averageCalculateEntity.setTotalGoodsQty(realWeightAndVolumeDto.getGoodsQtyTotal());
					//部门
					averageCalculateEntity.setOrgCode(saleDepartmentList.get(i).getCode());
					//平均重量
					averageCalculateEntity.setAverageWeight(averageWeight.setScale(three, BigDecimal.ROUND_HALF_DOWN));
					//平均体积
					averageCalculateEntity.setAverageVolume(averageVolume.setScale(three, BigDecimal.ROUND_HALF_DOWN));
					//平均件数字
					averageCalculateEntity.setAverageGoodsQty(averageGoodsPerWaybill);
					//修改时间
					averageCalculateEntity.setChangeTime(time);
					//新增
					averageCalculateDao.addAverageCalculate(averageCalculateEntity);
				} else {
					// 如果不为空则更新
					//重量
					averageCalculateEntity.setTotalWeight(realWeightAndVolumeDto.getTotalWeight());
					//体积
					averageCalculateEntity.setTotalVolume(realWeightAndVolumeDto.getTotalVolume());
					//票数
					averageCalculateEntity.setTotalWaybillQty(realWeightAndVolumeDto.getWaybillQtyTotal());
					//件数
					averageCalculateEntity.setTotalGoodsQty(realWeightAndVolumeDto.getGoodsQtyTotal());
					//平均重量
					averageCalculateEntity.setAverageWeight(averageWeight.setScale(three, BigDecimal.ROUND_HALF_DOWN));
					//平均体积
					averageCalculateEntity.setAverageVolume(averageVolume.setScale(three, BigDecimal.ROUND_HALF_DOWN));
					//平均件数
					averageCalculateEntity.setAverageGoodsQty(averageGoodsPerWaybill);
					//修改时间
					averageCalculateEntity.setChangeTime(time);
					//更新
					averageCalculateDao.updateAverageCalculateSelective(averageCalculateEntity);
				}
			}
		}
	}

	/**
	 * 查询外场某线路开单货量预测
	 * 
	 * @author huyue
	 * @date 2012-11-15 下午5:43:32
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#queryBillingList()
	 */
	@Override
	public List<BillingEntity> queryBillingList(BillingEntity billingEntity) throws TfrBusinessException {
		//查询货量预测开单表信息 批量 group by 营业区
		List<BillingEntity> billingList = billingDao.querybillingListGroupBy(billingEntity);
		// modify by liangfuxiang 2013-3-22上午10:28:06 begin 修改异常
		// 新建list
		// List<BillingEntity> newBillingList = new ArrayList<BillingEntity>();
		// 循环
		// for (int q = 0; q < newBillingList.size(); q++) {
		for (int q = 0; q < billingList.size(); q++) {
			// modify by liangfuxiang 2013-3-22上午10:28:14 end;
			//如果不为空
			if (StringUtils.isNotEmpty(billingList.get(q).getBillingSalesDistrict())) {
				//获取营业部名称
				String name = getNameByCode(billingList.get(q).getBillingSalesDistrict());
				//设置
				billingList.get(q).setBillingSalesDistrictName(name);
			}
			
			//xiaobc update start......................

			BigDecimal expressVolume = billingList.get(q).getExpressVolume();
			BigDecimal expressWeight = billingList.get(q).getExpressWeight();
			//zwd 调用综合接口，根据部门编码去查询重泡比，如果存在则使用查询到的重泡比，如果不存在则使用公用的重量体积转换参数。
			String orgCode = billingList.get(q).getBelongOrgCode();
			BigDecimal ratio = this.queryForecastParameter(orgCode);
			
			BigDecimal newExpressVolume = expressWeight.multiply(ratio).setScale(four, BigDecimal.ROUND_HALF_DOWN);
			BigDecimal volume = billingList.get(q).getBillingVolume();
			billingList.get(q).setBillingVolume(volume.subtract(expressVolume).add(newExpressVolume));//转换后的总体积=总体积-原始快递体积+转换后的快递体积
			billingList.get(q).setExpressVolume(newExpressVolume);
		
		//xiaobc update start......................
			
		}
		//返回
		return billingList;
	}

	/**
	 * 查询外场某线路在途中货量预测
	 * 
	 * @author huyue
	 * @date 2012-11-15 下午5:43:45
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#queryInTransitList()
	 */
	@Override
	public List<InTransitEntity> queryInTransitList(InTransitEntity inTransitEntity) throws TfrBusinessException {
		//查询货量预测在途表信息 批量
		List<InTransitEntity> inTransitList = inTransitDao.queryinTransitList(inTransitEntity);
		//循环
		for (int q = 0; q < inTransitList.size(); q++) {
			//设置所属名称
			inTransitList.get(q).setBelongOrgCodeName(getNameByCode(inTransitList.get(q).getBelongOrgCode()));
			//设置相关名称
			inTransitList.get(q).setRelevantOrgCodeName(getNameByCode(inTransitList.get(q).getRelevantOrgCode()));
			
			//xiaobc update start......................
			BigDecimal expressVolume = inTransitList.get(q).getExpressVolume();
			BigDecimal expressWeight = inTransitList.get(q).getExpressWeight();
			//zwd 调用综合接口，根据部门编码去查询重泡比，如果存在则使用查询到的重泡比，如果不存在则使用公用的重量体积转换参数。
			String orgCode = inTransitList.get(q).getBelongOrgCode();
			BigDecimal ratio = this.queryForecastParameter(orgCode);
			
			BigDecimal newExpressVolume = expressWeight.multiply(ratio).setScale(four, BigDecimal.ROUND_HALF_DOWN);
			BigDecimal volume = inTransitList.get(q).getIntransitVolume();
			inTransitList.get(q).setIntransitVolume(volume.subtract(expressVolume).add(newExpressVolume));//转换后的总体积=总体积-原始快递体积+转换后的快递体积
			inTransitList.get(q).setExpressVolume(newExpressVolume);
			//xiaobc update start......................
			
		}
		//返回
		return inTransitList;
	}

	/**
	 * 更新货量预测合车调整
	 * 
	 * @author huyue
	 * @date 2012-12-5 下午7:27:52
	 */
	public void changeQuantity(List<ForecastQuantityEntity> forecastQuantityList, ChangeQuantityEntity changeQuantityEntity) throws TfrBusinessException {
		// 更新调整后的两条记录
		//循环
		for (int i = 0; i < forecastQuantityList.size(); i++) {
			//更新
			forecastQuantityDao.updateforecastQuantitySelective(forecastQuantityList.get(i));
		}
		//new date
		Date changeTime = new Date();
		//如果不为空
		if (null != forecastQuantityList.get(0)) {
			//获取预测时间
			changeTime = forecastQuantityList.get(0).getForecastTime();
		}
		// 更新时间
		changeQuantityEntity.setChangeTime(changeTime);
		// 更新类型
		changeQuantityEntity.setType(ForecastConstants.FORECAST_DEPART);
		// 更新状态
		changeQuantityEntity.setStatus(ForecastConstants.CHANGE_QUANTITY_EFFECT);
		// 查询改变表是否存在该条目,不存在则新增,否则更新
		ChangeQuantityEntity oldEntity = changeQuantityDao.querychangeQuantity(changeQuantityEntity);
		if (null != oldEntity) {
			// 存在则更新
			//设置调整重量
			oldEntity.setModifyWeight(oldEntity.getModifyWeight().add(changeQuantityEntity.getModifyWeight()));
			//更新
			changeQuantityDao.updatechangeQuantitySelective(oldEntity);
		} else {
			//不存在
			//新增 
			//设置UUID
			changeQuantityEntity.setChangeQtyId(UUIDUtils.getUUID());
			//更新
			changeQuantityDao.addchangeQuantity(changeQuantityEntity);
		}
	}

	/**
	 * 查询合入本线路的货量
	 * 
	 * @author huyue
	 * @date 2012-12-5 下午8:34:16
	 */
	public List<ChangeQuantityEntity> queryChangeInByDate(Date modifyDate, String orgCode, String destorgCode) throws TfrBusinessException {
		//新建entity
		ChangeQuantityEntity changeQuantityEntity = new ChangeQuantityEntity();
		//设置调整时间
		changeQuantityEntity.setChangeTime(modifyDate);
		//设置新部门
		changeQuantityEntity.setNewDestOrg(destorgCode);
		//设置所属部门
		changeQuantityEntity.setBelongTransferCenter(orgCode);
		//查询调整货量表信息 批量
		List<ChangeQuantityEntity> changeQuantityList = changeQuantityDao.querychangeQuantityList(changeQuantityEntity);
		//循环
		for (int q = 0; q < changeQuantityList.size(); q++) {
			//设置所属部门名称
			changeQuantityList.get(q).setBelongTransferCenterName(getNameByCode(changeQuantityList.get(q).getBelongTransferCenter()));
			//设置新到达部门
			changeQuantityList.get(q).setNewDestOrgName(getNameByCode(changeQuantityList.get(q).getNewDestOrg()));
			//设置以前到达部门
			changeQuantityList.get(q).setOrigDestOrgName(getNameByCode(changeQuantityList.get(q).getOrigDestOrg()));
			if(StringUtils.equals(ForecastConstants.FORECAST_DEPART, changeQuantityList.get(q).getType())){
				changeQuantityList.get(q).setType("出发");
			}
		}
		//返回
		return changeQuantityList;
	}

	/**
	 * 查询合出本线路的货量
	 * 
	 * @author huyue
	 * @date 2012-12-5 下午8:34:33
	 */
	public List<ChangeQuantityEntity> queryChangeOutByDate(Date modifyDate, String orgCode, String destorgCode) throws TfrBusinessException {
		//新建entity
		ChangeQuantityEntity changeQuantityEntity = new ChangeQuantityEntity();
		//设置调整时间
		changeQuantityEntity.setChangeTime(modifyDate);
		//设置新部门
		changeQuantityEntity.setOrigDestOrg(destorgCode);
		//设置所属部门
		changeQuantityEntity.setBelongTransferCenter(orgCode);
		//查询调整货量表信息 批量
		List<ChangeQuantityEntity> changeQuantityList = changeQuantityDao.querychangeQuantityList(changeQuantityEntity);
		//循环
		for (int q = 0; q < changeQuantityList.size(); q++) {
			//设置所属部门名称
			changeQuantityList.get(q).setBelongTransferCenterName(getNameByCode(changeQuantityList.get(q).getBelongTransferCenter()));
			//设置新到达部门
			changeQuantityList.get(q).setNewDestOrgName(getNameByCode(changeQuantityList.get(q).getNewDestOrg()));
			//设置以前到达部门
			changeQuantityList.get(q).setOrigDestOrgName(getNameByCode(changeQuantityList.get(q).getOrigDestOrg()));
			if(StringUtils.equals(ForecastConstants.FORECAST_DEPART, changeQuantityList.get(q).getType())){
				changeQuantityList.get(q).setType("出发");
			}
		}
		//返回
		return changeQuantityList;
	}

	// 预测job
	/**
	 * 预测外场货量方法 分出发,到达 调用预测各外场方法
	 * 
	 * @author huyue
	 * @date 2012-12-17 下午8:03:21
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#forecastTotal(java.lang.String,
	 *      java.util.Date)
	 */
	@Override
	public void forecastTransferCenterTotal(String action, Date statistics) throws TfrBusinessException {
		// 首先查询所有外场信息
		//新建entity
		OrgAdministrativeInfoEntity orgAdministrativeInfoEntity = new OrgAdministrativeInfoEntity();
		//设置外场为yes
		orgAdministrativeInfoEntity.setTransferCenter(FossConstants.YES);
		//精确查询 动态的查询条件。 
		//如果传入的对象为空，
		//传入一个对象，
		//可查出所有的数据，
		//如果传入的对象的属性不为空或者空白，
		//则设置为查询条件
		List<OrgAdministrativeInfoEntity> orgAdministrativeInfoList = orgAdministrativeInfoService.querySimpleOrgAdministrativeInfoByEntity(orgAdministrativeInfoEntity, 0, Integer.MAX_VALUE);
		//如果为空
		if (CollectionUtils.isEmpty(orgAdministrativeInfoList)) {
			logger.error("调用综合接口查询所有外场信息没有得到数据!");
			return;
		//不为空
		} else {
			for (OrgAdministrativeInfoEntity entity: orgAdministrativeInfoList) {
				if(null != entity && StringUtils.isNotBlank(entity.getCode())){
					try{
						//预测货量 各外场出发,到达 调用预测各线路方法
						forecastService.forecastTransferCenter(action, statistics, entity.getCode());
					}catch(Exception e){
						logger.error("货量预测部门: " + entity.getCode(), e);
					}
				}
				
			}
		}
	}

	/**
	 * 预测营业部货量方法 分出发,到达 调用预测各营业部方法
	 * 
	 * 
	 * @author huyue
	 * @date 2012-12-27 下午1:50:21
	 */
	@Override
	public void forecastSalesDepartmentTotal(String action, Date statistics) throws TfrBusinessException {
		// 查询所有营业部
		//新建entity
		OrgAdministrativeInfoEntity orgAdministrativeInfoEntity = new OrgAdministrativeInfoEntity();
		//设置营业部为yes
		orgAdministrativeInfoEntity.setSalesDepartment(FossConstants.YES);
		//精确查询 动态的查询条件。 
		//如果传入的对象为空，
		//传入一个对象，
		//可查出所有的数据，
		//如果传入的对象的属性不为空或者空白，
		//则设置为查询条件
		List<OrgAdministrativeInfoEntity> orgAdministrativeInfoList = orgAdministrativeInfoService.querySimpleOrgAdministrativeInfoByEntity(orgAdministrativeInfoEntity, 0, Integer.MAX_VALUE);
		//如果为空
		if (CollectionUtils.isEmpty(orgAdministrativeInfoList)) {
			logger.error("调用综合接口查询所有营业部信息没有得到数据!");
			return;
		//不为空
		} else {
			//循环
			for (OrgAdministrativeInfoEntity entity: orgAdministrativeInfoList) {
				if(null != entity && StringUtils.isNotBlank(entity.getCode())){
					try{
						//预测货量 各营业部出发,到达 调用预测各线路方法
						forecastService.forecastSalesDepartment(action, statistics, entity.getCode());
					}catch(Exception e){
						logger.error("货量预测部门: " + entity.getCode(), e);
					}
				}
				
			}
		}
	}

	/**
	 * 预测货量 各外场出发,到达 调用预测各线路方法
	 * 
	 * @author huyue
	 * @date 2012-11-15 下午5:43:55
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#forecastTotal()
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void forecastTransferCenter(String action, Date statistics, String orgCode) throws TfrBusinessException {
		// 判断是出发还是到达
		if (null != action && StringUtils.equals(action, ForecastConstants.FORECAST_ARRIVE)) {// 到达
			
			// 查询该部门走货路径最后到达时间
			Date maxArriveTime = pathDetailDao.queryMaxArriveTime(orgCode);
			
			
			//如果为空
			if (null == maxArriveTime) {
				//记日志
				logger.info("查询部门" + orgCode + "的走货路径最后到达时间没有得到数据!");
				//返回
				return;
			}
			
			// 根据预测时间点 ,组织code 查询预测时间段
			// 获取开始时间点
			ConfigurationParamsEntity entityStart = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_START, orgCode);
			//如果不为空
			if (entityStart != null && StringUtils.isNotEmpty(entityStart.getConfValue())) {
				start1 = entityStart.getConfValue();
			}
			// 获取持续天数
			ConfigurationParamsEntity entityDuration = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_DURATION, orgCode);
			//如果不为空
			if (entityDuration != null && StringUtils.isNotEmpty(entityDuration.getConfValue())) {
				day1 = Integer.valueOf(entityDuration.getConfValue());
			}
			
			// 新建预测时间 根据当前时间判断
			Date forecastTime;
			// 修改时间格式 只取日期
			//开始时间
			Date midStartTime = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
			//到达时间
			Date midEndTime = TimeUtils.createStartTime(midStartTime, start1);
			
			// 如果现在时间小于当天的周期起始时间,并且大于0点.则预测的周期应该是昨天的周期
			if (statistics.after(midStartTime) && statistics.before(midEndTime)) {
				//计算时间 减一天
				forecastTime = TimeUtils.convertStringToDate(statistics, start1, -1);
			} else {// 否则就是当天的周期
				forecastTime = TimeUtils.createStartTime(statistics, start1);
			}
			// 判断需要计算几天的 小于1天返回1
			int diffDay = DateUtils.getTimeDiff(forecastTime, maxArriveTime).intValue() + 1;
			//循环
			for (int d = 0; d < diffDay; d++) {
				// 如果预测开始时间大于最大时间.则不继续循环否则继续
				if (forecastTime.after(maxArriveTime)) {
					//跳出
					break;
				//否则
				} else {
					//设置预测时间
					Date forecastStartTime = forecastTime;
					//设置结束时间
					Date forecastEndTime = TimeUtils.convertStringToDate(forecastTime, start1, day1);
					
					
					//如果为空
					if (null == forecastEndTime) {
						//记日志
						logger.error("转换时间出错!方法: forecastTransferCenter");
					}
					
					// 查询相应的到达部门LIST
					List<String> relevantOrgCode = this.arriveRelevantOrgCode(orgCode, forecastStartTime, forecastEndTime);
					
					// 循环查询本条目开单&在途货量 进行重新计算
					/**
					 * 循环所有orgCode(例如:orgCode = >上海转运场)的到达部门 relevantOrgCode(例如: 北京转运场,天津转运场,等...)
					 * 单独循环每一条
					 */
					for (int r = 0; r < relevantOrgCode.size(); r++) {
						/**
						 * 开单未交接的货量
						 */
						List<ForecastDto> billingList = new ArrayList<ForecastDto>(); 
						/**
						 * 在途货量
						 */
						List<ForecastDto> inTransitList = new ArrayList<ForecastDto>();
						/**
						 * 在库货量 (到达没有在库货量)
						 */
						List<ForecastDto> inventoryList = new ArrayList<ForecastDto>(0);
						/**
						 * 查询到达开单货量
						 * 例如 : 天津转运场  -> 上海转运场的 到达开单货量
						 */
						List<PathDetailEntity> arriveBillingList = this.arriveBilling(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						
						/**
						 * 查询到达在途货量
						 * 
						 * 例如 : 天津转运场  -> 上海转运场的 到达在途货量
						 */
						List<PathDetailEntity> arriveInTransitList = this.arriveInTransit(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						// 开单部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						//循环
						for (int j = 0; j < arriveBillingList.size(); j++) {
							
							//根据waybillNo查询一条走货路径信息
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(arriveBillingList.get(j).getWaybillNo());
							//如果为空
							if (null == transportPathEntity) {
								//记日志
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + arriveBillingList.get(j).getWaybillNo());
							//否则
							} else {
								
								transportPathEntity.setWaybillNoCount(arriveBillingList.get(j).getWaybillNoCount());
								
								// 重新计算重量体积
								TransportPathEntity	newTransportPathEntity = this.reCalculate(transportPathEntity);
								//新建立DTO
								ForecastDto forecastDto = new ForecastDto();
								//设置明细
								forecastDto.setPathDetailEntity(arriveBillingList.get(j));
								//设置路径
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								//添加到开单中
								billingList.add(forecastDto);
							}
						}
						
						// 在途部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < arriveInTransitList.size(); j++) {
							
							//根据waybillNo查询一条走货路径信息
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(arriveInTransitList.get(j).getWaybillNo());

							//如果为空
							if (null == transportPathEntity) {
								//记日志
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + arriveBillingList.get(j).getWaybillNo());
							//否则
							} else {
								
								transportPathEntity.setWaybillNoCount(arriveBillingList.get(j).getWaybillNoCount());
								
								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = this.reCalculate(transportPathEntity);
								
								//新建立DTO
								ForecastDto forecastDto = new ForecastDto();
								//设置明细
								forecastDto.setPathDetailEntity(arriveInTransitList.get(j));
								//设置路径
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								//添加到在途中
								inTransitList.add(forecastDto);
							}
						}
						// 根据到达部门统计条目信息 新增到主表
						forecastService.forecast(ForecastConstants.FORECAST_ARRIVE, forecastTime, statistics, orgCode, billingList, inTransitList, inventoryList, relevantOrgCode.get(r));
					}
					// 更新forecastTime为截止时间
					forecastTime = forecastEndTime;
				}
			}
		//如果为出发
		} else if (null != action && StringUtils.equals(action, ForecastConstants.FORECAST_DEPART)) {
			// 出发
			//查询时间
			Date maxStartTime = pathDetailDao.queryMaxStartTime(orgCode);
			
			
			// 查询该部门走货路径最后出发时间
			//如果为空
			if (null == maxStartTime) {
				//记日志
				logger.info("查询部门" + orgCode + "的走货路径最后到达时间没有得到数据!");
				//返回
				return;
			}
			
			// 根据预测时间点 ,组织code 查询预测时间段
			// 获取开始时间点
			ConfigurationParamsEntity entityStart = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_START, orgCode);
			//如果不为空
			if (entityStart != null && StringUtils.isNotEmpty(entityStart.getConfValue())) {
				start1 = entityStart.getConfValue();
			}
			// 获取持续天数
			ConfigurationParamsEntity entityDuration = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_DURATION, orgCode);
			//如果不为空
			if (entityDuration != null && StringUtils.isNotEmpty(entityDuration.getConfValue())) {
				day1 = Integer.valueOf(entityDuration.getConfValue());
			}
			
			// 新建预测时间 根据当前时间判断
			Date forecastTime;
			// 修改时间格式 只取日期
			//计算开始时间
			Date midStartTime = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
			//计算结束时间
			Date midEndTime = TimeUtils.createStartTime(midStartTime, start1);
			
			// 如果现在时间小于当天的周期起始时间,并且大于0点.则预测的周期应该是昨天的周期
			if (statistics.after(midStartTime) && statistics.before(midEndTime)) {
				//减一天
				forecastTime = TimeUtils.convertStringToDate(statistics, start1, -1);
			} else {
				// 否则就是当天的周期
				forecastTime = TimeUtils.createStartTime(statistics, start1);
			}
			//计算day
			int diffDay = DateUtils.getTimeDiff(forecastTime, maxStartTime).intValue() + 1;
			//循环
			for (int d = 0; d < diffDay; d++) {
				// 如果预测开始时间大于最大时间.则不继续循环否则继续
				if (forecastTime.after(maxStartTime)) {
					//跳出
					break;
				//否则
				} else {
					//设置预测时间
					Date forecastStartTime = forecastTime;
					//计算结束时间
					Date forecastEndTime = TimeUtils.convertStringToDate(forecastTime, start1, day1);
					//如果为空
					if (null == forecastEndTime) {
						//记日志
						logger.error("转换时间出错!方法: forecastTransferCenter");
					}
					// 查询相应的出发部门LIST
					List<String> relevantOrgCode = this.departRelevantOrgCode(orgCode, forecastStartTime, forecastEndTime);
					
					// 循环查询本条目开单&在途货量 进行重新计算
					//循环
					for (int r = 0; r < relevantOrgCode.size(); r++) {
						//开单未交接的货量
						List<ForecastDto> billingList = new ArrayList<ForecastDto>(); 
						// 在途货量
						List<ForecastDto> inTransitList = new ArrayList<ForecastDto>();
						// 在库货量 
						List<ForecastDto> inventoryList = new ArrayList<ForecastDto>();
						
						// 查询出发开单货量
						List<PathDetailEntity> departBillingList = this.departBilling(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						// 查询出发在途货量
						List<PathDetailEntity> departInTransitList = this.departInTransit(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						// 查询出发在库货量
						List<PathDetailEntity> departInventoryList = this.departInventory(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						
						// 开单部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < departBillingList.size(); j++) {
							
							//根据waybillNo查询一条走货路径信息
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(departBillingList.get(j).getWaybillNo());
							
							
							//为空
							if (null == transportPathEntity) {
								//记日志
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + departBillingList.get(j).getWaybillNo());
							} else {
								
								transportPathEntity.setWaybillNoCount(departBillingList.get(j).getWaybillNoCount());

								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = reCalculate(transportPathEntity);
								
								
								ForecastDto forecastDto = new ForecastDto();
								//设置
								forecastDto.setPathDetailEntity(departBillingList.get(j));
								//设置
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								//新增
								billingList.add(forecastDto);
							}
						}
						
						// 在途部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < departInTransitList.size(); j++) {
							//根据waybillNo查询一条走货路径信息
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(departInTransitList.get(j).getWaybillNo());
							
							//为空
							if (null == transportPathEntity) {
								//记日志
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + departInTransitList.get(j).getWaybillNo());
							} else {
								
								transportPathEntity.setWaybillNoCount(departInTransitList.get(j).getWaybillNoCount());
								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = reCalculate(transportPathEntity);
								ForecastDto forecastDto = new ForecastDto();
								//设置
								forecastDto.setPathDetailEntity(departInTransitList.get(j));
								//设置
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								//新增
								inTransitList.add(forecastDto);
							}
						}
						// 在库部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < departInventoryList.size(); j++) {
							//根据waybillNo查询一条走货路径信息
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(departInventoryList.get(j).getWaybillNo());
							//为空
							if (null == transportPathEntity) {
								//记日志
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + departInventoryList.get(j).getWaybillNo());
							} else {
								
								//复制 由于ORM缓存导致同一个运单查询出来的是同一个对象所以这边复制一个新的对象用来修改数据
								TransportPathEntity transportPathEntityTemp=new TransportPathEntity();
								BeanUtils.copyProperties(transportPathEntity, transportPathEntityTemp);
								
								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = this.reCalculate(transportPathEntityTemp);

								ForecastDto forecastDto = new ForecastDto();
								//设置
								forecastDto.setPathDetailEntity(departInventoryList.get(j));
								//设置
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								//新增
								inventoryList.add(forecastDto);
							}
						}
						// 根据到达部门统计条目信息 新增到主表
						forecastService.forecast(ForecastConstants.FORECAST_DEPART, forecastTime, statistics, orgCode, billingList, inTransitList, inventoryList, relevantOrgCode.get(r));
					}
					//设置时间为结束时间
					forecastTime = forecastEndTime;
				}
			}
		} else {
			//抛异常
			throw new TfrBusinessException(ForecastConstants.FORECAST_ACTION_ERROR, "");
		}
	}

	/**
	 * 预测货量 各营业部出发,到达 调用预测各线路方法
	 * 
	 * @author huyue
	 * @date 2012-12-17 下午8:16:33
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void forecastSalesDepartment(String action, Date statistics, String orgCode) throws TfrBusinessException {
		// 判断是出发还是到达
		if (null != action && StringUtils.equals(action, ForecastConstants.FORECAST_ARRIVE)) {
			// 到达
			Date maxArriveTime = pathDetailDao.queryMaxArriveTime(orgCode);
			// 查询该部门走货路径的最后到达时间没有得到数据
			//判空
			if (null == maxArriveTime) {
				//记日志
				logger.info("查询部门" + orgCode + "的走货路径最后到达时间没有得到数据!");
				return;
			}
			// 根据预测时间点 ,组织code 查询预测时间段
			// 获取开始时间点
			ConfigurationParamsEntity entityStart = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_START, orgCode);
			//判空
			if (entityStart != null && StringUtils.isNotEmpty(entityStart.getConfValue())) {
				start1 = entityStart.getConfValue();
			}
			// 获取持续天数
			ConfigurationParamsEntity entityDuration = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_DURATION, orgCode);
			//判空
			if (entityDuration != null && StringUtils.isNotEmpty(entityDuration.getConfValue())) {
				day1 = Integer.valueOf(entityDuration.getConfValue());
			}
			// 新建预测时间 根据当前时间判断
			Date forecastTime;
			// 修改时间格式 只取日期
			Date midStartTime = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
			Date midEndTime = TimeUtils.createStartTime(midStartTime, start1);
			
			// 如果现在时间小于当天的周期起始时间,并且大于0点.则预测的周期应该是昨天的周期
			if (statistics.after(midStartTime) && statistics.before(midEndTime)) {
				forecastTime = TimeUtils.convertStringToDate(statistics, start1, -1);
			} else {
				// 否则就是当天的周期
				forecastTime = TimeUtils.createStartTime(statistics, start1);
			}
			int diffDay = DateUtils.getTimeDiff(forecastTime, maxArriveTime).intValue() + 1;
			//循环
			for (int d = 0; d < diffDay; d++) {
				// 如果预测开始时间大于最大时间.则不继续循环否则继续
				if (forecastTime.after(maxArriveTime)) {
					break;
				} else {
					Date forecastStartTime = forecastTime;
					Date forecastEndTime = TimeUtils.convertStringToDate(forecastTime, start1, day1);
					//判空
					if (null == forecastEndTime) {
						//记日志
						logger.error("转换时间出错!方法: forecastTransferCenter");
					}
					// 查询相应的到达部门LIST
					List<String> relevantOrgCode = this.arriveRelevantOrgCode(orgCode, forecastStartTime, forecastEndTime);
					
					// 循环查询本条目开单&在途货量 进行重新计算
					for (int r = 0; r < relevantOrgCode.size(); r++) {
						List<ForecastDto> billingList = new ArrayList<ForecastDto>();
						List<ForecastDto> inTransitList = new ArrayList<ForecastDto>();
						// 查询到达开单货量
						List<PathDetailEntity> arriveBillingList = this.arriveBilling(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						// 查询到达在途货量
						List<PathDetailEntity> arriveInTransitList = this.arriveInTransit(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						
						// 开单部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < arriveBillingList.size(); j++) {
							
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(arriveBillingList.get(j).getWaybillNo());
							
							//判空
							if (null == transportPathEntity) {
								//记日志
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + arriveBillingList.get(j).getWaybillNo());
							} else {
								
								transportPathEntity.setWaybillNoCount(arriveBillingList.get(j).getWaybillNoCount());
								
								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = this.reCalculate(transportPathEntity);
								
								ForecastDto forecastDto = new ForecastDto();
								forecastDto.setPathDetailEntity(arriveBillingList.get(j));
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								billingList.add(forecastDto);
							}
						}
						
						// 在途部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < arriveInTransitList.size(); j++) {
							
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(arriveInTransitList.get(j).getWaybillNo());
							//判空
							if (null == transportPathEntity) {
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + arriveInTransitList.get(j).getWaybillNo());
							} else {
								
								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = this.reCalculate(transportPathEntity);
								
								ForecastDto forecastDto = new ForecastDto();
								forecastDto.setPathDetailEntity(arriveInTransitList.get(j));
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								inTransitList.add(forecastDto);
							}
						}
						// 根据到达营业部统计条目信息 新增到主表
						forecastService.forecastSalesDeptArrive(ForecastConstants.FORECAST_ARRIVE, forecastTime, statistics, orgCode, billingList, inTransitList, relevantOrgCode.get(r));
					}
					forecastTime = forecastEndTime;
				}
			}
		} else if (null != action && StringUtils.equals(action, ForecastConstants.FORECAST_DEPART)) {// 出发
			Date maxStartTime = pathDetailDao.queryMaxStartTime(orgCode);
			// 查询该部门走货路径的最后出发时间没有得到数据
			//判空
			if (null == maxStartTime) {
				logger.info("查询部门" + orgCode + "的走货路径最后出发时间没有得到数据!");
				return;
			}
			// 根据预测时间点 ,组织code 查询预测时间段
			// 获取开始时间点
			ConfigurationParamsEntity entityStart = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_START, orgCode);
			//判空
			if (entityStart != null && StringUtils.isNotEmpty(entityStart.getConfValue())) {
				start1 = entityStart.getConfValue();
			}
			// 获取持续天数
			ConfigurationParamsEntity entityDuration = configurationParamsService.queryConfigurationParamsByOrgCode(DictionaryConstants.SYSTEM_CONFIG_PARM__TFR, ConfigurationParamsConstants.TFR_PARM__FORECAST_DURATION, orgCode);
			//判空
			if (entityDuration != null && StringUtils.isNotEmpty(entityDuration.getConfValue())) {
				day1 = Integer.valueOf(entityDuration.getConfValue());
			}
			// 新建预测时间 根据当前时间判断
			Date forecastTime;
			// 修改时间格式 只取日期
			Date midStartTime = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
			Date midEndTime = TimeUtils.createStartTime(midStartTime, start1);
			// 如果现在时间小于当天的周期起始时间,并且大于0点.则预测的周期应该是昨天的周期
			if (statistics.after(midStartTime) && statistics.before(midEndTime)) {
				forecastTime = TimeUtils.convertStringToDate(statistics, start1, -1);
			} else {// 否则就是当天的周期
				forecastTime = TimeUtils.createStartTime(statistics, start1);
			}
			int diffDay = DateUtils.getTimeDiff(forecastTime, maxStartTime).intValue() + 1;
			for (int d = 0; d < diffDay; d++) {
				// 如果预测开始时间大于最大时间.则不继续循环否则继续
				if (forecastTime.after(maxStartTime)) {
					break;
				} else {
					Date forecastStartTime = forecastTime;
					Date forecastEndTime = TimeUtils.convertStringToDate(forecastTime, start1, day1);
					//判空
					if (null == forecastEndTime) {
						//记日志
						logger.error("转换时间出错!方法: forecastTransferCenter");
					}
					// 查询相应的出发部门LIST
					List<String> relevantOrgCode = this.departRelevantOrgCode(orgCode, forecastStartTime, forecastEndTime);
					
					// 循环查询本条目开单&在途货量 进行重新计算
					for (int r = 0; r < relevantOrgCode.size(); r++) {
						List<ForecastDto> billingList = new ArrayList<ForecastDto>();
						// 查询出发开单货量
						List<PathDetailEntity> departBillingList = departBilling(orgCode, relevantOrgCode.get(r), forecastStartTime, forecastEndTime);
						// 开单部分查询重量体积等主表字段 合并主表信息和明细表信息到Dto
						for (int j = 0; j < departBillingList.size(); j++) {
							
							TransportPathEntity transportPathEntity = transportationPathDao.queryTransportPath(departBillingList.get(j).getWaybillNo());
							
							if (null == transportPathEntity) {
								logger.error("根据运单号查询走货路径总表信息没有得到数据! 运单号: " + departBillingList.get(j).getWaybillNo());
							} else {
								
								transportPathEntity.setWaybillNoCount(departBillingList.get(j).getWaybillNoCount());
								// 重新计算重量体积
								TransportPathEntity newTransportPathEntity = this.reCalculate(transportPathEntity);
								
								ForecastDto forecastDto = new ForecastDto();
								forecastDto.setPathDetailEntity(departBillingList.get(j));
								forecastDto.setTransportPathEntity(newTransportPathEntity);
								billingList.add(forecastDto);
							}
						}
						// 根据出发营业部统计条目信息 新增到主表
						forecastService.forecastSalesDeptDepart(ForecastConstants.FORECAST_DEPART, forecastTime, statistics, orgCode, billingList, relevantOrgCode.get(r));
					}
					forecastTime = forecastEndTime;
				}
			}
		} else {
			throw new TfrBusinessException(ForecastConstants.FORECAST_ACTION_ERROR, "");
		}
	}

	/**
	 * 根据外场部门统计条目信息 新增到主表
	 * @author huyue
	 * @date 2012-11-27 下午8:16:21
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void forecast(String action, Date forecastTime, Date statistics, String orgCode, List<ForecastDto> billingList, List<ForecastDto> inTransitList, List<ForecastDto> inventoryList, String relevantOrgCode) throws TfrBusinessException {
		// 拆分预测时间
		Date statisticsDate = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
		SimpleDateFormat sdf2 = new SimpleDateFormat("HHmm");
		String statisticsHHMM = sdf2.format(statistics);
		// 设置统计字段
		//总 = 开单 + 在途 + 在库
		//总重量
		BigDecimal weightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		//总体积
		BigDecimal volumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		//总单数
		Integer waybillQtyTotal = 0;
		
		//卡航 = 开单卡航 + 在途卡航 + 在库卡航
		BigDecimal gpsEnabledResWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal gpsEnabledResVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer gpsEnabledResQtyTotal = 0;
		
		//城运 = 开单城运 + 在途城运 + 在库城运
		BigDecimal precisionIfsWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal precisionIfsVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer precisionIfsQtyTotal = 0;
		
		//快递 = 开单快递 + 在途快递 + 在库快递
		BigDecimal expressWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal expressVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer expressQtyTotal = 0;
		
		//在库
		BigDecimal inventoryWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal inventoryVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer inventoryQtyTotal = 0;
		
		//开单
		BigDecimal billingWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal billingVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer billingQtyTotal = 0;
		
		//在途
		BigDecimal intransitWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal intransitVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer intransitQtyTotal = 0;
		
		Set<String> setTotalWaybill = new HashSet<String>();
		Set<String> setInTransitWaybill = new HashSet<String>();
		Set<String> setBillingWaybill = new HashSet<String>();
		Set<String> setInventoryWaybill = new HashSet<String>();
		Set<String> setGpsEnabledResWaybill = new HashSet<String>();
		Set<String> setPrecisionIfsWaybill = new HashSet<String>();
		Set<String> setExpressWaybill = new HashSet<String>();
		List<ForecastDto> billingBeLongList = new ArrayList<ForecastDto>();
		Set<String> setSalesDepartmentCode = new HashSet<String>();
		Set<String> setVehicleCode = new HashSet<String>();
		// 根据组织查询所有的辐射营业部
		List<String> salesDepartmentCodeList = getSalesDeptListByTransferCode(orgCode);
		if (CollectionUtils.isEmpty(salesDepartmentCodeList)) {
			logger.error("调用综合接口根据组织查询所有辐射营业部为空! 方法: getSalesDeptListByTransferCode  orgCode : " + orgCode);
			salesDepartmentCodeList = new ArrayList<String>();
		}
		// 循环开单货件LIST
		for (int j = 0; j < billingList.size(); j++) {
			// 总量增加
			weightTotal = weightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
			volumeTotal = volumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
			setTotalWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			// 开单量增加
			billingWeightTotal = billingWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
			billingVolumeTotal = billingVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
			setBillingWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			// 判断是否精准卡航
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
				// 卡航量增加
				gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setGpsEnabledResWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否精准城运
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
				// 城运量增加
				precisionIfsWeightTotal = precisionIfsWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setPrecisionIfsWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否快递
			if (
				null != billingList.get(j).getTransportPathEntity().getTransportModel() 
				&& ( 
					StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE) 
			       ||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
			       ||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"EPEP")
			   )
			){
				// 快递量增加
				expressWeightTotal = expressWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				expressVolumeTotal = expressVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setExpressWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			String salesDept;
			// 如果出发则营业部为开单部门
			if (StringUtil.equals(ForecastConstants.FORECAST_DEPART, action)) {
				salesDept = billingList.get(j).getPathDetailEntity().getBillingOrgCode();
			} else {// 否则到达则营业部为上一部门
				salesDept = billingList.get(j).getPathDetailEntity().getOrigOrgCode();
			}
			// 判断是否为本外场辐射营业部
			if (salesDepartmentCodeList.contains(salesDept)) {
				// 如果是则把本条保存 以备统计本部门开单货量使用
				billingBeLongList.add(billingList.get(j));
				setSalesDepartmentCode.add(salesDept);
			}
		}
		// 循环在途货件LIST
		for (int j = 0; j < inTransitList.size(); j++) {
			// 总量增加
			weightTotal = weightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
			volumeTotal = volumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
			setTotalWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			// 在途量增加
			intransitWeightTotal = intransitWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
			intransitVolumeTotal = intransitVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
			setInTransitWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			// 判断是否精准卡航
			if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
				// 卡航量增加
				gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
				gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
				setGpsEnabledResWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否精准城运
			if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
				// 城运量增加
				precisionIfsWeightTotal = precisionIfsWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
				precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
				setPrecisionIfsWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否快递
			if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
				PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)||
				StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
				||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"EPEP"))) {
				// 快递量增加
				expressWeightTotal = expressWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
				expressVolumeTotal = expressVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
				setExpressWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			}
			String vehicleNo;
			// 如果出发则车牌号为上一段车牌号
			if (StringUtil.equals(ForecastConstants.FORECAST_DEPART, action)) {
				vehicleNo = inTransitList.get(j).getPathDetailEntity().getBeforeVehicleNo();
			} else {// 否则到达则车牌号为本段车牌号
				vehicleNo = inTransitList.get(j).getPathDetailEntity().getVehicleNo();
			}
			setVehicleCode.add(vehicleNo);
		}
		// 循环在库货件LIST
		for (int j = 0; j < inventoryList.size(); j++) {
			// 总量增加
			
			//总重量
			weightTotal = weightTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalWeight());
			//总体积
			volumeTotal = volumeTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalVolume());
			 //运单号 
			setTotalWaybill.add(inventoryList.get(j).getTransportPathEntity().getWaybillNo());
			
			// 在库量增加
			 // 总重量
			inventoryWeightTotal = inventoryWeightTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalWeight());
			 //总体积
			inventoryVolumeTotal = inventoryVolumeTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalVolume());
			 // 运单
			setInventoryWaybill.add(inventoryList.get(j).getTransportPathEntity().getWaybillNo());
			// 判断是否精准卡航
			if (null != inventoryList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inventoryList.get(j).getTransportPathEntity().getTransportModel(), PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
				// 卡航量增加
				gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalWeight());
				gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalVolume());
				setGpsEnabledResWaybill.add(inventoryList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否精准城运
			if (null != inventoryList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inventoryList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
				// 城运量增加
				precisionIfsWeightTotal = precisionIfsWeightTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalWeight());
				precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalVolume());
				setPrecisionIfsWaybill.add(inventoryList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否快递
			if (null != inventoryList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(inventoryList.get(j).getTransportPathEntity().getTransportModel(),
				PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)||
				StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
				||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"EPEP"))) {
				// 快递量增加
				expressWeightTotal = expressWeightTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalWeight());
				expressVolumeTotal = expressVolumeTotal.add(inventoryList.get(j).getTransportPathEntity().getTotalVolume());
				setExpressWaybill.add(inventoryList.get(j).getTransportPathEntity().getWaybillNo());
			}
		}
		// 设置总票数
		waybillQtyTotal = setTotalWaybill.size();
		// 设置开单票数
		billingQtyTotal = setBillingWaybill.size();
		// 设置在途票数
		intransitQtyTotal = setInTransitWaybill.size();
		// 设置在库票数
		inventoryQtyTotal = setInventoryWaybill.size();
		// 设置卡航票数
		gpsEnabledResQtyTotal = setGpsEnabledResWaybill.size();
		// 设置城运票数
		precisionIfsQtyTotal = setPrecisionIfsWaybill.size();
		// 设置城运票数
		expressQtyTotal = setExpressWaybill.size();
		// 根据orgCode 查询region站点组
		String region = "无";
		List<SiteGroupEntity> siteGroupList = siteGroupService.querySiteGroupsBySiteCode(relevantOrgCode);
		if (CollectionUtils.isEmpty(siteGroupList)) {
			logger.error("调用综合接口根据组织查询站点组为空! 类: " + siteGroupService + " 方法: querySiteGroupsBySiteCode orgCode : " + relevantOrgCode);
			siteGroupList = new ArrayList<SiteGroupEntity>();
		}
		// 如果出发 查询出发站点组
		if (StringUtil.equals(ForecastConstants.FORECAST_DEPART, action)) {
			for (int s = 0; s < siteGroupList.size(); s++) {
				// 如果站点组类型等于出发,则该条为外场出发站点组
				if (StringUtil.equals(siteGroupList.get(s).getType(), DictionaryValueConstants.BSE_SITE_GROUP_TYPE_CF)) {
					region = siteGroupList.get(s).getVirtualCode();
				}
			}
		} else {// 到达 查询到达站点组
			for (int s = 0; s < siteGroupList.size(); s++) {
				// 如果站点组类型等于到达,则该条为外场到达站点组
				if (StringUtil.equals(siteGroupList.get(s).getType(), DictionaryValueConstants.BSE_SITE_GROUP_TYPE_DD)) {
					region = siteGroupList.get(s).getVirtualCode();
				}
			}
		}
		
		// 提交总表
		String forecastQuantityId = UUIDUtils.getUUID();
		ForecastQuantityEntity forecastQuantityEntity = new ForecastQuantityEntity();
		
		// 查询当天合车改变量 记录到新记录中
		// 只有出发才有合车
		if (StringUtil.equals(ForecastConstants.FORECAST_DEPART, action)) {
			BigDecimal changeVolume = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			List<ChangeQuantityEntity> outList = this.queryChangeOutByDate(statisticsDate, orgCode, relevantOrgCode);
			List<ChangeQuantityEntity> inList = this.queryChangeInByDate(statisticsDate, orgCode, relevantOrgCode);
			// 合出的减去 合入的增加
			for (int q = 0; q < outList.size(); q++) {
				changeVolume = changeVolume.subtract(outList.get(q).getModifyWeight());
			}
			for (int q = 0; q < inList.size(); q++) {
				changeVolume = changeVolume.add(inList.get(q).getModifyWeight());
			}
			// 只有不为空才更新该字段
			if (outList.size() > 0 || inList.size() > 0) {
				forecastQuantityEntity.setDeviationVolume(changeVolume.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			}
		}
		
		forecastQuantityEntity.setForecastQuantityId(forecastQuantityId);
		forecastQuantityEntity.setBelongOrgCode(orgCode);
		forecastQuantityEntity.setRegion(region);
		forecastQuantityEntity.setRelevantOrgCode(relevantOrgCode);
		forecastQuantityEntity.setWeightTotal(weightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setVolumeTotal(volumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setWaybillQtyTotal(waybillQtyTotal);
		forecastQuantityEntity.setGpsEnabledResWeightTotal(gpsEnabledResWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setGpsEnabledResVolumeTotal(gpsEnabledResVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setGpsEnabledResQtyTotal(gpsEnabledResQtyTotal);
		forecastQuantityEntity.setPrecisionIfsWeightTotal(precisionIfsWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setPrecisionIfsVolumeTotal(precisionIfsVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setPrecisionIfsQtyTotal(precisionIfsQtyTotal);
		forecastQuantityEntity.setExpressWeightTotal(expressWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setExpressVolumeTotal(expressVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setExpressQtyTotal(expressQtyTotal);
		forecastQuantityEntity.setInventoryWeightTotal(inventoryWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setInventoryVolumeTotal(inventoryVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setInventoryQtyTotal(inventoryQtyTotal);
		forecastQuantityEntity.setBillingWeightTotal(billingWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setBillingVolumeTotal(billingVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setBillingQtyTotal(billingQtyTotal);
		forecastQuantityEntity.setIntransitWeightTotal(intransitWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setIntransitVolumeTotal(intransitVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setIntransitQtyTotal(intransitQtyTotal);
		forecastQuantityEntity.setStatisticsTime(statistics);
		forecastQuantityEntity.setStatisticsDate(statisticsDate);
		forecastQuantityEntity.setStatisticsHHMM(statisticsHHMM);
		// 转换为日期保存 日期代表本日期周期
		forecastTime = DateUtils.convert(DateUtils.convert(forecastTime, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
		forecastQuantityEntity.setForecastTime(forecastTime);
		forecastQuantityEntity.setType(action);
		
		forecastQuantityDao.addforecastQuantity(forecastQuantityEntity);
		// 调用方法做开单表数据
		billingForecast(forecastQuantityId, action, statistics, orgCode, relevantOrgCode, region, billingBeLongList, setSalesDepartmentCode);
		// 调用方法做在途表数据
		inTransitForecast(forecastQuantityId, action, statistics, orgCode, relevantOrgCode, region, inTransitList, setVehicleCode);
	}

	/**
	 * 根据到达营业部统计条目信息 新增到主表
	 * 
	 * @author huyue
	 * @date 2012-11-29 下午7:43:19
	 */
	
	public void forecastSalesDeptArrive(String action, Date forecastTime, Date statistics, String orgCode, List<ForecastDto> billingList, List<ForecastDto> inTransitList, String relevantOrgCode) {
		// 拆分预测时间
		Date statisticsDate = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
		SimpleDateFormat sdf2 = new SimpleDateFormat("HHmm");
		String statisticsHHMM = sdf2.format(statistics);
		// 设置统计字段
		//总 = 开单+ 在途
		// 总重量
		BigDecimal weightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		// 总体积
		BigDecimal volumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		// 总单数
		Integer waybillQtyTotal = 0;
		
		//总卡航 = 开单卡航+ 在途卡航
		// 总重量
		BigDecimal gpsEnabledResWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		// 总体积
		BigDecimal gpsEnabledResVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		// 总单数
		Integer gpsEnabledResQtyTotal = 0;
		
		//总城运 = 开单城运+ 在途 城运
		// 总重量
		BigDecimal precisionIfsWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		// 总体积
		BigDecimal precisionIfsVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		// 总单数
		Integer precisionIfsQtyTotal = 0;
		
		//快递 = 开单快递 + 在途快递 + 在库快递
		BigDecimal expressWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal expressVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer expressQtyTotal = 0;
		
		//在库
		BigDecimal inventoryWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal inventoryVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer inventoryQtyTotal = 0;
		
		//开单
		BigDecimal billingWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal billingVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer billingQtyTotal = 0;
		
		//在途
		BigDecimal intransitWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal intransitVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer intransitQtyTotal = 0;
		
		Set<String> setTotalWaybill = new HashSet<String>();
		Set<String> setInTransitWaybill = new HashSet<String>();
		Set<String> setBillingWaybill = new HashSet<String>();
		Set<String> setInventoryWaybill = new HashSet<String>();
		Set<String> setGpsEnabledResWaybill = new HashSet<String>();
		Set<String> setPrecisionIfsWaybill = new HashSet<String>();
		Set<String> setExpressWaybill = new HashSet<String>();
		Set<String> setVehicleCode = new HashSet<String>();
		// 循环开单货件LIST
		for (int j = 0; j < billingList.size(); j++) {
			// 总量增加
			weightTotal = weightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
			volumeTotal = volumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
			setTotalWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			// 开单量增加
			billingWeightTotal = billingWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
			billingVolumeTotal = billingVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
			setBillingWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			// 判断是否精准卡航
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
				// 卡航量增加
				gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setGpsEnabledResWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否精准城运
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
				// 城运量增加
				precisionIfsWeightTotal = precisionIfsWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setPrecisionIfsWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否快递
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)
			||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
			||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"EPEP")
			)) {
				// 快递量增加
				expressWeightTotal = expressWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				expressVolumeTotal = expressVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setExpressWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
		}
		// 循环在途货件LIST
		for (int j = 0; j < inTransitList.size(); j++) {
			// 总量增加
			weightTotal = weightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
			volumeTotal = volumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
			setTotalWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			// 在途量增加
			intransitWeightTotal = intransitWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
			intransitVolumeTotal = intransitVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
			setInTransitWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			// 判断是否精准卡航
			if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
				// 卡航量增加
				gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
				gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
				setGpsEnabledResWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否精准城运
			if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
				// 城运量增加
				precisionIfsWeightTotal = precisionIfsWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
				precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
				setPrecisionIfsWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否快递
			if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
				PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)||
				StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
				||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"EPEP"))) {
				// 快递量增加
				expressWeightTotal = expressWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
				expressVolumeTotal = expressVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
				setExpressWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
			}
			String vehicleNo;
			// 到达车牌号为本段车牌号
			vehicleNo = inTransitList.get(j).getPathDetailEntity().getVehicleNo();
			setVehicleCode.add(vehicleNo);
		}
		// 设置总票数
		waybillQtyTotal = setTotalWaybill.size();
		// 设置开单票数
		billingQtyTotal = setBillingWaybill.size();
		// 设置在途票数
		intransitQtyTotal = setInTransitWaybill.size();
		// 设置在库票数
		inventoryQtyTotal = setInventoryWaybill.size();
		// 设置卡航票数
		gpsEnabledResQtyTotal = setGpsEnabledResWaybill.size();
		// 设置城运票数
		precisionIfsQtyTotal = setPrecisionIfsWaybill.size();
		// 设置快递票数
		expressQtyTotal = setExpressWaybill.size();
		String forecastQuantityId = UUIDUtils.getUUID();
		
		// 提交总表
		ForecastQuantityEntity forecastQuantityEntity = new ForecastQuantityEntity();
		
		forecastQuantityEntity.setForecastQuantityId(forecastQuantityId);
		forecastQuantityEntity.setBelongOrgCode(orgCode);
		forecastQuantityEntity.setRelevantOrgCode(relevantOrgCode);
		forecastQuantityEntity.setWeightTotal(weightTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setVolumeTotal(volumeTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setWaybillQtyTotal(waybillQtyTotal);
		forecastQuantityEntity.setGpsEnabledResWeightTotal(gpsEnabledResWeightTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setGpsEnabledResVolumeTotal(gpsEnabledResVolumeTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setGpsEnabledResQtyTotal(gpsEnabledResQtyTotal);
		forecastQuantityEntity.setPrecisionIfsWeightTotal(precisionIfsWeightTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setPrecisionIfsVolumeTotal(precisionIfsVolumeTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setPrecisionIfsQtyTotal(precisionIfsQtyTotal);
		forecastQuantityEntity.setExpressWeightTotal(expressWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setExpressVolumeTotal(expressVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setExpressQtyTotal(expressQtyTotal);
		forecastQuantityEntity.setInventoryWeightTotal(inventoryWeightTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setInventoryVolumeTotal(inventoryVolumeTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setInventoryQtyTotal(inventoryQtyTotal);
		forecastQuantityEntity.setBillingWeightTotal(billingWeightTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setBillingVolumeTotal(billingVolumeTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setBillingQtyTotal(billingQtyTotal);
		forecastQuantityEntity.setIntransitWeightTotal(intransitWeightTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setIntransitVolumeTotal(intransitVolumeTotal.setScale(three, RoundingMode.HALF_DOWN));
		forecastQuantityEntity.setIntransitQtyTotal(intransitQtyTotal);
		forecastQuantityEntity.setStatisticsTime(statistics);
		forecastQuantityEntity.setStatisticsDate(statisticsDate);
		forecastQuantityEntity.setStatisticsHHMM(statisticsHHMM);
		forecastQuantityEntity.setForecastTime(forecastTime);
		forecastQuantityEntity.setType(action);
		
		//提交
		forecastQuantityDao.addforecastQuantity(forecastQuantityEntity);
		// 调用方法做在途表数据
		forecastService.inTransitForecast(forecastQuantityId, action, statistics, orgCode, relevantOrgCode, null, inTransitList, setVehicleCode);
	}

	/**
	 * 根据出发营业部统计条目信息 新增到主表
	 * 
	 * @author huyue
	 * @date 2012-11-29 下午7:52:35
	 */
	
	public void forecastSalesDeptDepart(String action, Date forecastTime, Date statistics, String orgCode, List<ForecastDto> billingList, String relevantOrgCode) {
		// 拆分预测时间
		Date statisticsDate = DateUtils.convert(DateUtils.convert(statistics, DateUtils.DATE_FORMAT), DateUtils.DATE_FORMAT);
		SimpleDateFormat sdf2 = new SimpleDateFormat("HHmm");
		String statisticsHHMM = sdf2.format(statistics);
		// 设置统计字段
		BigDecimal weightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal volumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer waybillQtyTotal = 0;
		BigDecimal gpsEnabledResWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal gpsEnabledResVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer gpsEnabledResQtyTotal = 0;
		BigDecimal precisionIfsWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal precisionIfsVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer precisionIfsQtyTotal = 0;
		BigDecimal expressWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal expressVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer expressQtyTotal = 0;
		BigDecimal inventoryWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal inventoryVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer inventoryQtyTotal = 0;
		BigDecimal billingWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal billingVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer billingQtyTotal = 0;
		BigDecimal intransitWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		BigDecimal intransitVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
		Integer intransitQtyTotal = 0;
		Set<String> setTotalWaybill = new HashSet<String>();
		Set<String> setInTransitWaybill = new HashSet<String>();
		Set<String> setBillingWaybill = new HashSet<String>();
		Set<String> setInventoryWaybill = new HashSet<String>();
		Set<String> setGpsEnabledResWaybill = new HashSet<String>();
		Set<String> setPrecisionIfsWaybill = new HashSet<String>();
		Set<String> setExpressWaybill = new HashSet<String>();
		Set<String> setSalesDepartmentCode = new HashSet<String>();
		// 循环开单货件LIST
		for (int j = 0; j < billingList.size(); j++) {
			// 总量增加
			weightTotal = weightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
			volumeTotal = volumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
			setTotalWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			
			// 开单量增加
			billingWeightTotal = billingWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
			billingVolumeTotal = billingVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
			setBillingWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			
			// 判断是否精准卡航
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
				// 卡航量增加
				gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setGpsEnabledResWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否精准城运
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
				// 城运量增加
				precisionIfsWeightTotal = precisionIfsWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setPrecisionIfsWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			// 判断是否快递
			if (null != billingList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),
			PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)||
			StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
			||StringUtil.equals(billingList.get(j).getTransportPathEntity().getTransportModel(),"EPEP"))) {
				// 快递量增加
				expressWeightTotal = expressWeightTotal.add(billingList.get(j).getTransportPathEntity().getTotalWeight());
				expressVolumeTotal = expressVolumeTotal.add(billingList.get(j).getTransportPathEntity().getTotalVolume());
				setExpressWaybill.add(billingList.get(j).getTransportPathEntity().getWaybillNo());
			}
			setSalesDepartmentCode.add(billingList.get(j).getPathDetailEntity().getOrigOrgCode());
		}
		
		// 设置总票数
		waybillQtyTotal = setTotalWaybill.size();
		// 设置开单票数
		billingQtyTotal = setBillingWaybill.size();
		// 设置在途票数
		intransitQtyTotal = setInTransitWaybill.size();
		// 设置在库票数
		inventoryQtyTotal = setInventoryWaybill.size();
		// 设置卡航票数
		gpsEnabledResQtyTotal = setGpsEnabledResWaybill.size();
		// 设置城运票数
		precisionIfsQtyTotal = setPrecisionIfsWaybill.size();
		// 设置快递票数
		expressQtyTotal = setExpressWaybill.size();
		// 提交总表
		ForecastQuantityEntity forecastQuantityEntity = new ForecastQuantityEntity();
		
		String forecastQuantityId = UUIDUtils.getUUID();
		forecastQuantityEntity.setForecastQuantityId(forecastQuantityId);
		forecastQuantityEntity.setBelongOrgCode(orgCode);
		forecastQuantityEntity.setRelevantOrgCode(relevantOrgCode);
		forecastQuantityEntity.setWeightTotal(weightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setVolumeTotal(volumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setWaybillQtyTotal(waybillQtyTotal);
		forecastQuantityEntity.setGpsEnabledResWeightTotal(gpsEnabledResWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setGpsEnabledResVolumeTotal(gpsEnabledResVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setGpsEnabledResQtyTotal(gpsEnabledResQtyTotal);
		forecastQuantityEntity.setPrecisionIfsWeightTotal(precisionIfsWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setPrecisionIfsVolumeTotal(precisionIfsVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setPrecisionIfsQtyTotal(precisionIfsQtyTotal);
		forecastQuantityEntity.setExpressWeightTotal(expressWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setExpressVolumeTotal(expressVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setExpressQtyTotal(expressQtyTotal);
		forecastQuantityEntity.setInventoryWeightTotal(inventoryWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setInventoryVolumeTotal(inventoryVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setInventoryQtyTotal(inventoryQtyTotal);
		forecastQuantityEntity.setBillingWeightTotal(billingWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setBillingVolumeTotal(billingVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setBillingQtyTotal(billingQtyTotal);
		forecastQuantityEntity.setIntransitWeightTotal(intransitWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setIntransitVolumeTotal(intransitVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
		forecastQuantityEntity.setIntransitQtyTotal(intransitQtyTotal);
		forecastQuantityEntity.setStatisticsTime(statistics);
		forecastQuantityEntity.setStatisticsDate(statisticsDate);
		forecastQuantityEntity.setStatisticsHHMM(statisticsHHMM);
		forecastQuantityEntity.setForecastTime(forecastTime);
		forecastQuantityEntity.setType(action);
		
		//提交
		forecastQuantityDao.addforecastQuantity(forecastQuantityEntity);
		// 调用方法做开单表数据
		billingForecast(forecastQuantityId, action, statistics, orgCode, relevantOrgCode, null, billingList, setSalesDepartmentCode);
	}

	/**
	 * 根据总表UUID,现部门,到达部门,始发配载部门list等生成开单表信息
	 * 
	 * 开单(运单)
	 * 计算 : 开单数(运单数),开单总重量,开单体积
	 *
	 * 所有开单(运单)中分为
	 * 	精准卡航 :
	 * 		计算  : 开单数(运单数),总重量,总体积
	 * 	精准城运 :
	 * 		计算 : 开单数(运单数),总重量,总体积
	 * 
	 * PS : 运单包含 精准卡航、精准城运
	 * @author huyue
	 * @date 2012-11-28 下午3:16:59
	 */
	public void billingForecast(String forecastQuantityId, String action, Date statistics, String orgCode, String relevantOrgCode, String region, List<ForecastDto> billingBeLongList, Set<String> setSalesDepartmentCode) throws TfrBusinessException {
		Object salesDepartmentCode[] = setSalesDepartmentCode.toArray();
		//开单部门 或 出发部门 TEMP
		String salesDept = "";
		
		// 根据所有所属营业部循环
		for (int i = 0; i < salesDepartmentCode.length; i++) {
			// 出发营业部
			String salesDeptOrgCode = salesDepartmentCode[i].toString();
			String salesDistrict = "";
			// 查询上级部门中指定类型为营业小区的部门
			List<String> bizTypes = new ArrayList<String>();
			bizTypes.add(BizTypeConstants.ORG_SMALL_REGION);
			OrgAdministrativeInfoEntity upOrgCodeEntity = orgAdministrativeInfoComplexService.queryOrgAdministrativeInfoByCode(salesDeptOrgCode, bizTypes);
			if (null == upOrgCodeEntity || StringUtil.isEmpty(upOrgCodeEntity.getCode())) {
				logger.error("调用综合接口查询营业部所属营业小区没有数据! 类: " + orgAdministrativeInfoComplexService + " 方法: queryOrgAdministrativeInfoByCode orgCode : " + salesDeptOrgCode + " bizTypes : " + bizTypes);
			} else {
				// 设置出发营业部所属营业区
				
				salesDistrict = upOrgCodeEntity.getCode();
			}
			
			//设置统计字段 运单下面分成  精准卡航、精准城运
			
			// 开单(运单)
			//总重量
			BigDecimal billingWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总体积
			BigDecimal billingVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总单数
			Integer billingWaybillQty = 0;
			
			//精准卡航
			//GPS 总重量
			BigDecimal gpsEnabledResWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//GPS 总体积
			BigDecimal gpsEnabledResVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//GPS 总单数
			Integer gpsEnabledResQtyTotal = 0;
			
			//精准城运
			//总重量(普:城运)
			BigDecimal precisionIfsWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总体积(普:城运)
			BigDecimal precisionIfsVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总单数(普:城运)
			Integer precisionIfsQtyTotal = 0;
			
			//快递
			//总重量(快递)
			BigDecimal expressWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总体积(快递)
			BigDecimal expressVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总单数(快递)
			Integer expressQtyTotal = 0;
			
			//SET 去除重复
			Set<String> setBillingWaybill = new HashSet<String>();
			Set<String> setGpsEnabledResWaybill = new HashSet<String>();
			Set<String> setPrecisionIfsWaybill = new HashSet<String>();
			Set<String> setExpressWaybill = new HashSet<String>();
			
			// 循环list 找到符合条件的条目统计
			for (int j = 0; j < billingBeLongList.size(); j++) {
				// 如果是出发货量,则看开单营业部是否属于出发营业部
				if (StringUtil.equals(ForecastConstants.FORECAST_DEPART, action)) {
					
					salesDept = billingBeLongList.get(j).getPathDetailEntity().getBillingOrgCode();
				} else {// 否则是到达货量,则看出发部门是否属于出发营业部,并且出发部门应等于开单部门
					
					salesDept = billingBeLongList.get(j).getPathDetailEntity().getOrigOrgCode();
				}
				// 如果本条是该出发营业部的,则统计
				if (StringUtil.equals(salesDept, salesDeptOrgCode)) {
					// 开单量增加
					billingWeightTotal = billingWeightTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalWeight());
					billingVolumeTotal = billingVolumeTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalVolume());
					setBillingWaybill.add(billingBeLongList.get(j).getTransportPathEntity().getWaybillNo());
					// 判断是否精准卡航
					if (null != billingBeLongList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingBeLongList.get(j).getTransportPathEntity().getTransportModel(), PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
						// 卡航量增加
						gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalWeight());
						gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalVolume());
						setGpsEnabledResWaybill.add(billingBeLongList.get(j).getTransportPathEntity().getWaybillNo());
					}
					// 判断是否精准城运
					if (null != billingBeLongList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(billingBeLongList.get(j).getTransportPathEntity().getTransportModel(),
					PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
						// 城运量增加
						precisionIfsWeightTotal = precisionIfsWeightTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalWeight());
						precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalVolume());
						setPrecisionIfsWaybill.add(billingBeLongList.get(j).getTransportPathEntity().getWaybillNo());
					}
					// 判断是否快递
					if (null != billingBeLongList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(billingBeLongList.get(j).getTransportPathEntity().getTransportModel(),
					PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)||
					StringUtil.equals(billingBeLongList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
					||StringUtil.equals(billingBeLongList.get(j).getTransportPathEntity().getTransportModel(),"EPEP"))) {
						// 快递量增加
						expressWeightTotal = expressWeightTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalWeight());
						expressVolumeTotal = expressVolumeTotal.add(billingBeLongList.get(j).getTransportPathEntity().getTotalVolume());
						setExpressWaybill.add(billingBeLongList.get(j).getTransportPathEntity().getWaybillNo());
					}
				}
			}
			/**开单票数*/
			billingWaybillQty = setBillingWaybill.size();
			/**卡航票数*/
			gpsEnabledResQtyTotal = setGpsEnabledResWaybill.size();
			/**城运票数*/
			precisionIfsQtyTotal = setPrecisionIfsWaybill.size();
			/**快递票数*/
			expressQtyTotal = setExpressWaybill.size();
			
			// 提交开单表
			BillingEntity billingEntity = new BillingEntity();
			
			billingEntity.setBillingId(UUIDUtils.getUUID());
			billingEntity.setBelongOrgCode(orgCode);
			billingEntity.setRelevantOrgCode(relevantOrgCode);
			billingEntity.setBillingSalesDepartment(salesDeptOrgCode);
			billingEntity.setBillingSalesDistrict(salesDistrict);
			billingEntity.setBillingWeight(billingWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setBillingVolume(billingVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setBillingQty(billingWaybillQty);
			billingEntity.setGpsEnabledResWeight(gpsEnabledResWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setGpsEnabledResVolume(gpsEnabledResVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setGpsEnabledResQty(gpsEnabledResQtyTotal);
			billingEntity.setPrecisionIfsWeight(precisionIfsWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setPrecisionIfsVolume(precisionIfsVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setPrecisionIfsQty(precisionIfsQtyTotal);
			billingEntity.setGpsEnabledResQty(gpsEnabledResQtyTotal);
			billingEntity.setExpressWeight(expressWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setExpressVolume(expressVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			billingEntity.setExpressQty(expressQtyTotal);
			billingEntity.setForecastQuantityId(forecastQuantityId);
			billingEntity.setRegion(region);
			billingEntity.setType(action);
			billingEntity.setStatisticsTime(statistics);
			
			//更新
			billingDao.addbilling(billingEntity);
		}
	}

	/**
	 * 根据总表UUID,现部门,到达部门,车牌号list等生成在途表信息
	 * 
	 * 在途(运单)
	 * 计算 : 在途总单数 ,在途运总重量,在途运体积
	 *
	 * 所有在途运单中分为
	 * 	精准卡航 :
	 * 		计算  : 总单数,总重量,总体积
	 * 	精准城运 :
	 * 		计算 : 总单数,总重量,总体积
	 * 
	 * PS : 运单包含 精准卡航、精准城运
	 * @author huyue
	 * @date 2012-11-28 下午9:01:20
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#billingForecast(java.lang.String,
	 *      java.lang.String, java.util.Date, java.lang.String,
	 *      java.lang.String, java.lang.String, java.util.List, java.util.Set)
	 */
	public void inTransitForecast(String forecastQuantityId, String action, Date statistics, String orgCode, String relevantOrgCode, String region, List<ForecastDto> inTransitList, Set<String> setVehicleCode) throws TfrBusinessException {
		Object vehicleCode[] = setVehicleCode.toArray();
		// 根据所有 在途车牌号循环
		for (int i = 0; i < vehicleCode.length; i++) {
			// 在途车牌号
			String vehicleNo = vehicleCode[i].toString();

			//在途运单总重量
			BigDecimal intransitWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//在途运单总体积
			BigDecimal intransitVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//在途运单总票数
			Integer intransitQtyTotal = 0;
			
			//在途运单 中 卡航 总重量
			BigDecimal gpsEnabledResWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//在途运单 中 卡航 总体积
			BigDecimal gpsEnabledResVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//在途运单 中 卡航 总票数
			Integer gpsEnabledResQtyTotal = 0;
			
			//在途运单 中 城运 总重量
			BigDecimal precisionIfsWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//在途运单 中 城运 总体积
			BigDecimal precisionIfsVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//在途运单 中 城运 总票数
			Integer precisionIfsQtyTotal = 0;
			
			//快递
			//总重量(快递)
			BigDecimal expressWeightTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总体积(快递)
			BigDecimal expressVolumeTotal = BigDecimal.ZERO.setScale(three, RoundingMode.HALF_DOWN);
			//总单数(快递)
			Integer expressQtyTotal = 0;
			
			Set<String> setInTransitWaybill = new HashSet<String>();
			Set<String> setGpsEnabledResWaybill = new HashSet<String>();
			Set<String> setPrecisionIfsWaybill = new HashSet<String>();
			Set<String> setExpressWaybill = new HashSet<String>();
			
			// 循环list 找到符合条件的条目统计
			for (int j = 0; j < inTransitList.size(); j++) {
				String vehicle;
				// 如果是出发货量,则看开单营业部是否属于出发营业部
				if (StringUtil.equals(ForecastConstants.FORECAST_DEPART, action)) {
					vehicle = inTransitList.get(j).getPathDetailEntity().getBeforeVehicleNo();
				} else {// 否则是到达货量,则看出发部门是否属于出发营业部,并且出发部门应等于开单部门
					vehicle = inTransitList.get(j).getPathDetailEntity().getVehicleNo();
				}
				// 如果本条是该出发营业部的,则统计
				if (StringUtil.equals(vehicle, vehicleNo)) {
					// 在途量增加
					intransitWeightTotal = intransitWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
					intransitVolumeTotal = intransitVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
					setInTransitWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
					// 判断是否精准卡航
					if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(), PricingConstants.ProductEntityConstants.PRICING_PRODUCT_LONG_DISTANCE_FAST_FREIGHT)) {
						// 卡航量增加
						gpsEnabledResWeightTotal = gpsEnabledResWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
						gpsEnabledResVolumeTotal = gpsEnabledResVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
						setGpsEnabledResWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
					}
					// 判断是否精准城运
					if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
					PricingConstants.ProductEntityConstants.PRICING_PRODUCT_SHORT_DISTANCE_FAST_FREIGHT)) {
						// 城运量增加
						precisionIfsWeightTotal = precisionIfsWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
						precisionIfsVolumeTotal = precisionIfsVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
						setPrecisionIfsWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
					}
					// 判断是否快递
					if (null != inTransitList.get(j).getTransportPathEntity().getTransportModel() && (StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),
					PricingConstants.ProductEntityConstants.PRICING_PRODUCT_EXPRESS_PACKAGE)||
					StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),"RCP")
					||StringUtil.equals(inTransitList.get(j).getTransportPathEntity().getTransportModel(),"EPEP"))) {
						// 快递量增加
						expressWeightTotal = expressWeightTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalWeight());
						expressVolumeTotal = expressVolumeTotal.add(inTransitList.get(j).getTransportPathEntity().getTotalVolume());
						setExpressWaybill.add(inTransitList.get(j).getTransportPathEntity().getWaybillNo());
					}
				}
			}
			
			//计算在途 运单总数
			intransitQtyTotal = setInTransitWaybill.size();
			//计算在途 运单中卡航总数
			gpsEnabledResQtyTotal = setGpsEnabledResWaybill.size();
			//计算在途 运单中城运总数
			precisionIfsQtyTotal = setPrecisionIfsWaybill.size();
			//计算在途 运单中快递总数
			expressQtyTotal = setExpressWaybill.size();
			
			// 提交在途表
			InTransitEntity inTransitEntity = new InTransitEntity();
			
			inTransitEntity.setIntransitId(UUIDUtils.getUUID());
			inTransitEntity.setBelongOrgCode(orgCode);
			inTransitEntity.setRelevantOrgCode(relevantOrgCode);
			inTransitEntity.setIntransitVehicleNo(vehicleNo);
			inTransitEntity.setIntransitWeight(intransitWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setIntransitVolume(intransitVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setIntransitQty(intransitQtyTotal);
			inTransitEntity.setGpsEnabledResWeight(gpsEnabledResWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setGpsEnabledResVolume(gpsEnabledResVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setGpsEnabledResQty(gpsEnabledResQtyTotal);
			inTransitEntity.setPrecisionIfsWeight(precisionIfsWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setPrecisionIfsVolume(precisionIfsVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setPrecisionIfsQty(precisionIfsQtyTotal);
			inTransitEntity.setExpressWeight(expressWeightTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setExpressVolume(expressVolumeTotal.setScale(three, BigDecimal.ROUND_HALF_DOWN));
			inTransitEntity.setExpressQty(expressQtyTotal);
			inTransitEntity.setForecastQuantityId(forecastQuantityId);
			inTransitEntity.setRegion(region);
			inTransitEntity.setType(action);
			inTransitEntity.setStatisticsTime(statistics);
			
			//新增
			inTransitDao.addinTransit(inTransitEntity);
		}
	}

	/**
	 * 查询到达开单部门LIST
	 * @author huyue
	 * @date 2012-11-27 下午3:20:49
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#arriveBilling(java.lang.String,
	 *      java.util.Date, java.util.Date)
	 */
	public List<String> arriveRelevantOrgCode(String orgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		Map<String, Object> billingMap = new HashMap<String, Object>();
		List<String> listType = new ArrayList<String>();
		/** 
		 * 赋值 
		 */
		listType.add(TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		/** 
		 * 赋值 
		 */
		listType.add(TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
		/** 
		 * 赋值 
		 */
		listType.add(TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
		// 找到状态为未离开的
		/** 
		 * 赋值 
		 */
		billingMap.put(objective, orgCode);
		/** 
		 * 赋值 
		 */
		billingMap.put("arriveOrLeaveList", listType);
		/** 
		 * 赋值 
		 */
		billingMap.put(countStartTime, forecastStartTime);
		/** 
		 * 赋值 
		 */
		billingMap.put(countEndTime, forecastEndTime);
		return pathDetailDao.queryArriveRelevantOrgCode(billingMap);
	}

	/**
	 * 查询到达开单LIST
	 * @param objectiveOrgCode
	 * @param origOrgCode
	 * @param forecastStartTime
	 * @param forecastEndTime
	 * @author huyue
	 * @date 2012-11-27 下午3:20:49
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#arriveBilling(java.lang.String,
	 *      java.util.Date, java.util.Date)
	 */
	public List<PathDetailEntity> arriveBilling(String objectiveOrgCode, String origOrgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		Map<String, Object> billingMap = new HashMap<String, Object>();
		// 找到状态为未离开的
		/** 
		 * 赋值 
		 */
		billingMap.put(origOrg, origOrgCode);
		/** 
		 * 赋值 
		 */
		billingMap.put(objective, objectiveOrgCode);
		/** 
		 * 赋值 
		 */
		billingMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		/** 
		 * 赋值 
		 */
		billingMap.put(countStartTime, forecastStartTime);
		/** 
		 * 赋值 
		 */
		billingMap.put(countEndTime, forecastEndTime);
		return pathDetailDao.queryArrive(billingMap);
	}

	/**
	 * 查询到达在途LIST
	 * @author huyue
	 * @date 2012-11-27 下午3:25:05
	 */
	public List<PathDetailEntity> arriveInTransit(String objectiveOrgCode, String origOrgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		Map<String, Object> inTransitMap = new HashMap<String, Object>();
		// 找到状态为已交接的
		/** 
		 * 赋值 
		 */
		inTransitMap.put(origOrg, origOrgCode);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(objective, objectiveOrgCode);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_HANDOVER);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(countStartTime, forecastStartTime);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(countEndTime, forecastEndTime);
		List<PathDetailEntity> arriveHandoverList = pathDetailDao.queryArrive(inTransitMap);
		inTransitMap = new HashMap<String, Object>();
		// 找到状态为出发的
		/** 
		 * 赋值 
		 */
		inTransitMap.put(origOrg, origOrgCode);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(objective, objectiveOrgCode);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_LEAVE);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(countStartTime, forecastStartTime);
		/** 
		 * 赋值 
		 */
		inTransitMap.put(countEndTime, forecastEndTime);
		List<PathDetailEntity> arriveLeaveList = pathDetailDao.queryArrive(inTransitMap);
		List<PathDetailEntity> arriveList = new ArrayList<PathDetailEntity>();
		arriveList.addAll(arriveHandoverList);
		arriveList.addAll(arriveLeaveList);
		for (int a = 0; a < arriveList.size(); a++) {
			// 为空的都是交接没有车牌号的
			if (StringUtils.isEmpty(arriveList.get(a).getVehicleNo())) {
				arriveList.get(a).setVehicleNo("N/A");
			}
		}
		return arriveList;
	}

	/**
	 * 查询出发开单部门LIST
	 * @author huyue
	 * @date 2012-12-18 下午2:51:20
	 */
	public List<String> departRelevantOrgCode(String orgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		Map<String, Object> billingMap = new HashMap<String, Object>();
		// 找到状态为未离开的
		/** 
		 * 赋值 
		 */
		billingMap.put(origOrg, orgCode);
		/** 
		 * 赋值 
		 */
		billingMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		/** 
		 * 赋值 
		 */
		billingMap.put(countStartTime, forecastStartTime);
		/** 
		 * 赋值 
		 */
		billingMap.put(countEndTime, forecastEndTime);
		return pathDetailDao.departRelevantOrgCode(billingMap);
	}

	/**
	 * 查询出发开单LIST
	 * 
	 * arriveOrLeave: 状态为 -> 未离开,<br/>
	 * 
	 * 上段车牌号不空 就是出发货量里的在途货量<br/>
	 * 
	 * SQL: <br/>
	 *
	 <pan>
	  SELECT
		(*)
		FROM TFR.T_OPT_PATH_DETAIL 
		WHERE <br/>
		ORIG_ORG_CODE = #{origOrgCode} 
		AND OBJECTIVE_ORG_CODE = #{objectiveOrgCode}
		AND ARRIVE_OR_LEAVE = #{arriveOrLeave}
		AND #{countStartTime} <= MODIFY_START_TIME
		AND #{countEndTime} > MODIFY_START_TIME
		AND BEFORE_VEHICLE_NO = 'N/A'
	</pan>
	 * 
	 * @author huyue
	 * @date 2012-11-29 上午11:31:04
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#departBilling(java.lang.String,
	 *      java.util.Date, java.util.Date)
	 */
	public List<PathDetailEntity> departBilling(String origOrgCode, String objectiveOrgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		Map<String, Object> billingMap = new HashMap<String, Object>();
		// 找到状态为未离开的 上一段车牌号为空的
		billingMap.put(origOrg, origOrgCode);
		billingMap.put(objective, objectiveOrgCode);
		billingMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		billingMap.put(countStartTime, forecastStartTime);
		billingMap.put(countEndTime, forecastEndTime);
		return pathDetailDao.queryStartBilling(billingMap);
	}

	/**
	 * 查询出发在途LIST <br/>
	 * 
	 * arriveOrLeave: 状态为 -> 未离开,<br/>
	 * 
	 * ifChangeTime : 是否修改过计划出发时间  -> 否,<br/>
	 * 
	 * 上段车牌号不空 就是出发货量里的在途货量<br/>
	 * 
	 * SQL: <br/>
	 *
	 <pan>
	  SELECT
		(*)
		FROM TFR.T_OPT_PATH_DETAIL 
		WHERE <br/>
		ORIG_ORG_CODE = #{origOrgCode} 
		AND OBJECTIVE_ORG_CODE = #{objectiveOrgCode}
		AND ARRIVE_OR_LEAVE = #{arriveOrLeave}
		AND #{countStartTime} <= MODIFY_START_TIME
		AND #{countEndTime} > MODIFY_START_TIME
		AND BEFORE_VEHICLE_NO = 'N/A'
	</pan>
	 * 
	 * @author huyue
	 * @date 2012-11-29 上午11:52:22
	 */
	public List<PathDetailEntity> departInTransit(String origOrgCode, String objectiveOrgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		Map<String, Object> inTransitMap = new HashMap<String, Object>();
		// 找到状态为未离开的 调整出发时间为否的 上一段车牌号不为空的
		inTransitMap.put(origOrg, origOrgCode);
		inTransitMap.put(objective, objectiveOrgCode);
		inTransitMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		inTransitMap.put(countStartTime, forecastStartTime);
		inTransitMap.put(countEndTime, forecastEndTime);
		/** 
		 *  是否修改过计划出发时间 -> N
		 */
		inTransitMap.put("ifChangeTime", TransportPathConstants.NOTCHANGETIME);
		return pathDetailDao.queryStartNotBilling(inTransitMap);
	}

	/**
	 * 查询出发在库LIST <br/>
	 * 
	 *  BUG-36705 by 134019-foss-yuyongxiang 2013年6月25日 15:30:21 修改在库逻辑<br/><br/>
	 *
<span>
		SELECT
			tstock.waybill_no AS waybillNo
		FROM TFR.T_OPT_STOCK tstock
		WHERE
			tstock.org_code =  #{origOrgCode}
		AND
			tstock.next_org_code =  #{objectiveOrgCode}
		AND #{countStartTime} <= tstock.in_stock_time
		AND #{countEndTime} > tstock.in_stock_time
</span>
	 *  <br/><br/>BUG-36705 by 134019-foss-yuyongxiang 2013年6月25日 15:30:21 修改在库逻辑<br/>
	 * <br/>
	 * <br/>
	 * <br/>
	 * <br/>
	 * arriveOrLeave: 状态为 -> 未离开,<br/>
	 * 
	 * ifChangeTime : 是否修改过计划出发时间  -> 是,<br/>
	 * 
	 * 上段车牌号不空 就是出发货量里的在库货量<br/>
	 * 
	 * SQL: <br/>
	 *
	 <span>
	  SELECT
		(*)
		FROM TFR.T_OPT_PATH_DETAIL 
		WHERE 
		ORIG_ORG_CODE = #{origOrgCode}
		AND OBJECTIVE_ORG_CODE = #{objectiveOrgCode}
		AND ARRIVE_OR_LEAVE = #{arriveOrLeave}
		AND #{countStartTime} <= MODIFY_START_TIME
		AND #{countEndTime} > MODIFY_START_TIME
		AND BEFORE_VEHICLE_NO != 'N/A'
		AND IF_CHANGE_TIME = #{ifChangeTime}
	</span>
	 * @author huyue
	 * @date 2012-11-29 上午11:53:54
	 */
	public List<PathDetailEntity> departInventory(String origOrgCode, String objectiveOrgCode, Date forecastStartTime, Date forecastEndTime) throws TfrBusinessException {
		
/*		Map<String, Object> inventoryMap = new HashMap<String, Object>();
		// 找到状态为未离开的 调整出发时间为是的 上一段车牌号不为空的
		*//* 
		 * 出发部门
		 *//*
		inventoryMap.put(origOrg, origOrgCode);
		*//*
		 * 目的部门
		 *//*
		inventoryMap.put(objective, objectiveOrgCode);
		*//*
		 * 抵达/离开
		 *//*
		inventoryMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);
		*//*
		 * countStartTime 小于等于 MODIFY_START_TIME(调整出发时间)
		 *//*
		inventoryMap.put(countStartTime, forecastStartTime);
		*//*
		 * countEndTime 大于 MODIFY_START_TIME(调整出发时间)
		 *//*
		inventoryMap.put(countEndTime, forecastEndTime);
		*//*
		 * 是否修改过计划出发时间 -> Y
		 *//*
		inventoryMap.put("ifChangeTime", TransportPathConstants.CHANGETIME);
		
		pathDetailDao.queryStartNotBilling(inventoryMap);*/
		
		
		// BUG-36705 by 134019-foss-yuyongxiang 2013年6月25日 15:30:21 修改在库逻辑
		
		Map<String, Object> inventoryMap = new HashMap<String, Object>();
		//出发部门
		inventoryMap.put(origOrg, origOrgCode);
		//到达部门
		inventoryMap.put(objective, objectiveOrgCode);
	/*	//起始入库时间
		inventoryMap.put(countStartTime, forecastStartTime);
		//结束入库时间
		inventoryMap.put(countEndTime, forecastEndTime);*/
		
		//根据 以上4个条件查询查询 库存中的运单号
		List<String> list =forecastQuantityDao.queryStockWhitInStock(inventoryMap);
		
		List<PathDetailEntity> pathDetailList =new ArrayList<PathDetailEntity>();
		
		PathDetailEntity pathDetail=null;
		
		for(String str: list){
			pathDetail=new PathDetailEntity();
			pathDetail.setWaybillNo(str);
			pathDetailList.add(pathDetail);
		}
		
		// BUG-36705 by 134019-foss-yuyongxiang 2013年6月25日 15:30:21 修改在库逻辑
		return pathDetailList;
	}

	/**
	 * 分批配载重新计算重量体积
	 * @author huyue
	 * @date 2012-11-27 下午5:13:41
	 */
	public TransportPathEntity reCalculate(TransportPathEntity transportPathEntity) {
		AverageCalculateEntity averageCalculateEntity = new AverageCalculateEntity();
		averageCalculateEntity.setOrgCode(transportPathEntity.getBillingOrgCode());
		
		//重量
		BigDecimal weight=BigDecimal.ONE;
		//体积
		BigDecimal volume=BigDecimal.ONE;
		//本次走货走了此运单几件货
		BigDecimal goodsQtyTotal=BigDecimal.ONE;
		//是否分批配载
		// 如果分批
		if (null != transportPathEntity.getIfPartialStowage() && StringUtils.equals(TransportPathConstants.PARTIALSTOWAGE, transportPathEntity.getIfPartialStowage())) {
			if(null != transportPathEntity.getWaybillNoCount()){
				try{
				goodsQtyTotal = BigDecimal.valueOf(Double.valueOf(transportPathEntity.getWaybillNoCount()));
				}catch (Exception e) {
					goodsQtyTotal =BigDecimal.ONE;
				}
			}
			//weight = (走货件数 /总件数)/1000  PS:这个地方是除以1000是为了把KG换算成T
			weight=(goodsQtyTotal.divide(BigDecimal.valueOf(transportPathEntity.getGoodsQtyTotal()),ten,RoundingMode.HALF_DOWN)).divide(BigDecimal.valueOf(ton));
			volume=goodsQtyTotal.divide(BigDecimal.valueOf(transportPathEntity.getGoodsQtyTotal()),ten,RoundingMode.HALF_DOWN);
		}else{//不分批的时候一票货不管有多少件都算一所以这个地方要取总重量所以值应该为1(PS单位换算除外)
			//这个地方是除以1000是为了把KG换算成T
			weight=goodsQtyTotal.divide(BigDecimal.valueOf(ton));
			//由于这个地方不需要转换所以就注释掉了
			//volume=goodsQtyTotal;
		}
		
		
		if (null != transportPathEntity.getTotalWeight() && null != transportPathEntity.getGoodsQtyTotal()) {
			//实际走货重量(T) = 总重量(KG) * ((走货件数 /总件数)/1000)(T)
			BigDecimal newWeight = transportPathEntity.getTotalWeight().multiply(weight);
			transportPathEntity.setTotalWeight(newWeight);
		} else {
			// 查询平均重量
			averageCalculateEntity = averageCalculateDao.queryAverageCalculate(averageCalculateEntity);
			if (null == averageCalculateEntity) {
				// 设置为0
				transportPathEntity.setTotalWeight(BigDecimal.ZERO);
			} else {
				// 取平均每件重量
				//实际走货重量(T) = 总重量(KG) * ((走货件数 /总件数)/1000)(T)
				BigDecimal newWeight = averageCalculateEntity.getAverageWeight().multiply(weight);
				transportPathEntity.setTotalWeight(newWeight);
			}
		}
		// 计算体积
		if (null != transportPathEntity.getTotalVolume() && null != transportPathEntity.getGoodsQtyTotal()) {
			BigDecimal newVolume = transportPathEntity.getTotalVolume().multiply(volume);
			transportPathEntity.setTotalVolume(newVolume);
		} else {
			// 查询平均体积
			averageCalculateEntity = averageCalculateDao.queryAverageCalculate(averageCalculateEntity);
			if (null == averageCalculateEntity) {
				// 设置为0
				transportPathEntity.setTotalVolume(BigDecimal.ZERO);
			} else {
				// 取平均每件体积
				BigDecimal newVolume = averageCalculateEntity.getAverageVolume().multiply(volume);
				transportPathEntity.setTotalWeight(newVolume);
			}
		}
		return transportPathEntity;
	}

	/**
	 * 根据外场编码查询所有辐射营业部
	 * @author huyue
	 * @date 2012-11-30 下午5:08:16
	 */
	public List<String> getSalesDeptListByTransferCode(String transferCode) {
		LineEntity condition = new LineEntity();
		condition.setActive(FossConstants.ACTIVE);
		condition.setDestinationOrganizationCode(transferCode);
		condition.setLineSort(DictionaryValueConstants.BSE_LINE_SORT_SOURCE);
		List<LineEntity> lineList = lineService.queryLineListByCondition(condition);
		List<String> salesDeptCodeList = new ArrayList<String>();
		for (int i = 0; i < lineList.size(); i++) {
			salesDeptCodeList.add(lineList.get(i).getOrginalOrganizationCode());
		}
		return salesDeptCodeList;
	}

	/**
	 * 根据出发,到达部门判断发车计划类型
	 * @author huyue
	 * @date 2013-1-5 下午6:52:29
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#queryDepartureType(java.lang.String,
	 *      java.lang.String)
	 */
	public String queryDepartureType(String origOrgCode, String destOrgCode) throws TfrBusinessException {
		GoodsAreaEntity goodsAreaEntity = goodsAreaService.queryGoodsAreaByArriveRegionCode(origOrgCode, destOrgCode, null);
		// 如果找不到库区.则表示这个路线没有发车类型
		if (null == goodsAreaEntity) {
			return null;
		} else {
			// 否则返回发车类型
			return goodsAreaEntity.getGoodsAreaUsage();
		}
	}

	/**
	 * 生成导出文件名称
	 * @author huyue
	 * @date 2013-1-7 下午2:51:23
	 */
	public String encodeFileName(String fileName) throws TfrBusinessException {
		try {
			String returnStr;
			String agent = (String) ServletActionContext.getRequest().getHeader("USER-AGENT");
			if (agent != null && agent.indexOf("MSIE") == -1) {
				returnStr = new String(fileName.getBytes("UTF-8"), "iso-8859-1");
			} else {
				returnStr = URLEncoder.encode(fileName, "UTF-8");
			}
			return returnStr;
		} catch (UnsupportedEncodingException e) {
			logger.error("转换文件名编码失败", e);
			throw new TfrBusinessException(StockException.EXPORT_FILE_ERROR_CODE, "");
		}
	}
	
	/**
	 * 导出预测数据到Excel
	 * @author huyue
	 * @date 2013-1-7 下午3:08:17
	 */
	public InputStream exportExcelStream(ForecastQuantityEntity forecastQuantityEntity) throws TfrBusinessException {
		InputStream excelStream = null;
		// 查询最新一批时间
		Date maxStatisticsTime = forecastQuantityDao.selectMaxStatisticsTime(forecastQuantityEntity);
		forecastQuantityEntity.setStatisticsTime(maxStatisticsTime);
		List<ForecastQuantityEntity> list = forecastQuantityDao.queryforecastQuantityList(forecastQuantityEntity);
		// 行List
		List<List<String>> rowList = new ArrayList<List<String>>();
		for (ForecastQuantityEntity forecastQuantityList : list) {
			// 每行的列List
			List<String> columnList = new ArrayList<String>();
			columnList.add(getNameByCode(forecastQuantityList.getBelongOrgCode()));
			
			//xiaobc update start.....................
			
			BigDecimal expressVolume =  forecastQuantityList.getExpressVolumeTotal();
			BigDecimal expressWeight = forecastQuantityList.getExpressWeightTotal();
		//zwd 调用综合接口，根据部门编码去查询重泡比，如果存在则使用查询到的重泡比，如果不存在则使用公用的重量体积转换参数。
			String orgCode = forecastQuantityList.getBelongOrgCode();
			BigDecimal ratio = this.queryForecastParameter(orgCode);//获取比率
			BigDecimal newExpressVolume = expressWeight.multiply(ratio).setScale(four, BigDecimal.ROUND_HALF_DOWN);
			BigDecimal volume = forecastQuantityList.getVolumeTotal();//总体积
			forecastQuantityList.setVolumeTotal(volume.subtract(expressVolume).add(newExpressVolume));//快递体积=总体积-原先的快递体积+转换后的快递体积
			forecastQuantityList.setExpressVolumeTotal(newExpressVolume);
		
		//xiaobc update start.....................
			
			if (null != siteGroupService.querySiteGroupByCode(forecastQuantityList.getRegion())) {
				/** 
				 * 赋值 
				 */
				columnList.add(siteGroupService.querySiteGroupByCode(forecastQuantityList.getRegion()).getName());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(forecastQuantityList.getRelevantOrgCode()));
			if (null != forecastQuantityList.getWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getWaybillQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getWaybillQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getGpsEnabledResWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getGpsEnabledResWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getGpsEnabledResVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getGpsEnabledResVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getGpsEnabledResQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getGpsEnabledResQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getPrecisionIfsWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getPrecisionIfsWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getPrecisionIfsVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getPrecisionIfsVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getPrecisionIfsQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getPrecisionIfsQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getExpressWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getExpressWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getExpressVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getExpressVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getExpressQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getExpressQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getInventoryWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getInventoryWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getInventoryVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getInventoryVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getInventoryQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getInventoryQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getBillingWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getBillingWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getBillingVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getBillingVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getBillingQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getBillingQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getIntransitWeightTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getIntransitWeightTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getIntransitVolumeTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getIntransitVolumeTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getIntransitQtyTotal()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getIntransitQtyTotal().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getDeviationVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(forecastQuantityList.getDeviationVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != forecastQuantityList.getStatisticsTime()) {
				/** 
				 * 赋值 
				 */
				columnList.add(DateUtils.convert(forecastQuantityList.getStatisticsTime(), DateUtils.DATE_TIME_FORMAT));
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			/** 
			 * 赋值 
			 */
			if(StringUtils.equals(forecastQuantityList.getType(),ForecastConstants.FORECAST_ARRIVE)){
				columnList.add("到达");
			}else{
				columnList.add("出发");
			}
			if (null != forecastQuantityList.getForecastTime()) {
				/** 
				 * 赋值 
				 */
				columnList.add(DateUtils.convert(forecastQuantityList.getForecastTime(), DateUtils.DATE_FORMAT));
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			rowList.add(columnList);
		}
		ExportResource forecastList = new ExportResource();
		/** 
		 * 赋值 
		 */
		forecastList.setHeads(TransportPathConstants.FORECAST_ROW_HEADS);
		/** 
		 * 赋值 
		 */
		forecastList.setRowList(rowList);
		ExportSetting exportSetting = new ExportSetting();
		exportSetting.setSize(TransportPathConstants.SHEET_SIZE);
		exportSetting.setSheetName(TransportPathConstants.FORECAST_SHEET_NAME);
		ExcelExporter objExcelExportor = new ExcelExporter();
		excelStream =  objExcelExportor.exportBySheet(forecastList, exportSetting);
		return excelStream;
	}

	/**
	 * 导出预测明细数据到Excel
	 * @author huyue
	 * @date 2013-1-8 下午2:07:28
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#detailExportExcelStream(java.lang.String)
	 */
	public InputStream detailExportExcelStream(String forecastQuantityId) throws TfrBusinessException {
		InputStream excelStream = null;
		// 获取开单信息
		BillingEntity billingEntity = new BillingEntity();
		billingEntity.setForecastQuantityId(forecastQuantityId);
		List<BillingEntity> billingList = billingDao.querybillingList(billingEntity);
		// 行List
		List<List<String>> rowBillingList = new ArrayList<List<String>>();
		for (BillingEntity billing : billingList) {
			// 每行的列List
			List<String> columnList = new ArrayList<String>();
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(billing.getBelongOrgCode()));
			if (null != siteGroupService.querySiteGroupByCode(billing.getRegion())) {
				/** 
				 * 赋值 
				 */
				columnList.add(siteGroupService.querySiteGroupByCode(billing.getRegion()).getName());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(billing.getRelevantOrgCode()));
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(billing.getBillingSalesDistrict()));
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(billing.getBillingSalesDepartment()));
			if (null != billing.getBillingWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getBillingWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getBillingVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getBillingVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getBillingQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getBillingQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getGpsEnabledResWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getGpsEnabledResWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getGpsEnabledResVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getGpsEnabledResVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getGpsEnabledResQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getGpsEnabledResQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getPrecisionIfsWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getPrecisionIfsWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getPrecisionIfsVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getPrecisionIfsVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getPrecisionIfsQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getPrecisionIfsQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getExpressWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getExpressWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getExpressVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getExpressVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getExpressQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(billing.getExpressQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != billing.getStatisticsTime()) {
				/** 
				 * 赋值 
				 */
				columnList.add(DateUtils.convert(billing.getStatisticsTime(), DateUtils.DATE_TIME_FORMAT));
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			/** 
			 * 赋值 
			 */
			if(StringUtils.equals(billing.getType(),ForecastConstants.FORECAST_ARRIVE)){
				columnList.add("到达");
			}else{
				columnList.add("出发");
			}
			/** 
			 * 赋值 
			 */
			rowBillingList.add(columnList);
		}
		ExportResource billing = new ExportResource();
		/** 
		 * 赋值 
		 */
		billing.setHeads(TransportPathConstants.BILLING_ROW_HEADS);
		/** 
		 * 赋值 
		 */
		if(CollectionUtils.isEmpty(rowBillingList)){
			rowBillingList.add(new ArrayList<String>(0));
		}
		billing.setRowList(rowBillingList);
		// 获取在途信息
		InTransitEntity inTransitEntity = new InTransitEntity();
		/** 
		 * 赋值 
		 */
		inTransitEntity.setForecastQuantityId(forecastQuantityId);
		List<InTransitEntity> inTransitList = inTransitDao.queryinTransitList(inTransitEntity);
		// 行List
		List<List<String>> rowInTransitList = new ArrayList<List<String>>();
		for (InTransitEntity inTransit : inTransitList) {
			// 每行的列List
			List<String> columnList = new ArrayList<String>();
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(inTransit.getBelongOrgCode()));
			if (null != siteGroupService.querySiteGroupByCode(inTransit.getRegion())) {
				/** 
				 * 赋值 
				 */
				columnList.add(siteGroupService.querySiteGroupByCode(inTransit.getRegion()).getName());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			/** 
			 * 赋值 
			 */
			columnList.add(getNameByCode(inTransit.getRelevantOrgCode()));
			/** 
			 * 赋值 
			 */
			columnList.add(inTransit.getIntransitVehicleNo());
			if (null != inTransit.getIntransitWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getIntransitWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getIntransitVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getIntransitVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getIntransitQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getIntransitQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getGpsEnabledResWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getGpsEnabledResWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getGpsEnabledResVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getGpsEnabledResVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getGpsEnabledResQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getGpsEnabledResQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getPrecisionIfsWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getPrecisionIfsWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getPrecisionIfsVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getPrecisionIfsVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getPrecisionIfsQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getPrecisionIfsQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getExpressWeight()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getExpressWeight().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getExpressVolume()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getExpressVolume().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getExpressQty()) {
				/** 
				 * 赋值 
				 */
				columnList.add(inTransit.getExpressQty().toString());
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			if (null != inTransit.getStatisticsTime()) {
				/** 
				 * 赋值 
				 */
				columnList.add(DateUtils.convert(inTransit.getStatisticsTime(), DateUtils.DATE_TIME_FORMAT));
			} else {
				/** 
				 * 赋值 
				 */
				columnList.add(null);
			}
			/** 
			 * 赋值 
			 */
			if(StringUtils.equals(inTransit.getType(),ForecastConstants.FORECAST_ARRIVE)){
				columnList.add("到达");
			}else{
				columnList.add("出发");
			}
			/** 
			 * 赋值 
			 */
			rowInTransitList.add(columnList);
		}
		ExportResource inTransit = new ExportResource();
		/** 
		 * 赋值 
		 */
		inTransit.setHeads(TransportPathConstants.INTRANSIT_ROW_HEADS);
		/** 
		 * 赋值 
		 */
		
		if(CollectionUtils.isEmpty(rowInTransitList)){
			rowInTransitList.add(new ArrayList<String>(0));
		}
		inTransit.setRowList(rowInTransitList);
		ArrayList<ExportResource> exportResources = new ArrayList<ExportResource>();
		/** 
		 * 赋值 
		 */
		exportResources.add(billing);
		/** 
		 * 赋值 
		 */
		exportResources.add(inTransit);
		ExportSetting exportSetting = new ExportSetting();
		exportSetting.setSize(TransportPathConstants.SHEET_SIZE);
		ExcelExporter objExcelExportor = new ExcelExporter();
		excelStream = objExcelExportor.exportBySheet(exportResources, exportSetting, new String[] { TransportPathConstants.BILLING_SHEET_NAME, TransportPathConstants.INTRANSIT_SHEET_NAME });
		return excelStream;
	}

	/**
	 * 根据组织code查询缓存获取name
	 * @author huyue
	 * @date 2013-1-22 下午3:42:47
	 */
	public String getNameByCode(String orgCode) {
		String orgName = orgAdministrativeInfoService.queryCommonNameByCommonCodeFromCache(orgCode);
		if (StringUtils.isEmpty(orgName)) {
			//如果没有名称则返回code
			return orgCode;
		} else {
			//否则返回名称
			return orgName;
		}
	}
	
	/**
	 * 统计货量查询
	 * 
	 * 分5个 货物状态 每个状态都是一种 应用场合
	 * 
	 * @author yuyongxiang
	 * @date 2013年7月8日 15:37:29
	 * (non-Javadoc)
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#queryStatisticalInquiries(com.deppon.foss.module.transfer.scheduling.api.shared.vo.ForecastVO)
	 */
	@Override
	@Transactional
	public ForecastVO queryStatisticalInquiries(ForecastVO forecastVO) {
		//封装 把前台传进来的参数设置一个别名(简化使用)
		StatisticalInquiriesDto stDto=forecastVO.getStatisticalInquiriesDto();
		//实例化查询参数
		Map<String, Object> queryMap=new HashMap<String, Object>();
		//分页设置
		queryMap.put("start", forecastVO.getStart());
		queryMap.put("limit", forecastVO.getLimit());
		//出发部门到达部门设置
		queryMap.put(origOrg, stDto.getTransforCenterCode());
		queryMap.put(objective, stDto.getArriveOrgCode());
		//设定运输性质
		List<String> strList=null;
		if("ALL".equals(stDto.getTransportModelCode())){
			//设定所有
			strList=new ArrayList<String>();
			//strList.add(ForecastConstants.FORECAST_PLF);
			strList.add(ForecastConstants.FORECAST_FLF);
			strList.add(ForecastConstants.FORECAST_FSF);
			strList.add(ForecastConstants.FORECAST_LRF);
			strList.add(ForecastConstants.FORECAST_SRF);
		}else{
			//依靠前台选择(前台的有单独的数据元,修改的时候要把前后台两个地方一起修改)
			strList=new ArrayList<String>(1);
			strList.add(stDto.getTransportModelCode());
		}
		
		/**
		 * 参数封装调整
		 */
		Map<String, String> map=new HashMap<String, String>();
		//map.put(ForecastConstants.FORECAST_PLF, ForecastConstants.FORECAST_PLF_NAME);
		map.put(ForecastConstants.FORECAST_FLF, ForecastConstants.FORECAST_FLF_NAME);
		map.put(ForecastConstants.FORECAST_FSF, ForecastConstants.FORECAST_FSF_NAME);
		map.put(ForecastConstants.FORECAST_LRF, ForecastConstants.FORECAST_LRF_NAME);
		map.put(ForecastConstants.FORECAST_SRF, ForecastConstants.FORECAST_SRF_NAME);
		
		//map.put(ForecastConstants.FORECAST_PLF_NAME, ForecastConstants.FORECAST_PLF);
		map.put(ForecastConstants.FORECAST_FLF_NAME, ForecastConstants.FORECAST_FLF);
		map.put(ForecastConstants.FORECAST_FSF_NAME, ForecastConstants.FORECAST_FSF);
		map.put(ForecastConstants.FORECAST_LRF_NAME, ForecastConstants.FORECAST_LRF);
		map.put(ForecastConstants.FORECAST_SRF_NAME, ForecastConstants.FORECAST_SRF);
		
		// 设置查询条件
		queryMap.put("strList", strList);
		
		//判定前台是否输入了配载方案,如果输入了则不加载默认的配载方案
		if (CollectionUtils.isEmpty(stDto.getArriveDeptList())) {
			List<String> temp = new ArrayList<String>();
			//把到达部门添加进去
			temp.add(stDto.getArriveOrgCode());
			//加载默认的配载方案
			List<String> stowagePlansList = stowagePlansService.queryStowageWithid(stDto.getTransforCenterCode(), stDto.getArriveOrgCode());
			if(CollectionUtils.isNotEmpty(stowagePlansList)){
				temp.addAll(new HashSet<String>(stowagePlansList));
			}
			stDto.setArriveDeptList(temp);
		} else if (CollectionUtils.isNotEmpty(stDto.getArriveDeptList())) {
			stDto.getArriveDeptList().add(stDto.getArriveOrgCode());
		}

		// 接收到达部门、配载部门所辐射的营业部的list
		List<String> arriveDeptList = new ArrayList<String>();
		for (String arriveDept : stDto.getArriveDeptList()) {

			// 获取该部门对象
			OrgAdministrativeInfoEntity orgEntity = orgAdministrativeInfoService
					.queryOrgAdministrativeInfoByCode(arriveDept);
			arriveDeptList.add(arriveDept);
			// 如果为外场，则获取其辐射的营业部code
			if (null != orgEntity
					&& StringUtils.equals(FossConstants.YES,
							orgEntity.getTransferCenter())) {
				List<String> list = lineService
						.queryArriveCodeListByTransferCode(arriveDept);
				arriveDeptList.addAll(list);
			}

		}
		// 设置查询条件
		queryMap.put("arriveDeptList", arriveDeptList);
		queryMap.put("startTime", stDto.getStartTime());
		queryMap.put("endTime", stDto.getEndTime());

		//处理5种状态,每种状态都是从不同的地方获取数据
		//PS: 数据源来自不同的地方所以这个地方数据处理要小心
		if(ForecastConstants.FORECAST_NO_TRANSFER_BILLING.equals(stDto.getGoodStatus())){
			/**1. 开单未交接 -> NOTRANSFERBILLING */
			queryMap.put(arriveOrLeave, TransportPathConstants.PATHDETAIL_STATUS_NOTLEAVE);

			List<String> transforCenterCodeList=new ArrayList<String>();
			
			// 获取该部门对象
			OrgAdministrativeInfoEntity orgEntity = orgAdministrativeInfoService
					.queryOrgAdministrativeInfoByCode(stDto.getTransforCenterCode());
			transforCenterCodeList.add(stDto.getTransforCenterCode());
			// 如果为外场，则获取其辐射的营业部code
			if (null != orgEntity
					&& StringUtils.equals(FossConstants.YES,
							orgEntity.getTransferCenter())) {
				List<NetGroupSiteDto> list = lineService
						.querySourceLineListByTransferCode(stDto.getTransforCenterCode(), DictionaryValueConstants.BSE_LINE_TRANSTYPE_QIYUN);
				
				List<String> listTemp=new ArrayList<String>();
				for(NetGroupSiteDto ngs : list){
					listTemp.add(ngs.getCode());
				}
				transforCenterCodeList.addAll(listTemp);
				queryMap.put("transferCenter", FossConstants.YES);
			}else{
				queryMap.put("transferCenter", null);
			}
			// 设置查询条件
			queryMap.put("transforCenterCodeList", transforCenterCodeList);
			
			//根据运单号和运输性质查询运单详细
			List<StatisticalInquiriesEntity> tempList = forecastQuantityDao.queryStatisticalInquiriesWithWayBillNo(queryMap);
			Map<String,Object> mapCount = forecastQuantityDao.queryStatisticalInquiriesWithWayBillNoCount(queryMap);
			
			//循环处理查询出来的数据
			for(StatisticalInquiriesEntity  statisticalInquiries:tempList){
				//根据code获取Name并且赋值
				statisticalInquiries.setTransportModelName(map.get(statisticalInquiries.getTransportModelCode()));
				//设定 货物状态
				statisticalInquiries.setGoodStatus(ForecastConstants.FORECAST_NO_TRANSFER_BILLING_NAME);
			}
			
			//临时变量赋值到展现层
			forecastVO.setStatisticalInquiriesEntityList(tempList);
			
			//赋值结果总数用于分页
			mapCount = this.objToString(mapCount);
			forecastVO.setTotalCount(String.valueOf(mapCount.get("WAYBILLNOCOUNT")));
			forecastVO.setWeightSum(String.valueOf(mapCount.get("WEIGHTSUM")));
			forecastVO.setVolumeSum(String.valueOf(mapCount.get("VOLUMESUM")));
			forecastVO.getStatisticalInquiriesDto().setGoodStatus(ForecastConstants.FORECAST_NO_TRANSFER_BILLING_NAME);

		}else if(ForecastConstants.FORECAST_NO_DEPARTURE_TRANSFER.equals(stDto.getGoodStatus())){
			/**2.交接未出发 ->  NODEPARTURETRANSFER */
			
			//设置查询条件
			List<String> handoverbillStateList = new ArrayList<String>(2);
			////20：已交接 //21：已配载 (集配交接单专属状态)
			handoverbillStateList.add(String.valueOf(LoadConstants.HANDOVERBILL_STATE_FORMAL_HANDOVER));
			handoverbillStateList.add(String.valueOf(LoadConstants.HANDOVERBILL_STATE_ALREADY_ASSEMBLE));

			//设置查询条件
			queryMap.put("handoverbillStateList", handoverbillStateList);
			queryMap.put("taskDetailStatus", "UNDEPART");
			queryMap.put("undepart", "Y");
			queryMap.put("ontheway", null);
			
			//根据交接单的状态查出所对应的运单
			List<StatisticalInquiriesEntity> statisticalInquiriesEntityList = forecastQuantityDao.queryStatisticalInquiriesWithHandover(queryMap);
			
			Map<String,Object> mapCount  = forecastQuantityDao.queryStatisticalInquiriesWithHandoverCount(queryMap);
			
			//循环处理查询出来的数据
			for(StatisticalInquiriesEntity  statisticalInquiries:statisticalInquiriesEntityList){
				//根据code获取Name并且赋值
				statisticalInquiries.setTransportModelName(map.get(statisticalInquiries.getTransportModelCode()));
				//设定 货物状态
				statisticalInquiries.setGoodStatus(ForecastConstants.FORECAST_NO_DEPARTURE_TRANSFER_NAME);
			}
			
			//临时变量赋值到展现层
			forecastVO.setStatisticalInquiriesEntityList(statisticalInquiriesEntityList);
			mapCount = this.objToString(mapCount);
			forecastVO.setTotalCount(String.valueOf(mapCount.get("WAYBILLNOCOUNT")));
			forecastVO.setWeightSum(String.valueOf(mapCount.get("WEIGHTSUM")));
			forecastVO.setVolumeSum(String.valueOf(mapCount.get("VOLUMESUM")));
			forecastVO.getStatisticalInquiriesDto().setGoodStatus(ForecastConstants.FORECAST_NO_DEPARTURE_TRANSFER_NAME);
		}else if(ForecastConstants.FORECAST_IN_TRANSIT.equals(stDto.getGoodStatus())){
			/**3.在途 -> INTRANSIT */
			//设置查询条件
			List<String> handoverbillStateList = new ArrayList<String>();
			////30 : 已出发
			handoverbillStateList.add(String.valueOf(LoadConstants.HANDOVERBILL_STATE_FORMAL_HANDOVER));
			handoverbillStateList.add(String.valueOf(LoadConstants.HANDOVERBILL_STATE_ALREADY_ASSEMBLE));
			handoverbillStateList.add(String.valueOf(LoadConstants.HANDOVERBILL_STATE_ALREADY_DEPART));
			
			//设置查询条件
			queryMap.put("handoverbillStateList", handoverbillStateList);
			queryMap.put("taskDetailStatus", "ONTHEWAY");
			queryMap.put("undepart", null);
			queryMap.put("ontheway", "Y");
			
			//根据交接单的状态查出所对应的运单
			List<StatisticalInquiriesEntity> statisticalInquiriesEntityList = forecastQuantityDao.queryStatisticalInquiriesWithHandover(queryMap);
			
			Map<String,Object> mapCount = forecastQuantityDao.queryStatisticalInquiriesWithHandoverCount(queryMap);
			
			//循环处理查询出来的数据
			for(StatisticalInquiriesEntity  statisticalInquiries:statisticalInquiriesEntityList){
				//根据code获取Name并且赋值
				statisticalInquiries.setTransportModelName(map.get(statisticalInquiries.getTransportModelCode()));
				//设定 货物状态
				statisticalInquiries.setGoodStatus(ForecastConstants.FORECAST_IN_TRANSIT_NAME);
			}
			
			//临时变量赋值到展现层
			forecastVO.setStatisticalInquiriesEntityList(statisticalInquiriesEntityList);
			mapCount = this.objToString(mapCount);
			forecastVO.setTotalCount(String.valueOf(mapCount.get("WAYBILLNOCOUNT")));
			forecastVO.setWeightSum((String) mapCount.get("WEIGHTSUM"));
			forecastVO.setVolumeSum((String) mapCount.get("VOLUMESUM"));
			forecastVO.getStatisticalInquiriesDto().setGoodStatus(ForecastConstants.FORECAST_IN_TRANSIT_NAME);
			
		}else if(ForecastConstants.FORECAST_UNLOADING_NOT_REACHED.equals(stDto.getGoodStatus())){
			/**4.到达未卸车 -> UNLOADINGNOTREACHED */
			//设置查询条件
			List<String> handoverbillStateList = new ArrayList<String>(1);
			////40 : 已到达
			handoverbillStateList.add(String.valueOf(LoadConstants.HANDOVERBILL_STATE_ALREADY_ARRIVE));
			queryMap.put("handoverbillStateList", handoverbillStateList);
			
			//根据交接单的状态查出所对应的运单
			List<StatisticalInquiriesEntity> statisticalInquiriesEntityList = forecastQuantityDao.queryStatisticalInquiriesWithUnloadingNotReach(queryMap);
			
			Map<String,Object> mapCount = forecastQuantityDao.queryStatisticalInquiriesWithUnloadingNotReachCount(queryMap);
			//循环处理查询出来的数据
			for(StatisticalInquiriesEntity  statisticalInquiries:statisticalInquiriesEntityList){
				//根据code获取Name并且赋值
				statisticalInquiries.setTransportModelName(map.get(statisticalInquiries.getTransportModelCode()));
				//设定 货物状态
				statisticalInquiries.setGoodStatus(ForecastConstants.FORECAST_UNLOADING_NOT_REACHED_NAME);
			}
			
			//临时变量赋值到展现层
			forecastVO.setStatisticalInquiriesEntityList(statisticalInquiriesEntityList);
			mapCount = this.objToString(mapCount);
			forecastVO.setTotalCount(String.valueOf(mapCount.get("WAYBILLNOCOUNT")));
			forecastVO.setWeightSum(String.valueOf(mapCount.get("WEIGHTSUM")));
			forecastVO.setVolumeSum(String.valueOf(mapCount.get("VOLUMESUM")));
			forecastVO.getStatisticalInquiriesDto().setGoodStatus(ForecastConstants.FORECAST_UNLOADING_NOT_REACHED_NAME);
			
		}else if(ForecastConstants.FORECAST_IN_LIBRARY.equals(stDto.getGoodStatus())){
			/**5. 统计货量查询 在库 -> INLIBRARY*/
			
			//根据交接单的状态查出所对应的运单
			List<StatisticalInquiriesEntity> statisticalInquiriesEntityList = forecastQuantityDao.queryStatisticalInquiriesWithInLibrary(queryMap);
			
			Map<String,Object> mapCount = forecastQuantityDao.queryStatisticalInquiriesWithInLibraryCount(queryMap);
			
			//循环处理查询出来的数据
			for(StatisticalInquiriesEntity  statisticalInquiries:statisticalInquiriesEntityList){
				//根据code获取Name并且赋值
				statisticalInquiries.setTransportModelName(map.get(statisticalInquiries.getTransportModelCode()));
				//设定 货物状态
				statisticalInquiries.setGoodStatus(ForecastConstants.FORECAST_IN_LIBRARY_NAME);
			}
			
			//临时变量赋值到展现层
			forecastVO.setStatisticalInquiriesEntityList(statisticalInquiriesEntityList);
			mapCount = this.objToString(mapCount);
			forecastVO.setTotalCount(String.valueOf(mapCount.get("WAYBILLNOCOUNT")));
			forecastVO.setWeightSum(String.valueOf(mapCount.get("WEIGHTSUM")));
			forecastVO.setVolumeSum(String.valueOf(mapCount.get("VOLUMESUM")));
			forecastVO.getStatisticalInquiriesDto().setGoodStatus(ForecastConstants.FORECAST_IN_LIBRARY_NAME);
			
		}else{
			throw new TfrBusinessException("请选择正确的货物状态!");
		}

		return forecastVO;
	}
	
	/**
	 * 导出统计货量查询到Excel
	 * @author yuyongxiang
	 * @date 2013年7月10日 19:37:00
	 * @see com.deppon.foss.module.transfer.scheduling.api.server.service.IForecastService#detailExportExcelStream(java.lang.String)
	 */
	@Override
	@Transactional
	public InputStream queryStatisticalInquiriesExcelStream(ForecastVO forecastVO) throws TfrBusinessException {
		InputStream excelStream = null;
		
		// 获取导出信息
		forecastVO.setLimit(ConstantsNumberSonar.SONAR_NUMBER_20000);
		forecastVO = this.queryStatisticalInquiries(forecastVO);
		List<StatisticalInquiriesEntity> statisticalInquiriesList = forecastVO.getStatisticalInquiriesEntityList();
		// 行List
		List<List<String>> rowStatisticalInquiriesList = new ArrayList<List<String>>();
		for (StatisticalInquiriesEntity statisticalInquiries : statisticalInquiriesList) {
			// 每行的列List
			List<String> columnList = new ArrayList<String>();
			
			//"运单号",
			if (null != statisticalInquiries.getWayBillNo()) {
				columnList.add(statisticalInquiries.getWayBillNo());
			} else {
				columnList.add(null);
			}
			//"运输性质",
			if (null != statisticalInquiries.getTransportModelName()) {
				columnList.add(statisticalInquiries.getTransportModelName());
			} else {
				columnList.add(null);
			}
			//"货物名称",
			if (null != statisticalInquiries.getGoodName()) {
				columnList.add(statisticalInquiries.getGoodName());
			} else {
				columnList.add(null);
			}
			//"货物状态",
			if (null != statisticalInquiries.getGoodStatus()) {
				columnList.add(statisticalInquiries.getGoodStatus());
			} else {
				columnList.add(null);
			}
			//"货物体积(方)",
			if (null != statisticalInquiries.getVolume()) {
				columnList.add(statisticalInquiries.getVolume().toString());
			} else {
				columnList.add(null);
			}
			//"货物重量(公斤)",
			if (null != statisticalInquiries.getWeight()) {
				columnList.add(statisticalInquiries.getWeight().toString());
			} else {
				columnList.add(null);
			}
			//"货物件数",
			if (null != statisticalInquiries.getGoodQty()) {
				columnList.add(statisticalInquiries.getGoodQty());
			} else {
				columnList.add(null);
			}
			//"出发部门",
			if (null != statisticalInquiries.getDestOrgName()) {
				columnList.add(statisticalInquiries.getDestOrgName());
			} else {
				columnList.add(null);
			}
			//"到达部门",
			if (null != statisticalInquiries.getArriveOrgName()) {
				columnList.add(statisticalInquiries.getArriveOrgName());
			} else {
				columnList.add(null);
			}
			//"开单时间",
			if (null != statisticalInquiries.getBillingTime()) {
				columnList.add(DateUtils.convert(statisticalInquiries.getBillingTime(), DateUtils.DATE_TIME_FORMAT));
			} else {
				columnList.add(null);
			}
			//"到达时间"
			if (null != statisticalInquiries.getArriveTime()) {
				columnList.add(DateUtils.convert(statisticalInquiries.getArriveTime(), DateUtils.DATE_TIME_FORMAT));
			} else {
				columnList.add(null);
			}
			
			rowStatisticalInquiriesList.add(columnList);
		}
		ExportResource statisticalInquiries = new ExportResource();
		statisticalInquiries.setHeads(TransportPathConstants.STATISTICALINQUIRIES_ROW_HEADS);
		if(CollectionUtils.isEmpty(rowStatisticalInquiriesList)){
			rowStatisticalInquiriesList.add(new ArrayList<String>(0));
		}
		statisticalInquiries.setRowList(rowStatisticalInquiriesList);
		ArrayList<ExportResource> exportResources = new ArrayList<ExportResource>();
		exportResources.add(statisticalInquiries);
		ExportSetting exportSetting = new ExportSetting();
		exportSetting.setSize(TransportPathConstants.SHEET_SIZE);
		ExcelExporter objExcelExportor = new ExcelExporter();
		excelStream = objExcelExportor.exportBySheet(exportResources, exportSetting, new String[] { forecastVO.getStatisticalInquiriesDto().getGoodStatus()});
		return excelStream;
	}
	
	/**
	 * 
	 * 处理map中的value==null 的时候转化为0
	 * 
	 * 
	 * @author 134019-foss-yuyongxiang
	 * @date 2013-9-10 上午10:36:02
	 * @param map
	 * @return
	 */
	private Map<String,Object> objToString(Map<String,Object> map){
		
		Map<String,Object> mapTemp=new HashMap<String, Object>();
		
		mapTemp.put("WAYBILLNOCOUNT", String.valueOf(map.get("WAYBILLNOCOUNT")));
		
		//
		if(null == map.get("WEIGHTSUM") ||"null".equalsIgnoreCase(map.get("WEIGHTSUM").toString())){
			mapTemp.put("WEIGHTSUM",String.valueOf(0));
		}else{
			mapTemp.put("WEIGHTSUM", String.valueOf(map.get("WEIGHTSUM")));
		}
		//
		if(null == map.get("VOLUMESUM") ||"null".equalsIgnoreCase(map.get("VOLUMESUM").toString())){
			mapTemp.put("VOLUMESUM", String.valueOf(0));
		}else{
			mapTemp.put("VOLUMESUM", String.valueOf(map.get("VOLUMESUM")));
		}
		
		
		return mapTemp;
	}
	
	
}
